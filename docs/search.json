[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "파이썬 프로그래밍 (2024)",
    "section": "",
    "text": "질문하는 방법\n\n이메일: guebin@jbnu.ac.kr\n직접방문: 자연과학대학 본관 205호\nZoom: 이메일로 미리 시간을 정할 것\n카카오톡: http://pf.kakao.com/_txeIFG/chat\n\n강의노트\n\n\n\n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nMay 3, 2024\n\n\n09wk-2: 중간고사\n\n\n최규빈 \n\n\n\n\nApr 26, 2024\n\n\n08wk-2: 랜덤모듈을 이용한 시뮬레이션 문제 예시\n\n\n최규빈 \n\n\n\n\nApr 24, 2024\n\n\n08wk-1: 퀴즈5\n\n\n최규빈 \n\n\n\n\nApr 19, 2024\n\n\n07wk-2: numpy (2)\n\n\n최규빈 \n\n\n\n\nApr 17, 2024\n\n\n07wk-1: 퀴즈4\n\n\n최규빈 \n\n\n\n\nApr 12, 2024\n\n\n06wk-2: numpy (1)\n\n\n최규빈 \n\n\n\n\nApr 5, 2024\n\n\n05wk-2: 파이썬의 자료형 (2)\n\n\n최규빈 \n\n\n\n\nMar 29, 2024\n\n\n04wk-2: 파이썬의 자료형 (1)\n\n\n최규빈 \n\n\n\n\nMar 27, 2024\n\n\n04wk-1: 퀴즈3\n\n\n최규빈 \n\n\n\n\nMar 22, 2024\n\n\n03wk-2: 리스트는 쓰레기인가?\n\n\n최규빈 \n\n\n\n\nMar 20, 2024\n\n\n03wk-1: 퀴즈2\n\n\n최규빈 \n\n\n\n\nMar 15, 2024\n\n\n02wk-2: 파이썬은 좋은 계산기다 (2)\n\n\n최규빈 \n\n\n\n\nMar 13, 2024\n\n\n02wk-1: 퀴즈1\n\n\n최규빈 \n\n\n\n\nMar 8, 2024\n\n\n01wk-2: 파이썬은 좋은 계산기다 (1)\n\n\n최규빈 \n\n\n\n\nMar 6, 2024\n\n\n01wk-1: 강의소개\n\n\n최규빈 \n\n\n\n\nDec 1, 2023\n\n\nA0: Quiz 1 (예상문제)\n\n\n최규빈 \n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/08wk-1.html",
    "href": "posts/08wk-1.html",
    "title": "08wk-1: 퀴즈5",
    "section": "",
    "text": "Caution\n\n\n\n\n전북대 학생들을 시험당일 학생증을 지참할 것. (출석체크 및 본인확인) 학생증 외에 신분증 여권등도 가능.\n부정행위 (카카오톡 채팅을 통한 코드공유, 생성형모델 사용, 대리시험 등) 적발시 F 처리함.\n퀴즈 중 지각할 경우 지각사실을 기록함. 하지만 별 다른 감점은 하지 않음.\n.ipynb 파일 형태로 제출된 답안지만 채점하며 그 외의 형식 (.hwp, .py 등)은 채점하지 않음. 즉 0점 처리함.\n\n\n\n\n1. – 20점\n앞으로 읽어도 뒤로 읽어도 동일한 단어이면 true 그렇지 않으면 false를 리턴하는 함수 solution를 구현하라. 아래는 이러한 함수 solution를 사용한 예시이다.\n\nlst1 = ['기러기', '토마토', '스위스', '인도인', '별똥별', '우영우', '파이썬']\nlst2 = ['level', 'radar', 'noon', 'deified', 'rotor', 'python']\n\n\n[solution(l) for l in lst1]\n\n[True, True, True, True, True, True, False]\n\n\n\n[solution(l) for l in lst2]\n\n[True, True, True, True, True, False]\n\n\n(풀이)\n\nsolution = lambda x: x[::-1] == x\n\n\n[solution(l) for l in lst1]\n\n[True, True, True, True, True, True, False]\n\n\n\n[solution(l) for l in lst2]\n\n[True, True, True, True, True, False]\n\n\n\n\n2. – 40점\n아홉개의 공이있다. 이 가운데 여덟개는 무게가 같고 하나는 남은 하나는 좀 더 무겁다. 우리에게는 저울이 하나 있는데 이 저울로는 왼쪽의 공들이 무거운지 오른쪽의 공들이 무거운지밖에 알아낼 수 없다. 이 저울을 딱 두번만 사용하여 가장 무거운 공을 찾아내는 알고리즘을 solution 함수로 정리하여 제시하라. 공들의 무게는 길이가 9인 리스트로 온다고 가정한다. 출력은 가장 무거운 공이 위치한 index를 리턴하도록 한다.\n다음은 solution 함수를 실제로 구현하여 사용한 예시이다.\n\nsolution([2,1,1,1,1,1,1,1,1])\n\n0\n\n\n\nsolution([2,2,5,2,2,2,2,2,2])\n\n2\n\n\n(풀이)\n\nhint: 공을 세 개씩 세 그룹으로 나누세요\n\n\ndef solution(lst):\n    l1,l2,l3 = lst[:3],lst[3:6],lst[6:]\n    argmax = 0 \n    if sum(l1)&gt;sum(l2): # 0,1,2 중 가장 무거운 공이 있음 \n        if l1[0] &gt; l1[1]:\n            argmax = 0\n        elif l1[0] &lt; l1[1]:\n            argmax = 1 \n        else: \n            argmax = 2 \n    elif sum(l1)&lt;sum(l2): # 3,4,5 중 가장 무거운 공이 있음 \n        if l2[0] &gt; l2[1]:\n            argmax = 0+3\n        elif l2[0] &lt; l2[1]:\n            argmax = 1+3 \n        else: \n            argmax = 2+3 \n    else: # 6,7,8 중 가장 무거운 공이 있음 \n        if l3[0] &gt; l3[1]:\n            argmax = 0+6\n        elif l3[0] &lt; l3[1]:\n            argmax = 1+6 \n        else: \n            argmax = 2+6\n    return argmax \n\n\nsolution([2,1,1,1,1,1,1,1,1])\n\n0\n\n\n\nsolution([2,2,5,2,2,2,2,2,2])\n\n2\n\n\n\n\n5. – 40점\n\n카카오 채용연계형 인턴쉽 기출문제\n\n네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다. 다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다.\n1478 --&gt; \"one4seveneight\"\n234567 --&gt; \"23four5six7\"\n10203 --&gt; \"1zerotwozero3\"\n이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 s가 매개변수로 주어집니다. s가 의미하는 원래 숫자를 return 하도록 solution 함수를 완성해주세요.\n참고로 각 숫자에 대응되는 영단어는 다음 표와 같습니다.\n\n\n\n숫자\n영단어\n\n\n\n\n0\nzero\n\n\n1\none\n\n\n2\ntwo\n\n\n3\nthree\n\n\n4\nfour\n\n\n5\nfive\n\n\n6\nsix\n\n\n7\nseven\n\n\n8\neight\n\n\n9\nnine\n\n\n\n- 제한사항\n\n1 ≤ s의 길이 ≤ 50\ns가 “zero” 또는 “0”으로 시작하는 경우는 주어지지 않습니다.\nreturn 값이 1 이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 s로 주어집니다.\n\n- 입출력 예\n\n\n\ns\nresult\n\n\n\n\n“one4seveneight”\n1478\n\n\n“23four5six7”\n234567\n\n\n“2three45sixseven”\n234567\n\n\n“123”\n123\n\n\n\n- 입출력 예 설명\n\n입출력 예 #1 – 문제 예시와 같습니다.\n입출력 예 #2 – 문제 예시와 같습니다.\n입출력 예 #3 – “three”는 3, “six”는 6, “seven”은 7에 대응되기 때문에 정답은 입출력 예 #2와 같은 234567이 됩니다. 입출력 예 #2와 #3과 같이 같은 정답을 가리키는 문자열이 여러 가지가 나올 수 있습니다.\n입출력 예 #4 – s에는 영단어로 바뀐 부분이 없습니다.\n\n(풀이)\nhint – 아래의 dictionary를 이용하세요\n\ndef solution(s):\n    dct = {\n        'zero': '0',\n        'one': '1',\n        'two': '2',\n        'three': '3',\n        'four': '4',\n        'five': '5',\n        'six': '6',\n        'seven': '7',\n        'eight': '8',\n        'nine': '9'\n    }\n    for k,v in dct.items():\n        s = s.replace(k,v)    \n    return s \n\n\nsolution(\"one4seveneight\")\n\n'1478'\n\n\n\nsolution(\"23four5six7\")\n\n'234567'\n\n\n\nsolution(\"2three45sixseven\")\n\n'234567'\n\n\n\nsolution(\"123\")\n\n'123'"
  },
  {
    "objectID": "posts/02wk-1.html",
    "href": "posts/02wk-1.html",
    "title": "02wk-1: 퀴즈1",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt \n\n\n\n\n\n\n\nWarning\n\n\n\n\n모든 문항은 부분점수 없음.\n일부문항은 부분문제를 모두 맞출경우만 정답으로 인정함.\n.ipynb 파일 형태로 제출된 답안지만 채점하며 그 외의 형식 (.hwp등)은 채점하지 않음. 즉 0점 처리함. 제출방법 모르면 물어볼것!\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n전북대 학생들을 시험당일 학생증을 지참할 것. (출석체크 및 본인확인) 학생증 외에 신분증 여권등도 가능.\n부정행위 (카카오톡 채팅을 통한 코드공유, 생성형모델 사용, 대리시험 등) 적발시 F 처리함.\n퀴즈 중 지각할 경우 지각사실을 기록함. 하지만 별다른 감점은 하지 않음.\n\n\n\n\n문제 1. – 10점\n\n모두 맞출 경우만 정답으로 인정\n\n(1) 아래와 같이 50개의 숫자를 나열한 배열 \\({\\bf x}=[x_1,x_2,\\dots,x_n]\\)을 상상하자.\n\nx = np.array([0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1,\n              0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,\n              0, 0, 0, 0, 1, 0])\nx\n\narray([0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1,\n       0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,\n       0, 0, 0, 0, 1, 0])\n\n\n위와 같은 \\(x_i\\)에 대하여 \\(0&lt;p&lt;1\\)에서의 아래와 같은 함수 \\(l(p)\\)를 정의하라.\n\\[l(p)=\\sum_{i=1}^nx_i \\log p +\\left(n-\\sum_{i=1}^{n}x_i \\right)\\log(1-p)\\]\n파이썬을 이용하여 아래를 근사계산하라.\n\\[\\lim_{h \\to 0}\\frac{l(0.32+h)-l(0.32)}{h}\\]\n(풀이)\n\nl = lambda p: 16*np.log(p) + (50-16)*np.log(1-p)\nh =0.000000001\n(l(0.32+h)-l(0.32))/h\n\n3.5527136788005005e-06\n\n\n(2) \\(0&lt;p&lt;1\\)의 범위에서 \\(l(p)\\)를 최대로 만드는 \\(p\\)의 값을 구하라. 즉 \\(\\underset{p}{\\operatorname{argmax}} l(p)\\)를 구하라.\n(풀이)\n\np = np.linspace(1/100,1,100)[:-1]\np\n\narray([0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1 , 0.11,\n       0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.2 , 0.21, 0.22,\n       0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3 , 0.31, 0.32, 0.33,\n       0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4 , 0.41, 0.42, 0.43, 0.44,\n       0.45, 0.46, 0.47, 0.48, 0.49, 0.5 , 0.51, 0.52, 0.53, 0.54, 0.55,\n       0.56, 0.57, 0.58, 0.59, 0.6 , 0.61, 0.62, 0.63, 0.64, 0.65, 0.66,\n       0.67, 0.68, 0.69, 0.7 , 0.71, 0.72, 0.73, 0.74, 0.75, 0.76, 0.77,\n       0.78, 0.79, 0.8 , 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87, 0.88,\n       0.89, 0.9 , 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99])\n\n\n\np[np.argmax(l(p))]\n\n0.32\n\n\n\n\n문제 2. – 10점\n\n모두 맞출 경우만 정답으로 인정\n\n길이가 100인 벡터 \\({\\bf x} = [x_0, x_1, \\dots, x_{99}]\\)를 아래와 같이 선언하라.\n\nnp.random.seed(43052)\nx = np.random.randn(100)\n\n(1) \\(x_0\\)의 값은 얼마인가?\n(풀이)\n\nx[0]\n\n0.38342048800857303\n\n\n(2) \\(x_{99}\\)의 값은 얼마인가?\n(풀이)\n\nx[99]\n\n1.1870144262405193\n\n\n(3) \\(\\sum_{i=0}^{99} x_i\\)의 값은 얼마인가?\n(풀이)\n\nnp.sum(x)\n\n-8.136079223187856\n\n\n(4) \\(\\sum_{i=22}^{55} x_i\\)의 값은 얼마인가?\n(풀이)\n\nnp.sum(x[22:56])\n\n-1.1780743585314586\n\n\n\n\n문제 3. – 10점\n길이가 100인 벡터 \\({\\bf x} = [x_0, x_1, \\dots, x_{99}]\\)를 아래와 같이 선언하라.\n\nnp.random.seed(43052)\nx = np.random.randn(100)\n\n이 벡터에 대하여\n\n\\(a=\\sum_{i=0}^{24}x_i\\)\n\\(b=\\sum_{i=25}^{49}x_i\\)\n\\(c=\\sum_{i=50}^{74}x_i\\)\n\\(d=\\sum_{i=75}^{99}x_i\\)\n\n의 값을 각각 조사하라. a,b,c,d 중 가장 큰 값은 무엇인가?\n(풀이)\n\na = np.sum(x[:25])\nb = np.sum(x[25:50])\nc = np.sum(x[50:75])\nd = np.sum(x[75:])\n\n\na,b,c,d\n\n(-3.006728261055644,\n 0.3368136525904264,\n -4.526860531092521,\n -0.9393040836301192)\n\n\n\n\n문제 4. – 10점\n\n모두 맞출 경우만 정답으로 인정\n\n(1) lambda를 이용하여 \\(f(x)=\\sin(x)\\)에 대응하는 함수를 선언하라.\n(풀이)\n\nlambda x: np.sin(x)\n\n&lt;function __main__.&lt;lambda&gt;(x)&gt;\n\n\n(2) def를 이용하여 \\(g(x)=\\cos(2x)\\)에 대응하는 함수를 선언하라.\n(풀이)\n\ndef g(x):\n    return np.cos(2*x)\n\n(3) 임의의 벡터 \\({\\bf x}=[x_0,\\dots,x_{n-1}]\\) 이 왔을때, \\({\\bf x}\\)의 최대값을 \\(x_{max}\\) 라고 하고 최소값을 \\(x_{min}\\)이라고 하자. 예를들어\n\\[{\\bf x} = [1,2,3,0]\\]\n의 경우 \\(x_{max}=3\\) 이고 \\(x_{min}=0\\) 이다. 벡터 \\({\\bf x}\\)를 입력으로 하고 출력으로 \\(x_{max}-x_{min}\\)의 계산값을 리턴하는 함수를 구현하라.\n(풀이)\n\nf = lambda x: np.max(x) - np.min(x)\n\n\nf([1,2,3,0])\n\n3\n\n\n\nf([-1,2,4,10])\n\n11\n\n\n\n\n문제 5. – 10점\n\n모두 맞출 경우만 정답으로 인정\n\n아래의 코드를 실행하여 x를 생성하라.\n\nnp.random.seed(43052)\nx = np.random.rand(4305)\n\n(1) 생성된 \\(x_i\\) 중 0.65와 가장 가까운 값을 출력하라.\n(풀이)\n\nx[np.argmin(np.abs(x-0.65))]\n\n0.6499741766686671\n\n\n(2) 생성된 값의 평균을 구하라.\nhint \\(\\frac{1}{4305}\\sum_{i=1}^{4305}x_i\\)를 계산하면 된다. 아니면 np.mean() 함수를 이용해도된다.\n(풀이)\n\nnp.sum(x)/4305, np.mean(x)\n\n(0.4965974918744432, 0.4965974918744432)\n\n\n(3) (2)에서 계산된 평균값과 가장 가까운 \\(x_i\\)값을 출력하라.\n(풀이)\n\nx[np.argmin(np.abs(x-np.mean(x)))]\n\n0.497315535600802\n\n\n\n\n문제 6. – 20점\n\\(\\frac{\\pi}{2}\\leq x \\leq \\pi\\) 에서 \\(f(x)=\\sin(\\frac{3}{2}x)\\) 와 \\(g(x)=\\cos(2x)\\sin(5x)\\) 의 교점의 좌표를 구하라.\n\n근사값만구해도 정답으로 인정함\n\n(풀이)\n\nx = np.linspace(np.pi/2, np.pi,1000000)\nf = lambda x: np.sin(3/2*x) \ng = lambda x: np.cos(2*x)*np.sin(5*x)\n\n\nplt.plot(x,f(x))\nplt.plot(x,g(x))\n\n\n\n\n\n\n\n\n\nxx = x[np.argmin(np.abs(f(x)-g(x)))]\nxx\n\n1.9462123119258816\n\n\n\nf(xx), g(xx)\n\n(0.2204484288597834, 0.2204457729878962)\n\n\n\n\n문제 7. – 30점\n(1) 무한급수 \\(\\sum_{n=1}^{\\infty}(\\frac{1}{2})^n\\) 의 수렴 및 발산을 파이썬을 이용하여 판정하라. – 10점\n힌트\n\\(n=10, 20, 30, ..., 100\\) 등에서 \\(S_n=\\sum_{k=1}^{n}a_k\\)의 값을 조사해보고 수렴성을 판단하라.\n(풀이)\n\nn = np.linspace(1,100,100)\nan = (1/2)**n\nSn = np.cumsum(an)\n\n\nSn\n\narray([0.5       , 0.75      , 0.875     , 0.9375    , 0.96875   ,\n       0.984375  , 0.9921875 , 0.99609375, 0.99804688, 0.99902344,\n       0.99951172, 0.99975586, 0.99987793, 0.99993896, 0.99996948,\n       0.99998474, 0.99999237, 0.99999619, 0.99999809, 0.99999905,\n       0.99999952, 0.99999976, 0.99999988, 0.99999994, 0.99999997,\n       0.99999999, 0.99999999, 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ])\n\n\n수렴한다\n(2) 무한급수 \\(\\sum_{n=1}^{\\infty}\\frac{1}{n}\\) 의 수렴 및 발산을 파이썬을 이용하여 판정하라. – 20점\n힌트 – (1)번과 동일한 테크닉\n(풀이)\n\nn = np.linspace(1,100000000,100000000)\nan = 1/n\nSn = np.cumsum(an)\n\n\nSn\n\narray([ 1.        ,  1.5       ,  1.83333333, ..., 18.99789639,\n       18.9978964 , 18.99789641])\n\n\n발산한다\n\n\n성적분포\n\nimport pandas as pd\n\n\npd.read_csv(\"2wk.csv\")['2wk'].sort_values().to_numpy()\n\narray([  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n         0,   0,   0,  10,  10,  10,  20,  20,  20,  20,  20,  30,  30,\n        30,  30,  40,  40,  40,  40,  40,  50,  50,  50,  50,  50,  50,\n        50,  60,  60,  60,  70,  70,  80,  80,  80,  90,  90, 100, 100,\n       100, 100, 100, 100])"
  },
  {
    "objectID": "posts/09wk-2.html",
    "href": "posts/09wk-2.html",
    "title": "09wk-2: 중간고사",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport urllib.request\nimport requests\nimport PIL\nimport io\n\n\n1. 학번소개 – 40점\n\n\n20점, (2) 20점\n\n\n아래의 코드를 실행하여 MNIST 자료를 불러오라.\n\n# URL 설정\nurl = 'https://github.com/guebin/PP2023/raw/main/posts/02_DataScience/mnist.npz'\n\n# URL에서 파일 다운로드\nurllib.request.urlretrieve(url, './mnist.npz')\n\n# 데이터 로드\ndata = np.load('./mnist.npz')\nxtrain, ytrain, xtest, ytest = data['x_train']/255, data['y_train'], data['x_test']/255, data['y_test']\n\n# mnist.npz 삭제\n!rm mnist.npz\n\n(1) xtrain, xtest, ytrain, ytest 의 shape은 각각 아래와 같다.\n\nxtrain.shape, xtest.shape, ytrain.shape, ytest.shape\n\n((60000, 28, 28), (10000, 28, 28), (60000,), (10000,))\n\n\nxtrain, xtest를 합쳐서 shape이 (70000,28,28) 인 numpy array를 생성하고 이것을 X에 저장하라. 저장된 X에서 각 숫자의 평균이미지를 구하고 평균이미지를 좌우로 붙여 본인의 학번 마지막 5자리를 출력하라. (충남대 학생들은 충남대 학번으로 쓰셔도 괜찮습니다)\n(풀이)\n\nX = np.concatenate([xtrain,xtest],axis=0)\ny = np.concatenate([ytrain,ytest])\n\n\nlst = [\n    X[y == 4].mean(axis=0),\n    X[y == 3].mean(axis=0),\n    X[y == 0].mean(axis=0),\n    X[y == 5].mean(axis=0),\n    X[y == 2].mean(axis=0)\n]\nimg = np.concatenate(lst,axis=-1)\n\n\nplt.imshow(img,cmap=\"gray\")\n\n\n\n\n\n\n\n\n(2) (1)에서 구한 평균이미지와 가장 차이가 작은 이미지를 숫자별로 찾고, 이를 이어서 (1)처럼 본인의 학번 마지막 5개의 숫자를 출력하라. 이때 평균이미지와 가장 차이가 작은 이미지는 픽셀별로 차이를 제곱한뒤 평균을 내서 계산한다. (07wk-2 // 5.numpy활용 // C.MNIST data // (5)번 문항을 참고할 것)\n(풀이)\n\nlst = [\n    X[y == 4][((X[y == 4] - X[y == 4].mean(axis=0))**2).mean(axis=(1,2)).argmin()],\n    X[y == 3][((X[y == 3] - X[y == 3].mean(axis=0))**2).mean(axis=(1,2)).argmin()],\n    X[y == 0][((X[y == 0] - X[y == 0].mean(axis=0))**2).mean(axis=(1,2)).argmin()],\n    X[y == 5][((X[y == 5] - X[y == 5].mean(axis=0))**2).mean(axis=(1,2)).argmin()],\n    X[y == 2][((X[y == 2] - X[y == 2].mean(axis=0))**2).mean(axis=(1,2)).argmin()],\n]\nimg = np.concatenate(lst,axis=-1)\n\n\nplt.imshow(img,cmap=\"gray\")\n\n\n\n\n\n\n\n\n\n\n2. 아름다운 부산 – 40점\n\n(1)-(2) 모두 맞출 경우만 정답으로 인정\n\n아래의 코드를 실행하여 부산의 야경을 불러오라.\n\nurl = 'https://cdn.pixabay.com/photo/2016/10/17/07/53/busan-night-scene-1747130_1280.jpg'\nimg = np.array(PIL.Image.open(io.BytesIO(requests.get(url).content)))/255\nplt.imshow(img)\n\n\n\n\n\n\n\n\n\nimg.shape\n\n(854, 1280, 3)\n\n\n(1) 위의 이미지의 Red,Green,Blue 에 해당하는 array 를 변수 R, G, B 에 저장하라. 아래의 공식을 이용하여 새로운 numpy array Gray를 만들고 이를 출력하라.\n\\[Gray = 0.2989 \\times R + 0.5870 \\times G + 0.1140 \\times B\\]\n여기에서 R,G,B,Gray는 모두 shape이 (854,1280) 인 numpy array 이다.\n(풀이)\n\nR,G,B = img[:,:,0],img[:,:,1],img[:,:,2]\nGray = 0.2989*R + 0.5870*G + 0.1140*B \nplt.imshow(Gray,cmap=\"gray\")\n\n\n\n\n\n\n\n\n(2) R,G,B 에 대하여 아래의 슈도-알고리즘과 동등한 처리를 np.where을 이용하여 수행하라. 편의상 아래의 알고리즘에서 R,G,B는 변수 Ch로 생각한다.\nch_min = np.min(Ch[0:587, 948:1210])\nch_max = np.max(Ch[0:587, 948:1210]) \nfor i in range(854):\n    for j in range(1280):\n        if ch_min &lt; Ch[i,j] &lt; ch_max:\n            Ch[i,j] = Gray[i,j]\n        else: \n            Ch[i,j] = Ch[i,j]\n위의 알고리즘을 각각 R, G, B에 적용하였으면 변화된 R,G,B를 합쳐서 하나의 칼라이미지를 만들고 출력하라.\n(풀이)\n\ndef f(Ch):\n    ch_min = np.min(Ch[0:587, 948:1210])\n    ch_max = np.max(Ch[0:587, 948:1210]) \n    Ch = np.where((ch_min &lt; Ch) & (Ch &lt; ch_max), Gray, Ch)\n    return Ch\nsolution = np.stack(list(map(f,[R,G,B])),axis=-1) \nplt.imshow(solution)\n\n\n\n\n\n\n\n\n\n\n3. 공든탑쌓기 – 120점\n규빈과 다호가 블록을 사용하여 탑을 쌓는다. 규빈은 한 번에 2개의 블록을 사용하여 탑을 쌓지만, 실수로 탑을 무너뜨릴 확률이 50%이다. 한 번 무너진 탑은 다시 처음부터 쌓아야 한다. 다호는 한 번에 1개의 블록을 사용하여 신중하게 탑을 쌓는다. 다호는 천천히 탑을 쌓지만 실수로 탑을 무너뜨리지 않는다.\n\n(1)번은 0점, (2)-(3)을 모두 맞출경우 60점, (2)-(4)를 모두 맞출경우 120점\n\n(1) 규빈과 다호가 2층 높이의 탑을 먼저 쌓는 내기를 하였다고 하자. 탑을 쌓을수 있는 기회는 2회 준다. 이 내기는 누가 유리한가? 시뮬레이션을 통하여 근거를 설명하라. (둘이 동시에 탑을 쌓을경우 무승부로 판단한다.)\n힌트: 시뮬레이션 결과는 아래와 같다. 따라서 규빈이 유리하다.\n\n{'무승부 (둘이 동시에 성공)': 25063, '다호승': 24845, '규빈승': 50092}\n\n{'무승부 (둘이 동시에 성공)': 25063, '다호승': 24845, '규빈승': 50092}\n\n\n(2) 규빈과 다호가 10층 높이의 탑을 먼저 쌓는 내기를 하였다고 하자. 탑을 쌓을수 있는 기회는 10회 준다. 이 내기는 누가 유리한가? 시뮬레이션을 통하여 근거를 설명하라. (둘이 동시에 탑을 쌓을경우 무승부로 판단한다.)\n힌트: 시뮬레이션 결과는 아래와 같다. 따라서 다호가 유리하다.\n\n{'무승부 (둘이 동시에 성공)': 1580, '다호승': 89045, '규빈승': 9375}\n\n{'무승부 (둘이 동시에 성공)': 1580, '다호승': 89045, '규빈승': 9375}\n\n\n(3) 규빈은 (2)의 게임을 반복하다가 본인이 불리하다는 사실을 알고 분노했다. 흑화한 규빈은 매번 50%의 확률로 다호의 탑을 공격하기로 하였다. 공격 성공률은 60% 이며 공격이 성공시 다호의 탑은 모두 무너진다. (단, 공격시 규빈은 탑을 쌓을 수 없다) 규빈과 다호에게 탑을 쌓거나 상대방의 탑을 공격할 기회를 20회 준다고 가정하자. 이 내기는 누가 유리한가? 시뮬레이션을 통하여 근거를 설명하라. (둘이 동시에 탑을 쌓거나 둘 모두 탑을 쌓지 못할 경우 무승부로 판단한다.)\n힌트: 시뮬레이션 결과는 아래와 같다. 유불리가 비슷하다.\n\n{'무승부 (둘이 동시에 성공)': 133, '무승부 (둘다 쌓지 못함)': 79385, '다호승': 10165, '규빈승': 10317}\n\n{'무승부 (둘이 동시에 성공)': 133, '무승부 (둘다 쌓지 못함)': 79385, '다호승': 10165, '규빈승': 10317}\n\n\n(4) 규빈은 공격을 하는사이에 본인의 탑을 쌓지 못하게 되자 전략을 바꾸었다. 다호의 탑을 관찰하며, 다호의 탑이 5층 이상인 경우에만 공격하기로 하였다. 이 경우 규빈과 다호에게 탑을 쌓거나 상대방의 탑을 공격할 기회를 20회 준다고 가정하면 누가 유리한가? 시뮬레이션을 통하여 근거를 설명하라. (둘이 동시에 탑을 쌓거나 둘 모두 탑을 쌓지 못할 경우 무승부로 판단한다.)\n힌트: 시뮬레이션 결과는 아래와 같다. 규빈이 유리하다.\n\n{'무승부 (둘다 쌓지 못함)': 79324, '다호승': 1950, '규빈승': 18726}\n\n{'무승부 (둘다 쌓지 못함)': 79324, '다호승': 1950, '규빈승': 18726}"
  },
  {
    "objectID": "posts/01wk-1.html",
    "href": "posts/01wk-1.html",
    "title": "01wk-1: 강의소개",
    "section": "",
    "text": "1. 전북대 + 충남대\n- 전북대는 전북대학생끼리 성적평가.\n- 충남대는 충남대학생끼리 성적평가.\n- 충남대 학생의 경우 교양과목임을 감안하여 채점할 예정임.\n\n\n2. 플립러닝\n- 수업: 매주 금요일 오후까지 강의홈페이지에 업로드 될 예정.\n\n수업은 영상업로드 방식 (각자 수강)\n영상시청에 대한 별도의 출석체크는 없음.\n\n- 퀴즈: 매주 수요일 수업시간에 퀴즈를 볼 예정임.\n\n시험은 오픈북이며 구글검색, 강의노트 참고등을 허용함.\nChatGPT는 허용하지 않음.\n\n\n\n3. 성적처리 방식\n- 출석 10%, 퀴즈 50%, 중간 20%, 기말 20%\n\n출석은 매주 수요일 퀴즈시간에 체크할 예정임. (따라서 퀴즈를 보면 출석점수는 자동으로 인정)\n사실상 퀴즈의 점수비중이 60%"
  },
  {
    "objectID": "posts/02wk-2.html#a.-int-float-bool",
    "href": "posts/02wk-2.html#a.-int-float-bool",
    "title": "02wk-2: 파이썬은 좋은 계산기다 (2)",
    "section": "A. int, float, bool",
    "text": "A. int, float, bool\n- int형\n\na=100\n\n\ntype(a)\n\nint\n\n\n- float형\n\na=1.2*3\na\n\n3.5999999999999996\n\n\n\ntype(a)\n\nfloat\n\n\n\na?\n\n\nType:        float\nString form: 3.5999999999999996\nDocstring:   Convert a string or number to a floating point number, if possible.\n\n\n\n- bool형\n\na=True ## 숫자1으로 생각할 수 있음 \nb=False ## 숫자0으로 생각할 수 있음\n\n\ntype(a)\n\nbool\n\n\n\ntype(b)\n\nbool\n\n\n\na?\n\n\nType:        bool\nString form: True\nDocstring:  \nbool(x) -&gt; bool\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.\n\n\n\n\nb?\n\n\nType:        bool\nString form: False\nDocstring:  \nbool(x) -&gt; bool\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.\n\n\n\n- bool형의 연산\n\na=True ## 1\nb=False ## 0 \n\n\na+b\n\n1\n\n\n\na*b \n\n0\n\n\n- 형태변환: float \\(\\to\\) int\n(예시1)\n\na=3.0\ntype(a)\n\nfloat\n\n\n\na=int(a)\n\n\ntype(a)\n\nint\n\n\n(예시2) 이경우는 정보의 손실이 발생\n\na=3.14 \nint(a)\n\n3\n\n\n- 형태변환: int \\(\\to\\) float\n\na=3\ntype(a)\n\nint\n\n\n\na=float(a)\ntype(a)\n\nfloat\n\n\n- 형태변환: bool \\(\\to\\) int/float, int/float \\(\\to\\) bool\n(예시1)\n\na=True\ntype(a)\n\nbool\n\n\n\nint(a)\n\n1\n\n\n\nfloat(a)\n\n1.0\n\n\n(예시2)\n\na=1 \nbool(a)\n\nTrue\n\n\n\na=0\nbool(a)\n\nFalse\n\n\n(예시3)\n\na=1.0\nbool(a)\n\nTrue\n\n\n\na=0.0\nbool(a)\n\nFalse"
  },
  {
    "objectID": "posts/02wk-2.html#b.-1차원-자료의-형태변환",
    "href": "posts/02wk-2.html#b.-1차원-자료의-형태변환",
    "title": "02wk-2: 파이썬은 좋은 계산기다 (2)",
    "section": "B. 1차원 자료의 형태변환",
    "text": "B. 1차원 자료의 형태변환\n- list \\(\\to\\) np.array\n\n[1,2,3]\n\n[1, 2, 3]\n\n\n\nnp.array([1,2,3])\n\narray([1, 2, 3])\n\n\n- np.array \\(\\to\\) list\n\nnp.linspace(1,10,10)\n\narray([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.])\n\n\n\nlist(np.linspace(1,10,10))\n\n[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]\n\n\n- range \\(\\to\\) list, np.array\n\nrange(10) # 이게 뭐야??\n\nrange(0, 10)\n\n\n\nlist(range(10)) # 리스트화 \n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nnp.array(range(10)) # 넘파이배열화\n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\n보충학습: range의 다양한 활용을 익혀보자.\n\nlist(range(10))\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nlist(range(0,10))\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nlist(range(3,10))\n\n[3, 4, 5, 6, 7, 8, 9]\n\n\n\nlist(range(3,10,2))\n\n[3, 5, 7, 9]\n\n\n- map 결과물 \\(\\to\\) list\n\nf = lambda x: x**2\nlist(map(f,[1,2,3])) # [f(1),f(2),f(3)]\n\n[1, 4, 9]\n\n\n- map 결과물 \\(\\to\\) np.array로는 불가능\n\nf = lambda x: x**2\nnp.array(map(f,[1,2,3]))\n\narray(&lt;map object at 0x7f3a09e887f0&gt;, dtype=object)\n\n\n\n# 아래는 가능 \nf = lambda x: x**2\nnp.array(list(map(f,[1,2,3])))\n\narray([1, 4, 9])"
  },
  {
    "objectID": "posts/02wk-2.html#a.-np.random.rand",
    "href": "posts/02wk-2.html#a.-np.random.rand",
    "title": "02wk-2: 파이썬은 좋은 계산기다 (2)",
    "section": "A. np.random.rand()",
    "text": "A. np.random.rand()\n- 0~1 사이에서 10개의 난수생성\n\nnp.random.rand(10)\n\narray([0.43345371, 0.48324862, 0.48046707, 0.41056049, 0.56188841,\n       0.58762904, 0.6645858 , 0.60568829, 0.83033841, 0.4660302 ])\n\n\n- 0~2 사이에서 10개의 난수생성\n\nnp.random.rand(10)*2\n\narray([0.44894259, 1.8416822 , 0.50164259, 1.01601855, 0.21073439,\n       1.8049244 , 0.86548008, 0.38544391, 0.13816874, 1.22858088])\n\n\n- 1~3 사이에서 10개의 난수생성\n\nnp.random.rand(10)*2 + 1\n\narray([1.58013021, 1.96358901, 2.62137695, 1.74617053, 2.38021729,\n       1.00043864, 1.42801985, 1.65666288, 2.80405753, 1.23691426])"
  },
  {
    "objectID": "posts/02wk-2.html#b.-np.random.randn",
    "href": "posts/02wk-2.html#b.-np.random.randn",
    "title": "02wk-2: 파이썬은 좋은 계산기다 (2)",
    "section": "B. np.random.randn()",
    "text": "B. np.random.randn()\n- N(0,1)에서 10개의 난수생성\n\nnp.random.randn(10) # 표준정규분포에서 10개의 샘플 추출 \n\narray([-0.88043002, -0.75000612, -0.46393189,  0.73721724, -0.66208613,\n        0.84740615, -0.31835775,  0.60157946,  0.62744116,  2.06223706])\n\n\n- N(1,1)에서 10개 난수생성\n\nnp.random.randn(10) + 1\n\narray([ 1.50801901,  0.06945884,  2.52305677,  0.25080242, -0.25058225,\n        1.81696343, -0.47341629,  0.51879014,  2.55038708,  0.58788704])\n\n\n- N(0,4) 에서 10개 난수생성\n\nnp.random.randn(10)*2\n\narray([-2.26593271, -1.62304968, -1.71372316,  2.93723947,  0.63497107,\n        2.96605112,  0.71536533,  2.64037886,  0.10782247, -2.97822434])\n\n\n- N(3,4) 에서 10개 난수생성\n\nnp.random.randn(10)*2+3 \n\narray([ 3.71923104,  1.77496469,  4.04116354,  4.27443252,  2.59130929,\n        5.48551961, -1.09164073,  3.08090641,  0.88721243,  3.34579357])"
  },
  {
    "objectID": "posts/02wk-2.html#c.-np.random.randint",
    "href": "posts/02wk-2.html#c.-np.random.randint",
    "title": "02wk-2: 파이썬은 좋은 계산기다 (2)",
    "section": "C. np.random.randint()",
    "text": "C. np.random.randint()\n- [0,7) 에서 10개의 정수생성\n\nnp.random.randint(0,7,size=10) # [0,7)의 범위에서 10개의 정수 생성 \n\narray([0, 1, 5, 0, 2, 3, 1, 3, 0, 5])\n\n\n- [10,20) 에서 10개의 정수생성\n\nnp.random.randint(10,20,size=10) # [0,7)의 범위에서 10개의 정수 생성 \n\narray([11, 10, 10, 19, 13, 11, 11, 11, 15, 19])"
  },
  {
    "objectID": "posts/02wk-2.html#d.-np.random.choice",
    "href": "posts/02wk-2.html#d.-np.random.choice",
    "title": "02wk-2: 파이썬은 좋은 계산기다 (2)",
    "section": "D. np.random.choice()",
    "text": "D. np.random.choice()\n- [11,22,33] 에서 중복허용하여 20개 추출\n\nnp.random.choice([11,22,33],20) \n\narray([33, 33, 11, 33, 11, 11, 33, 22, 11, 33, 33, 33, 22, 33, 11, 11, 22,\n       22, 33, 22])\n\n\n- [11,22,33] 에서 중복허용하여 3개 추출\n\nnp.random.seed(4)\nnp.random.choice([11,22,33],3) \n\narray([33, 33, 22])\n\n\n\nnp.random.seed(5)\nnp.random.choice([11,22,33],3) \n\narray([33, 22, 33])\n\n\n- [11,22,33] 에서 중복허용하지 않고 3개 추출\n\nnp.random.choice([11,22,33],3,replace=False) \n\narray([22, 33, 11])"
  },
  {
    "objectID": "posts/04wk-1.html",
    "href": "posts/04wk-1.html",
    "title": "04wk-1: 퀴즈3",
    "section": "",
    "text": "Caution\n\n\n\n\n전북대 학생들을 시험당일 학생증을 지참할 것. (출석체크 및 본인확인) 학생증 외에 신분증 여권등도 가능.\n부정행위 (카카오톡 채팅을 통한 코드공유, 생성형모델 사용, 대리시험 등) 적발시 F 처리함.\n퀴즈 중 지각할 경우 지각사실을 기록함. 하지만 별 다른 감점은 하지 않음.\n.ipynb 파일 형태로 제출된 답안지만 채점하며 그 외의 형식 (.hwp, .py 등)은 채점하지 않음. 즉 0점 처리함.\n\n\n\n\nimport itertools\n\n\n1. – 10점\n4개의 문자 \\(x,x,y,y\\) 를 모두 일렬로 나열하는 경우의 수를 파이썬을 이용하여 구하여라.\n\nitertools.permutations()을 이용할 것.\n\nhint: 답은 \\(\\frac{4!}{2!2!}=6\\) 이다.\n(풀이)\n\nlen(set([''.join(i) for i in itertools.permutations('xxyy')]))\n# len(set([i for i in itertools.permutations('xxyy')])) &lt;-- 이렇게 해도 결과는 같음\n\n6\n\n\n\n\n2. – 10점\n리스트 컴프리헨션을 이용하여 \\(a_n=\\frac{1}{n(n+1)}\\)을 만족하는 수열을 선언하라. (\\(a_1,a_2,\\dots,a_5\\) 까지만 선언하면 정답으로 인정)\n## 정답은 아래와 같음\n[0.5, 0.16666666666666666, 0.08333333333333333, 0.05, \n 0.03333333333333333]\n(풀이)\n\n[1/(n*(n+1)) for n in range(1,6)]\n\n[0.5, 0.16666666666666666, 0.08333333333333333, 0.05, 0.03333333333333333]\n\n\n\n\n3. – 40점\n\n(1)~(4) 까지 각 10점씩임.\n\n(1) for 문을 사용하여 아래와 같은 수열을 정의하라. (\\(a_1,\\dots,a_{100}\\) 까지 선언할 것)\n\n\\(a_1=a_2=1\\)\n\\(a_{n} = a_{n-1} + a_{n-2}\\) where \\(n\\geq 2\\)\n\n## 정답은 아래와 같음\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987,\n 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393,\n 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887,\n 9227465, 14930352, 24157817, 39088169, 63245986, 102334155,\n 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903,\n 2971215073, 4807526976, 7778742049, 12586269025, 20365011074,\n 32951280099, 53316291173, 86267571272, 139583862445, 225851433717,\n 365435296162, 591286729879, 956722026041, 1548008755920,\n 2504730781961, 4052739537881, 6557470319842, 10610209857723,\n 17167680177565, 27777890035288, 44945570212853, 72723460248141,\n 117669030460994, 190392490709135, 308061521170129, 498454011879264,\n 806515533049393, 1304969544928657, 2111485077978050,\n 3416454622906707, 5527939700884757, 8944394323791464,\n 14472334024676221, 23416728348467685, 37889062373143906,\n 61305790721611591, 99194853094755497, 160500643816367088,\n 259695496911122585, 420196140727489673, 679891637638612258,\n 1100087778366101931, 1779979416004714189, 2880067194370816120,\n 4660046610375530309, 7540113804746346429, 12200160415121876738,\n 19740274219868223167, 31940434634990099905, 51680708854858323072,\n 83621143489848422977, 135301852344706746049, 218922995834555169026,\n 354224848179261915075]\n(풀이)\n\nan = [1,1]\nfor n in range(3,101): # range(2,100) 혹은 range(98) 을 써도 결과는 같음\n    an.append(an[-1]+an[-2])\n#an\n\n(2) 3-(1)의 결과로 나온 숫자들의 자리수를 카운트하는 파이썬코드를 리스트 컴프리헨션을 이용하여 구현하라.\nhint 3-(1)를 풀지못하였더라도 아래의 리스트를 입력하면 이 문제를 풀 수 있음.\n\nlst = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987,\n 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393,\n 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887,\n 9227465, 14930352, 24157817, 39088169, 63245986, 102334155,\n 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903,\n 2971215073, 4807526976, 7778742049, 12586269025, 20365011074,\n 32951280099, 53316291173, 86267571272, 139583862445, 225851433717,\n 365435296162, 591286729879, 956722026041, 1548008755920,\n 2504730781961, 4052739537881, 6557470319842, 10610209857723,\n 17167680177565, 27777890035288, 44945570212853, 72723460248141,\n 117669030460994, 190392490709135, 308061521170129, 498454011879264,\n 806515533049393, 1304969544928657, 2111485077978050,\n 3416454622906707, 5527939700884757, 8944394323791464,\n 14472334024676221, 23416728348467685, 37889062373143906,\n 61305790721611591, 99194853094755497, 160500643816367088,\n 259695496911122585, 420196140727489673, 679891637638612258,\n 1100087778366101931, 1779979416004714189, 2880067194370816120,\n 4660046610375530309, 7540113804746346429, 12200160415121876738,\n 19740274219868223167, 31940434634990099905, 51680708854858323072,\n 83621143489848422977, 135301852344706746049, 218922995834555169026,\n 354224848179261915075]\n\nhint 아래의 코드를 이용할 것\n\nlen(str(2584)), len(str(354224848179261915075))\n\n(4, 21)\n\n\n## 답은 아래와 같다. \n[ 1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  4,\n  4,  4,  4,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  7,  7,  7,  7,\n  7,  8,  8,  8,  8,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 11, 11,\n  11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 14,\n  15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18, 18,\n  18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21 ]\n(풀이)\n\n# [len(str(i)) for i in an]\n\n(3) 3-(1)의 결과로 나온 숫자들의 유일한 숫자의 수를 카운트하는 파이썬코드를 리스트 컴프리헨션을 이용하여 구현하라. (여기에서 17711 은 유일한 숫자가 “1,7” 2개이며, 10946은 유일한 숫자가 “1,0,9,4,6” 5개 이다.\nhint 아래의 코드를 활용할 것\n\nlen(set(str(9227465)))\n\n6\n\n\n## 답은 아래와 같다. \n[ 1,  1,  1,  1,  1,  1,  2,  2,  2,  1,  2,  2,  2,  2,  3,  3,  4,\n  4,  3,  3,  5,  2,  5,  4,  4,  4,  5,  4,  5,  5,  6,  7,  6,  5,\n  6,  7,  6,  6,  7,  6,  6,  6,  4,  6,  6,  6,  7,  8,  6,  7,  8,\n  7,  7,  6,  8,  7,  7,  7,  8,  8, 10,  9, 10,  9,  6,  7,  9,  8,\n  7,  8,  9,  9,  8, 10,  8,  9,  8,  8,  7,  8,  9,  8,  8,  8,  7,\n  9,  8,  7,  7,  9,  8, 10,  9,  9,  7,  9,  8, 10,  9, 10 ]\n\n문제의 뜻이 이해안되면 질문할 것\n\n(풀이)\n\n# [len(set(str(i))) for i in an]\n\n(4) 3-(1)의 결과로 나온 숫자들 중 짝수에 해당하는 숫자가 몇개인지 카운트하는 코드를 작성하라. 코드 작성시 if가 포함된 리스트컴프리헨션을 이용하라. (numpy 이용시 부분점수 없이 0점)\n(풀이)\n\nlen([i for i in an if i %2 ==0])\n\n33\n\n\n\n\n4. – 40점\n10원짜리 동전 13개, 100원짜리 동전 17개, 500원짜리 동전 4개가 있다고 하자. 이러한 동전들로 표현할 수 있는 돈의 액수는 모두 몇 가지인가? 파이썬의 itertools 모듈을 이용하여 count하라.\n– 예시 –\n10원짜리 동전 1개, 100원짜리 동전 5개, 500원짜리 동전 1개가 있다면 표현할 수 있는 돈은 아래와 같다.\n\n\n\n경우\n10원\n100원\n500원\n총액\n\n\n\n\n경우1\n0\n0\n0\n0원\n\n\n경우2\n0\n0\n1\n500원\n\n\n경우3\n0\n1\n0\n100원\n\n\n경우4\n0\n1\n1\n600원\n\n\n경우5\n0\n2\n0\n200원\n\n\n경우6\n0\n2\n1\n700원\n\n\n경우7\n0\n3\n0\n300원\n\n\n경우8\n0\n3\n1\n800원\n\n\n경우9\n0\n4\n0\n400원\n\n\n경우10\n0\n4\n1\n900원\n\n\n경우11\n0\n5\n0\n500원\n\n\n경우12\n0\n5\n1\n1000원\n\n\n경우13\n1\n0\n0\n10원\n\n\n경우14\n1\n0\n1\n510원\n\n\n경우15\n1\n1\n0\n110원\n\n\n경우16\n1\n1\n1\n610원\n\n\n경우17\n1\n2\n0\n210원\n\n\n경우18\n1\n2\n1\n710원\n\n\n경우19\n1\n3\n0\n310원\n\n\n경우20\n1\n3\n1\n810원\n\n\n경우21\n1\n4\n0\n410원\n\n\n경우22\n1\n4\n1\n910원\n\n\n경우23\n1\n5\n0\n510원\n\n\n경우24\n1\n5\n1\n1010원\n\n\n\n여기에서 경우2와 경우11은 중복이고, 경우14와 경우23은 중복이므로 총 22개의 경우가 나온다.\n\n문제의 뜻이 이해안되면 질문할 것\n\n(풀이)\n\nlst10 = list(range(14))\nlst100 = list(range(18))\nlst500 = list(range(5)) \n\n\nlen(set([i*10+j*100+k*500 for i,j,k in itertools.product(lst10,lst100,lst500)]))\n\n384"
  },
  {
    "objectID": "posts/QuizSample.html",
    "href": "posts/QuizSample.html",
    "title": "A0: Quiz 1 (예상문제)",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt \n\n\n\n\n\n\n\nNote\n\n\n\n\n이 문항은 예시일 뿐이며, 본 문항들이 그대로 시험에 출제되지는 않음.\n일부문항은 숫자를 바꿔서 출제되거나 그대로 출제될 수 있음.\n일부문항은 모범답안이 제시되어 있음. (참고용으로..)\n예상문제를 풀기 어려운 경우 질문가능함 (힌트를 주거나 풀이를 알려줄 수 있음, 혹은 학생이 풀이한 답안을 검토하고 피드백 줄 수 있음)\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\n\n모든 문항은 부분점수 없음. (예를들어 문제1-(1)의 경우 p까지는 생성하였지만 그래프를 그리지 못한 경우 0점처리함)\n일부문항은 부분문제를 모두 맞출경우만 정답으로 인정함. 예를들면 문제2와 같은 경우.\n.ipynb 파일 형태로 제출된 답안지만 채점하며 그 외의 형식 (.hwp등)은 채점하지 않음. 즉 0점 처리함. 제출방법 모르면 물어볼것!\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n전북대 학생들을 시험당일 학생증을 지참할 것. (출석체크 및 본인확인) 학생증 외에 신분증 여권등도 가능.\n부정행위 (카카오톡 채팅을 통한 코드공유, 생성형모델 사용, 대리시험 등) 적발시 F 처리함.\n퀴즈 중 지각할 경우 지각사실을 기록함. 하지만 별다른 감점은 하지 않음.\n\n\n\n\n문제 1.\n(1) \\(0&lt;p&lt;1\\) 인 범위에서 \\(p(1-p)\\)의 그래프를 그려라. – 5점\n(풀이)\n\np = np.linspace(1/100,1,100)[:-1]\np\n\narray([0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1 , 0.11,\n       0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.2 , 0.21, 0.22,\n       0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3 , 0.31, 0.32, 0.33,\n       0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4 , 0.41, 0.42, 0.43, 0.44,\n       0.45, 0.46, 0.47, 0.48, 0.49, 0.5 , 0.51, 0.52, 0.53, 0.54, 0.55,\n       0.56, 0.57, 0.58, 0.59, 0.6 , 0.61, 0.62, 0.63, 0.64, 0.65, 0.66,\n       0.67, 0.68, 0.69, 0.7 , 0.71, 0.72, 0.73, 0.74, 0.75, 0.76, 0.77,\n       0.78, 0.79, 0.8 , 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87, 0.88,\n       0.89, 0.9 , 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99])\n\n\n\nplt.plot(p,p*(1-p))\n\n\n\n\n\n\n\n\n(2) \\(0&lt;p&lt;1\\) 의 범위에서 \\(p(1-p)\\)를 최대로 만드는 \\(p\\) 값을 파이썬을 이용하여 계산하라. – 5점\n\n# 힌트: 손으로 풀어보면 답은 0.5라는건 알겠죠? \n\n(3) 아래와 같이 50개의 숫자를 나열한 배열 \\({\\bf x}=[x_1,x_2,\\dots,x_n]\\)을 상상하자. – 10점\n\nx = np.array([0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1,\n              0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,\n              0, 0, 0, 0, 1, 0])\nx\n\narray([0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1,\n       0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,\n       0, 0, 0, 0, 1, 0])\n\n\n위와 같은 \\(x_i\\)에 대하여 아래와 같은 함수 \\(l(p)\\)를 정의하고 \\(0&lt;p&lt;1\\)에서의 \\(l(p)\\)의 그래프를 그려라.\n\\[l(p)=\\sum_{i=1}^nx_i \\log p +\\left(n-\\sum_{i=1}^{n}x_i \\right)\\log(1-p)\\]\nhint\n\n\\(n=50\\) 으로 설정해야겠죠?\n\\(\\sum_{i=1}^{50}x_i=s\\)를 미리 계산하고 \\(s\\)를 이용하여 함수 \\(l(p)=s\\log p + (50-s)\\log(1-p)\\) 를 정의하세요.\n\n\n# 시각화예시\n\n/tmp/ipykernel_74601/1320384517.py:2: RuntimeWarning: divide by zero encountered in log\n  return np.log(p)*np.sum(x) + (50-np.sum(x))*np.log(1-p)\n\n\n\n\n\n\n\n\n\n(4) 파이썬을 이용하여 아래를 근사계산하라. – 5점\n\\[\\lim_{h \\to 0}\\frac{l(0.32+h)-l(0.32)}{h}\\]\n\n# 힌트: 답은 0이에요\n\n(5) \\(0&lt;p&lt;1\\)의 범위에서 \\(l(p)\\)를 최대로 만드는 \\(p\\)의 값을 구하라. 즉 \\(\\underset{p}{\\operatorname{argmax}} l(p)\\)를 구하라. – 5점\n\n# 힌트: 답은 0.32\n\n\n\n\n\n\n\nWarning\n\n\n\n1-(5)에서 문제 오류가 있어 수정했습니다.\n\n수정전: “\\(0&lt;p&lt;1\\)” 의 범위에서 \\(l(p)\\)를 최대값을 구하라.”\n수정후: “\\(0&lt;p&lt;1\\)” 의 범위에서 \\(l(p)\\)를 최대로 만드는 \\(p\\)의 값을 구하라. 즉 \\(\\underset{p}{\\operatorname{argmax}} l(p)\\)를 구하라.”\n\n\n\n\n\n문제 2.\n\n모두 맞출 경우만 정답으로 인정\n\n(1) 아래의 list에서 마지막 원소를 뽑는 코드를 작성하라.\n\nlst = [11,22,33,44,55] \nlst \n\n[11, 22, 33, 44, 55]\n\n\n(풀이)\n\nlst[-1]\n\n55\n\n\n(2) 아래의 list에서 마지막 2개의 원소를 제외하고 뽑는 코드를 작성하라.\n\nlst = [11,22,33,44,55]\nlst\n\n[11, 22, 33, 44, 55]\n\n\n(풀이)\n\nlst[:-2]\n\n[11, 22, 33]\n\n\n(3) lambda를 이용하여 \\(f(x)=x^2+1\\)에 대응하는 함수를 선언하라.\n(4) 아래의 코드를 실행하여 x를 생성하라.\n\nnp.random.seed(43052)\nx = np.random.rand(50)\nx\n\narray([0.81768226, 0.04953212, 0.83868626, 0.61977707, 0.12254052,\n       0.11712779, 0.8795562 , 0.97941543, 0.90986893, 0.96667407,\n       0.59164493, 0.84014933, 0.89714578, 0.76530684, 0.40073371,\n       0.38061141, 0.4305124 , 0.40991094, 0.00972398, 0.59732079,\n       0.8852783 , 0.31328711, 0.6141936 , 0.36838019, 0.08044368,\n       0.47142422, 0.43324944, 0.22441988, 0.01174913, 0.91587271,\n       0.88325068, 0.32707103, 0.45758847, 0.55495369, 0.55845013,\n       0.75018778, 0.29947949, 0.85888413, 0.60465549, 0.00651133,\n       0.80605888, 0.06988897, 0.76763953, 0.72438164, 0.06247252,\n       0.97571034, 0.76681327, 0.12138996, 0.14946193, 0.08540348])\n\n\n생성된 값의 최대값을 출력하는 파이썬 코드를 작성하라.\n\n# 힌트: 답은 0.9794154308159254\n\n(5) 아래의 코드를 실행하여 x를 생성하라.\n\nnp.random.seed(43052)\nx = np.random.rand(50)\nx\n\narray([0.81768226, 0.04953212, 0.83868626, 0.61977707, 0.12254052,\n       0.11712779, 0.8795562 , 0.97941543, 0.90986893, 0.96667407,\n       0.59164493, 0.84014933, 0.89714578, 0.76530684, 0.40073371,\n       0.38061141, 0.4305124 , 0.40991094, 0.00972398, 0.59732079,\n       0.8852783 , 0.31328711, 0.6141936 , 0.36838019, 0.08044368,\n       0.47142422, 0.43324944, 0.22441988, 0.01174913, 0.91587271,\n       0.88325068, 0.32707103, 0.45758847, 0.55495369, 0.55845013,\n       0.75018778, 0.29947949, 0.85888413, 0.60465549, 0.00651133,\n       0.80605888, 0.06988897, 0.76763953, 0.72438164, 0.06247252,\n       0.97571034, 0.76681327, 0.12138996, 0.14946193, 0.08540348])\n\n\n생성된 값중 0.6와 가장 가까운 값을 출력하는 파이썬 코드를 작성하라.\n\n# 힌트: 답은 0.5973207921703583\n\n\n\n문제 3.\n(1) \\(\\frac{\\pi}{2}&lt;x&lt;\\frac{3}{2}\\pi\\) 에서 \\(f(x)=\\sin(\\frac{3}{2}x)\\) 와 \\(g(x)=\\cos(2x)\\sin(5x)\\) 의 교점의 수를 구하여라.\n(풀이)\n\nx = np.linspace(np.pi/2,3/2*np.pi,100)[:-1]\nx\n\narray([1.57079633, 1.60252959, 1.63426285, 1.6659961 , 1.69772936,\n       1.72946262, 1.76119588, 1.79292914, 1.8246624 , 1.85639566,\n       1.88812892, 1.91986218, 1.95159544, 1.9833287 , 2.01506195,\n       2.04679521, 2.07852847, 2.11026173, 2.14199499, 2.17372825,\n       2.20546151, 2.23719477, 2.26892803, 2.30066129, 2.33239455,\n       2.3641278 , 2.39586106, 2.42759432, 2.45932758, 2.49106084,\n       2.5227941 , 2.55452736, 2.58626062, 2.61799388, 2.64972714,\n       2.6814604 , 2.71319366, 2.74492691, 2.77666017, 2.80839343,\n       2.84012669, 2.87185995, 2.90359321, 2.93532647, 2.96705973,\n       2.99879299, 3.03052625, 3.06225951, 3.09399276, 3.12572602,\n       3.15745928, 3.18919254, 3.2209258 , 3.25265906, 3.28439232,\n       3.31612558, 3.34785884, 3.3795921 , 3.41132536, 3.44305862,\n       3.47479187, 3.50652513, 3.53825839, 3.56999165, 3.60172491,\n       3.63345817, 3.66519143, 3.69692469, 3.72865795, 3.76039121,\n       3.79212447, 3.82385772, 3.85559098, 3.88732424, 3.9190575 ,\n       3.95079076, 3.98252402, 4.01425728, 4.04599054, 4.0777238 ,\n       4.10945706, 4.14119032, 4.17292358, 4.20465683, 4.23639009,\n       4.26812335, 4.29985661, 4.33158987, 4.36332313, 4.39505639,\n       4.42678965, 4.45852291, 4.49025617, 4.52198943, 4.55372268,\n       4.58545594, 4.6171892 , 4.64892246, 4.68065572])\n\n\n\nplt.plot(x,np.sin(1.5*x))\nplt.plot(x,np.cos(2*x)*np.sin(5*x))\n\n\n\n\n\n\n\n\n\n# 답 3개\n\n(2) \\(a_n=\\frac{1}{n(n+1)}\\) 일때 \\(S_1,\\dots,S_{20}\\)을 구하여라."
  },
  {
    "objectID": "posts/01wk-2.html#a.-함수를-선언하는-두-가지-방법",
    "href": "posts/01wk-2.html#a.-함수를-선언하는-두-가지-방법",
    "title": "01wk-2: 파이썬은 좋은 계산기다 (1)",
    "section": "A. 함수를 선언하는 두 가지 방법",
    "text": "A. 함수를 선언하는 두 가지 방법\n- 방법1: def를 이용하는 방법\n\ndef f(x):\n    return x+1\n\n\nf(3)\n\n4\n\n\n- 방법2: lambda를 사용하는 방법\n\nf = lambda x: x+1\n\n\nf(3)\n\n4"
  },
  {
    "objectID": "posts/01wk-2.html#b.-list와-np.array의-차이점",
    "href": "posts/01wk-2.html#b.-list와-np.array의-차이점",
    "title": "01wk-2: 파이썬은 좋은 계산기다 (1)",
    "section": "B. list와 np.array의 차이점",
    "text": "B. list와 np.array의 차이점\n- 리스트는 수학친화적이지 않다.\n\nlst1 = [1,2,3]\nlst2 = [-1, -2, -3]\n\n\nlst1+lst2\n\n[1, 2, 3, -1, -2, -3]\n\n\n- 넘파이는 수학친화적이다.\n\narr1 = np.array([1,2,3])\narr2 = np.array([-1, -2, -3])\n\n\narr1+arr2\n\narray([0, 0, 0])"
  },
  {
    "objectID": "posts/01wk-2.html#c.-인덱스로-벡터의-원소를-뽑는-방법",
    "href": "posts/01wk-2.html#c.-인덱스로-벡터의-원소를-뽑는-방법",
    "title": "01wk-2: 파이썬은 좋은 계산기다 (1)",
    "section": "C. 인덱스로 벡터의 원소를 뽑는 방법",
    "text": "C. 인덱스로 벡터의 원소를 뽑는 방법\n\nx = [11,22,33,-22,-33,-44]\n\n- 첫번째 원소를 뽑고 싶다면?\n\nx[0]\n\n11\n\n\n- 두번째 원소를 뽑고 싶다면?\n\nx[1]\n\n22\n\n\n- 마지막 원소를 뽑고 싶다면?\n\nx[5]\n\n-44\n\n\n\nx[-1]\n\n-44\n\n\n- 마지막에서 두번째 원소를 뽑고 싶다면?\n\nx[4]\n\n-33\n\n\n\nx[-2]\n\n-33\n\n\n- index = 0,1,2 에 해당하는 원소만 추출\n\nx[0:3] # 마지막 인덱스 3은 포함되지 않음 \n\n[11, 22, 33]\n\n\n- index = 2,3,4 에 해당하는 원소만 추출\n\nx[2:5] # 2,3,4에 해당하는 인덱스만 추출\n\n[33, -22, -33]\n\n\n- x[0:3]와 같이 처음 시작점이 0인 경우 생략가능\n\nx[:3] \n\n[11, 22, 33]\n\n\n- x[k:]와 같은 코드는 index=k에서 끝까지 뽑는다는 의미이다.\n\nx[3:6] #3,4,5\n\n[-22, -33, -44]\n\n\n\nx[3:]\n\n[-22, -33, -44]"
  },
  {
    "objectID": "posts/01wk-2.html#d.-np.cumsum-np.cumprod",
    "href": "posts/01wk-2.html#d.-np.cumsum-np.cumprod",
    "title": "01wk-2: 파이썬은 좋은 계산기다 (1)",
    "section": "D. np.cumsum(), np.cumprod()",
    "text": "D. np.cumsum(), np.cumprod()\n- 누적합\n\narr = np.array([1,-1,1,-1,1,-1])\narr\n\narray([ 1, -1,  1, -1,  1, -1])\n\n\n\nnp.cumsum(arr)\n\narray([1, 0, 1, 0, 1, 0])\n\n\n- 누적곱\n\narr = np.array([1,2,3,4])\narr\n\narray([1, 2, 3, 4])\n\n\n\nnp.cumprod(arr)\n\narray([ 1,  2,  6, 24])"
  },
  {
    "objectID": "posts/01wk-2.html#e.-plt.plot",
    "href": "posts/01wk-2.html#e.-plt.plot",
    "title": "01wk-2: 파이썬은 좋은 계산기다 (1)",
    "section": "E. plt.plot()",
    "text": "E. plt.plot()\n- 예시1: \\(x\\)없이 그리기 (라인)\n\ny=[2,3,5,2]\nplt.plot(y)\n\n\n\n\n\n\n\n\n- 예시2: \\(x\\)없이 그리기 (점)\n\ny=[2,3,5,2]\nplt.plot(y,'o')\n\n\n\n\n\n\n\n\n- 예시3: \\((x,y)\\)를 전달하여 그리기(점)\n\nx=[20,21,22,23]\ny=[2,3,5,2]\nplt.plot(x,y,'o')\n\n\n\n\n\n\n\n\n- 예시4: 겹쳐서 그리기\n\nx=[20,21,22,23]\ny1=[2,3,5,-2]\ny2=[2.5 ,3.5 ,5.5 , -2.5]\nplt.plot(x,y1,'--o')\nplt.plot(x,y2,'--o')\n\n\n\n\n\n\n\n\n- 예시5: 겹쳐서 그리기 + 라벨\n\nx=[20,21,22,23]\ny1=[2,3,5,-2]\ny2=[2.5 ,3.5 ,5.5 , -2.5]\nplt.plot(x,y1,'--o',label=\"y1\")\nplt.plot(x,y2,'--o',label=\"y2\")\nplt.legend()\n\n\n\n\n\n\n\n\n- 예시5: 겹쳐서 그리기 + latex 라벨\n\nx=[20,21,22,23]\ny1=[2,3,5,-2]\ny2=[2.5 ,3.5 ,5.5 , -2.5]\nplt.plot(x,y1,'--o',label=r\"$y_1$\")\nplt.plot(x,y2,'--o',label=r\"$y_2$\")\nplt.legend()\n\n\n\n\n\n\n\n\n\nlatex수식은 이 수업에서 필수사항은 아님\nlatex수식을 사용할 수 없어도 시험점수를 획득할때 아무런 불이익이 없음."
  },
  {
    "objectID": "posts/01wk-2.html#f.-np.argmax-np.argmin",
    "href": "posts/01wk-2.html#f.-np.argmax-np.argmin",
    "title": "01wk-2: 파이썬은 좋은 계산기다 (1)",
    "section": "F. np.argmax, np.argmin",
    "text": "F. np.argmax, np.argmin\n- 예시1\n\narr = np.array([1,2,3,2,1,0])\narr\n\narray([1, 2, 3, 2, 1, 0])\n\n\n\nnp.argmax(arr),np.argmin(arr)\n\n(2, 5)\n\n\n# 예제 – 두 함수의 교점\n\\(-1 \\leq x \\leq 3\\) 에서\n\n\\(f(x)=(x-1)^2\\) 와\n\\(g(x)=-2x+5\\)\n\n의 교점의 좌표를 구하여라.\n(풀이)\n\nx = np.linspace(-1,3,101)\nf = (x-1)**2\ng = -2*x+5 \nplt.plot(x,f,label=r\"$f(x)=(x-1)^2$\")\nplt.plot(x,g,label=r\"$g(x)=-2x+5$\")\nplt.legend()\n\n\n\n\n\n\n\n\n\nx[np.argmin(abs(f-g))]\n\n2.0\n\n\n\n2,(2-1)**2\n\n(2, 1)\n\n\n\n이것이 교점의 좌표"
  },
  {
    "objectID": "posts/06wk-2.html#a.-선언",
    "href": "posts/06wk-2.html#a.-선언",
    "title": "06wk-2: numpy (1)",
    "section": "A. 선언",
    "text": "A. 선언\n\na=np.array([1,2,3]) # list를 만들고 ndarray화 시킴 \nl=[1,2,3]"
  },
  {
    "objectID": "posts/06wk-2.html#b.-기본연산-브로드캐스팅",
    "href": "posts/06wk-2.html#b.-기본연산-브로드캐스팅",
    "title": "06wk-2: numpy (1)",
    "section": "B. 기본연산 브로드캐스팅",
    "text": "B. 기본연산 브로드캐스팅\n\na+1 ## [1,2,3] + 1 = [2,3,4]\n\narray([2, 3, 4])\n\n\n\nl+1\n\nTypeError: can only concatenate list (not \"int\") to list\n\n\n\na*2\n\narray([2, 4, 6])\n\n\n\nl*2\n\n[1, 2, 3, 1, 2, 3]\n\n\n\na/2\n\narray([0.5, 1. , 1.5])\n\n\n\nl/2\n\nTypeError: unsupported operand type(s) for /: 'list' and 'int'\n\n\n\na**2\n\narray([1, 4, 9])\n\n\n\nl**2\n\nTypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'\n\n\n\na%2 # %2 = 2로 나눈 나머지를 리턴 a=[1,2,3] \n\narray([1, 0, 1])\n\n\n\nl%2\n\nTypeError: unsupported operand type(s) for %: 'list' and 'int'"
  },
  {
    "objectID": "posts/06wk-2.html#c.-기타수학연산지원",
    "href": "posts/06wk-2.html#c.-기타수학연산지원",
    "title": "06wk-2: numpy (1)",
    "section": "C. 기타수학연산지원",
    "text": "C. 기타수학연산지원\n\nnp.sqrt(a), np.sqrt(l)\n\n(array([1.        , 1.41421356, 1.73205081]),\n array([1.        , 1.41421356, 1.73205081]))\n\n\n\nnp.log(a), np.log(l)\n\n(array([0.        , 0.69314718, 1.09861229]),\n array([0.        , 0.69314718, 1.09861229]))\n\n\n\nnp.exp(a), np.exp(l)\n\n(array([ 2.71828183,  7.3890561 , 20.08553692]),\n array([ 2.71828183,  7.3890561 , 20.08553692]))\n\n\n\nnp.sin(a), np.sin(l)\n\n(array([0.84147098, 0.90929743, 0.14112001]),\n array([0.84147098, 0.90929743, 0.14112001]))"
  },
  {
    "objectID": "posts/06wk-2.html#d.-인덱싱-1차원",
    "href": "posts/06wk-2.html#d.-인덱싱-1차원",
    "title": "06wk-2: numpy (1)",
    "section": "D. 인덱싱 1차원",
    "text": "D. 인덱싱 1차원\n- 선언\n\nl=[11,22,33,44,55,66] \na=np.array(l) \n\n- 인덱스로 접근\n\nl[0],l[1],l[2],l[3],l[-2],l[-1]\n\n(11, 22, 33, 44, 55, 66)\n\n\n\na[0],a[1],a[2],a[3],a[-2],a[-1]\n\n(11, 22, 33, 44, 55, 66)\n\n\n- : 이용 (슬라이싱)\n\nl[2:4] # index 2에서 시작, index 4는 포함하지 않음 \n\n[33, 44]\n\n\n\na[2:4] \n\narray([33, 44])\n\n\n- 정수배열에 의한 인덱싱\n\na\n\narray([11, 22, 33, 44, 55, 66])\n\n\n\na[[0,2,4]] # index=0, index=2, index=4 에 해당하는 원소를 뽑고 싶다 \n\narray([11, 33, 55])\n\n\n\nl[[0,2,4]] # 리스트는 불가능 \n\nTypeError: list indices must be integers or slices, not list\n\n\n- 부울값에 의한 인덱싱\n\na\n\narray([11, 22, 33, 44, 55, 66])\n\n\n\na[[True,False,True,False,True,False]] \n\narray([11, 33, 55])\n\n\n응용하면?\n\na &lt; 33 \n\narray([ True,  True, False, False, False, False])\n\n\n\na[a&lt;33]\n\narray([11, 22])\n\n\n리스트는 불가능\n\nl&lt;33 # 여기에서부터 불가능 \n\nTypeError: '&lt;' not supported between instances of 'list' and 'int'\n\n\n\nl[[True,False,True,False,True,False]] # 이것도 불가능 \n\nTypeError: list indices must be integers or slices, not list"
  },
  {
    "objectID": "posts/06wk-2.html#e.-인덱싱-2차원",
    "href": "posts/06wk-2.html#e.-인덱싱-2차원",
    "title": "06wk-2: numpy (1)",
    "section": "E. 인덱싱 2차원",
    "text": "E. 인덱싱 2차원\n- 중첩리스트와 2차원 np.array 선언\n\nA = [[1,2,3,4],[-1,-2,-3,-4],[5,6,7,8],[-5,-6,-7,-8]]\nA2 = np.array(A)\n\n\nA2\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n\nA\n\n[[1, 2, 3, 4], [-1, -2, -3, -4], [5, 6, 7, 8], [-5, -6, -7, -8]]\n\n\n- A의 원소 인덱싱\n\nA[0][0] # (1,1)의 원소 \n\n1\n\n\n\nA[1][2] # (2,3)의 원소 \n\n-3\n\n\n\nA[-1][0] # (4,1)의 원소 \n\n-5\n\n\n- A2의 원소 인덱싱\n\nA2[0][0] # (1,1)의 원소 \n\n1\n\n\n\nA2[1][2] # (2,3)의 원소 \n\n-3\n\n\n\nA2[-1][0] # (4,1)의 원소 \n\n-5\n\n\n- A2에서만 되는 기술 (넘파이에서 제시하는 신기술, R에서는 기본적으로 쓰던것, 이중list는 불가능)\n\nA2[0,0] # (1,1)의 원소 \n\n1\n\n\n\nA2[1,2] # (2,3)의 원소 \n\n-3\n\n\n\nA2[-1,0] # (4,1)의 원소 \n\n-5\n\n\n- 정수배열에 의한 인덱싱 & 슬라이싱!\n\nA2\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n\nA2[0,0:2] # 1행1열, 1행2열 \n\narray([1, 2])\n\n\n\nA2[0,:] # 1행 \n\narray([1, 2, 3, 4])\n\n\n\nA2[0] # 1행\n\narray([1, 2, 3, 4])\n\n\n\nA2[[0,2],:] # 1행, 3행 \n\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n\n\n\nA2[[0,2]] # 1행, 3행 \n\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n\n\n\nA2[:,0] # 1열 \n\narray([ 1, -1,  5, -5])\n\n\n\nA2[:,[0]] # 1열 \n\narray([[ 1],\n       [-1],\n       [ 5],\n       [-5]])\n\n\n\nA2[:,[0,2]] # 1열, 3열\n\narray([[ 1,  3],\n       [-1, -3],\n       [ 5,  7],\n       [-5, -7]])\n\n\n\nA2[0:2,[0,2]] # 1행~2행 //  1열,3열 \n\narray([[ 1,  3],\n       [-1, -3]])"
  },
  {
    "objectID": "posts/06wk-2.html#f.-1차원-배열의-선언",
    "href": "posts/06wk-2.html#f.-1차원-배열의-선언",
    "title": "06wk-2: numpy (1)",
    "section": "F. 1차원 배열의 선언",
    "text": "F. 1차원 배열의 선언\n- 리스트나 튜플을 선언하고 형변환\n\nnp.array((1,2,3)) # 튜플-&gt;넘파이어레이 \n\narray([1, 2, 3])\n\n\n\nnp.array([1,2,3]) # 리스트 -&gt;넘파이어레이 \n\narray([1, 2, 3])\n\n\n- range()를 이용해서 선언하고 형변환\n\nnp.array(range(10)) # range(10) -&gt; 넘파이어레이 \n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\n- np.zeros, np.ones\n\nnp.zeros(3) \n\narray([0., 0., 0.])\n\n\n\nnp.ones(4)\n\narray([1., 1., 1., 1.])\n\n\n- np.linspace\n\nnp.linspace(0,1,12) # 0에서 시작하고 1에서 끝남 (양끝점 모두 포함)\n\narray([0.        , 0.09090909, 0.18181818, 0.27272727, 0.36363636,\n       0.45454545, 0.54545455, 0.63636364, 0.72727273, 0.81818182,\n       0.90909091, 1.        ])\n\n\n\nlen(np.linspace(0,1,12)) # 길이는 12\n\n12\n\n\n- np.arange\n\nnp.arange(5) # np.array(range(5))\n\narray([0, 1, 2, 3, 4])\n\n\n\nnp.arange(1,6) # np.array(range(1,6))\n\narray([1, 2, 3, 4, 5])"
  },
  {
    "objectID": "posts/06wk-2.html#g.-reshape",
    "href": "posts/06wk-2.html#g.-reshape",
    "title": "06wk-2: numpy (1)",
    "section": "G. reshape",
    "text": "G. reshape\n- reshape: ndarray의 특수한 기능\n\na=np.array([11,22,33,44,55,66])\na ## 길이가 6인 벡터 \n\narray([11, 22, 33, 44, 55, 66])\n\n\n\na.reshape(2,3) ## (2,3) matrix 라고 생각해도 무방 \n\narray([[11, 22, 33],\n       [44, 55, 66]])\n\n\nnote: reshape은 a자체를 변화시키는것은 아님\n\na # a는 그대로 있음 \n\narray([11, 22, 33, 44, 55, 66])\n\n\n\nb= a.reshape(2,3) # a를 reshape한 결과를 b에 저장 \nb\n\narray([[11, 22, 33],\n       [44, 55, 66]])\n\n\n\na # a는 여전히 그대로 있음\n\narray([11, 22, 33, 44, 55, 66])\n\n\n- 다시 b를 a처럼 바꾸고 싶다\n\nb\n\narray([[11, 22, 33],\n       [44, 55, 66]])\n\n\n\nb.reshape(6) # b는 (2,3) matrix , 그런데 이것을 길이가 6인 벡터로 만들고 싶다. \n\narray([11, 22, 33, 44, 55, 66])\n\n\n- reshape with -1\n\na=np.arange(24) # np.array(range(24))\na\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])\n\n\n\na.reshape(2,-1)\n\narray([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]])\n\n\n\na.reshape(3,-1)\n\narray([[ 0,  1,  2,  3,  4,  5,  6,  7],\n       [ 8,  9, 10, 11, 12, 13, 14, 15],\n       [16, 17, 18, 19, 20, 21, 22, 23]])\n\n\n\na.reshape(4,-1)\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17],\n       [18, 19, 20, 21, 22, 23]])\n\n\n\na.reshape(5,-1)\n\nValueError: cannot reshape array of size 24 into shape (5,newaxis)\n\n\n\na.reshape(6,-1)\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15],\n       [16, 17, 18, 19],\n       [20, 21, 22, 23]])\n\n\n\na.reshape(7,-1)\n\nValueError: cannot reshape array of size 24 into shape (7,newaxis)\n\n\n\na.reshape(8,-1)\n\narray([[ 0,  1,  2],\n       [ 3,  4,  5],\n       [ 6,  7,  8],\n       [ 9, 10, 11],\n       [12, 13, 14],\n       [15, 16, 17],\n       [18, 19, 20],\n       [21, 22, 23]])\n\n\n\na.reshape(12,-1)\n\narray([[ 0,  1],\n       [ 2,  3],\n       [ 4,  5],\n       [ 6,  7],\n       [ 8,  9],\n       [10, 11],\n       [12, 13],\n       [14, 15],\n       [16, 17],\n       [18, 19],\n       [20, 21],\n       [22, 23]])\n\n\n\nb= a.reshape(12,-1)\nb\n\narray([[ 0,  1],\n       [ 2,  3],\n       [ 4,  5],\n       [ 6,  7],\n       [ 8,  9],\n       [10, 11],\n       [12, 13],\n       [14, 15],\n       [16, 17],\n       [18, 19],\n       [20, 21],\n       [22, 23]])\n\n\n\nb.reshape(-1) # b를 다시 길이가 24인 벡터로!\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])"
  },
  {
    "objectID": "posts/06wk-2.html#h.-2차원-배열의-선언",
    "href": "posts/06wk-2.html#h.-2차원-배열의-선언",
    "title": "06wk-2: numpy (1)",
    "section": "H. 2차원 배열의 선언",
    "text": "H. 2차원 배열의 선언\n\nnp.zeros((3,3))\n\narray([[0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.]])\n\n\n\nnp.ones((3,3))\n\narray([[1., 1., 1.],\n       [1., 1., 1.],\n       [1., 1., 1.]])\n\n\n\nnp.eye(3)\n\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n\n\n\nnp.diag([1,2,3,-1])\n\narray([[ 1,  0,  0,  0],\n       [ 0,  2,  0,  0],\n       [ 0,  0,  3,  0],\n       [ 0,  0,  0, -1]])"
  },
  {
    "objectID": "posts/06wk-2.html#i.-랜덤으로-배열-생성",
    "href": "posts/06wk-2.html#i.-랜덤으로-배열-생성",
    "title": "06wk-2: numpy (1)",
    "section": "I. 랜덤으로 배열 생성",
    "text": "I. 랜덤으로 배열 생성\n\nnp.random.randn(10) # 표쥰정규분포에서 10개를 뽑음 \n\narray([-0.33138513,  1.42650878,  1.22837316,  0.08113144, -1.0972836 ,\n        1.66641222,  0.18244459,  0.45246865, -1.22156378,  0.18756565])\n\n\n\nnp.random.rand(10) # 0~1사이에서 10개를 뽑음\n\narray([0.67642264, 0.06040223, 0.48991224, 0.32202819, 0.22195857,\n       0.31407011, 0.82567895, 0.14494499, 0.74293485, 0.37775136])\n\n\n\nnp.random.randn(4).reshape(2,2) # 표준정규분포에서 4개를 뽑고 (2,2) ndarray로 형태변환 \n\narray([[-1.1514733 , -0.82454175],\n       [-0.07976586,  0.0863252 ]])\n\n\n\nnp.random.rand(4).reshape(2,2) # 0~1 4개를 뽑고 (2,2) ndarray로 형태변환 \n\narray([[0.06084905, 0.54804885],\n       [0.64428734, 0.76590051]])"
  },
  {
    "objectID": "posts/06wk-2.html#j.-행렬관련기능",
    "href": "posts/06wk-2.html#j.-행렬관련기능",
    "title": "06wk-2: numpy (1)",
    "section": "J. 행렬관련기능",
    "text": "J. 행렬관련기능\n\nA=np.arange(4).reshape(2,2) \nA\n\narray([[0, 1],\n       [2, 3]])\n\n\n\nA.T # .T는 전치행렬을 구해줌 \n\narray([[0, 2],\n       [1, 3]])\n\n\n\nnp.linalg.inv(A) # np.linalg.inv는 역행렬을 구해주는 함수 \n\narray([[-1.5,  0.5],\n       [ 1. ,  0. ]])\n\n\n\nA @ np.linalg.inv(A) # @는 행렬곱을 수행 \n\narray([[1., 0.],\n       [0., 1.]])"
  },
  {
    "objectID": "posts/06wk-2.html#k.-2차원-배열과-연립-1차-방정식",
    "href": "posts/06wk-2.html#k.-2차원-배열과-연립-1차-방정식",
    "title": "06wk-2: numpy (1)",
    "section": "K. 2차원 배열과 연립 1차 방정식",
    "text": "K. 2차원 배열과 연립 1차 방정식\n- 아래의 연립방정식 고려\n\\(\\begin{cases} y+z+w = 3 \\\\ x+z+w = 3 \\\\ x+y+w = 3 \\\\ x+y+z = 3 \\end{cases}\\)\n- 행렬표현?\n\\(\\begin{bmatrix} 0 & 1 & 1 & 1 \\\\ 1 & 0 & 1 & 1 \\\\ 1 & 1 & 0 & 1 \\\\ 1 & 1 & 1 & 0 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ z \\\\ w \\end{bmatrix} = \\begin{bmatrix} 3 \\\\ 3 \\\\ 3 \\\\ 3 \\end{bmatrix}\\)\n- 풀이\n\nA = np.array([[0,1,1,1],[1,0,1,1],[1,1,0,1],[1,1,1,0]])\nA\n\narray([[0, 1, 1, 1],\n       [1, 0, 1, 1],\n       [1, 1, 0, 1],\n       [1, 1, 1, 0]])\n\n\n\nb= np.array([3,3,3,3]).reshape(4,1)\nb\n\narray([[3],\n       [3],\n       [3],\n       [3]])\n\n\n\nnp.linalg.inv(A) @ b \n\narray([[1.],\n       [1.],\n       [1.],\n       [1.]])\n\n\n- 다른풀이\nb를 아래와 같이 만들어도 된다.\n\nb=np.array([3,3,3,3])\nb\n\narray([3, 3, 3, 3])\n\n\n\nb.shape # b.shape은 길이가 1인 튜플로 나온다. \n\n(4,)\n\n\n\nnp.linalg.inv(A) @ b \n\narray([1., 1., 1., 1.])\n\n\n@의 유연성\n- 엄밀하게는 아래의 행렬곱이 가능하다. - (2,2) @ (2,1) =&gt; (2,1) - (1,2) @ (2,2) =&gt; (1,2)\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(2,1) \nA@b\n\narray([[ 5],\n       [11]])\n\n\n\nA.shape, b.shape, (A@b).shape\n\n((2, 2), (2, 1), (2, 1))\n\n\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(1,2) \nb@A \n\narray([[ 7, 10]])\n\n\n\nA.shape, b.shape, (b@A).shape\n\n((2, 2), (1, 2), (1, 2))\n\n\n- 당연히 아래는 성립안한다.\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(2,1) \nb@A\n\nValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 2 is different from 1)\n\n\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(1,2) \nA@b\n\nValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 1 is different from 2)\n\n\n- 아래는 어떨까? 계산가능할까? \\(\\to\\) 모두 계산가능! - (2,) @ (2,2) = (2,) - (2,2) @ (2,) = (2,)\n\nA = np.array([1,2,3,4]).reshape(2,2)\nb = np.array([1,2]) \nA@b\n\narray([ 5, 11])\n\n\n\nA.shape, b.shape, (A@b).shape \n\n((2, 2), (2,), (2,))\n\n\n\nb를 마치 (2,1)처럼 해석하여 행렬곱하고 결과는 다시 (2,) 로 만든것 같다.\n\n\nb@A\n\narray([ 7, 10])\n\n\n\nA.shape, b.shape, (b@A).shape \n\n((2, 2), (2,), (2,))\n\n\n\n이때는 \\(b\\)를 마치 (1,2)처럼 해석하여 행렬곱하고 결과는 다시 (2,)로 만든것 같다.\n\n- 아래는 어떠할까?\n\nb1 = np.array([1,2,3,4]) \nb2 = np.array([1,2,3,4]) \nb1@b2 \n\n30\n\n\n\nb1.shape, b2.shape, (b1@b2).shape \n\n((4,), (4,), ())\n\n\n\n(1,4) @ (4,1) = (1,1) 로 생각\n\n- 즉 위는 아래와 같이 해석하고 행렬곱한것과 결과가 같다.\n\nb1 = np.array([1,2,3,4]).reshape(1,4) \nb2 = np.array([1,2,3,4]).reshape(4,1) \nb1@b2 \n\narray([[30]])\n\n\n\nb1.shape, b2.shape, (b1@b2).shape \n\n((1, 4), (4, 1), (1, 1))\n\n\n- 때로는 (4,1) @ (1,4)와 같은 계산결과를 얻고 싶을 수 있는데 이때는 차원을 명시해야함\n\nb1 = np.array([1,2,3,4]).reshape(4,1) \nb2 = np.array([1,2,3,4]).reshape(1,4) \nb1@b2 \n\narray([[ 1,  2,  3,  4],\n       [ 2,  4,  6,  8],\n       [ 3,  6,  9, 12],\n       [ 4,  8, 12, 16]])"
  },
  {
    "objectID": "posts/06wk-2.html#l.-차원",
    "href": "posts/06wk-2.html#l.-차원",
    "title": "06wk-2: numpy (1)",
    "section": "L. 차원",
    "text": "L. 차원\n- 넘파이배열의 차원은 .shape 으로 확인가능\n- 아래는 모두 미묘하게 다르다.\n\na=np.array(3.14) # 스칼라, 0d array \na, a.shape\n\n(array(3.14), ())\n\n\n\na=np.array([3.14]) # 벡터, 1d array \na, a.shape\n\n(array([3.14]), (1,))\n\n\n\na=np.array([[3.14]]) # 매트릭스, 2d array \na, a.shape\n\n(array([[3.14]]), (1, 1))\n\n\n\na=np.array([[[3.14]]]) # 텐서, 3d array \na, a.shape\n\n(array([[[3.14]]]), (1, 1, 1))"
  },
  {
    "objectID": "posts/06wk-2.html#a.-np.concatenate",
    "href": "posts/06wk-2.html#a.-np.concatenate",
    "title": "06wk-2: numpy (1)",
    "section": "A. np.concatenate",
    "text": "A. np.concatenate\n- 기본예제\n\na = np.array([1,2])\nb = -a\n\n\nnp.concatenate([a,b])\n\narray([ 1,  2, -1, -2])\n\n\n\n딱히 인상적인건 아님.\n왜냐하면 리스트에서 있는 기능임\n\n- 2D인 경우\n\na = np.array([1,2,3,4]).reshape(2,2)\nb = -a\n\n\nnp.concatenate([a,b])\n\narray([[ 1,  2],\n       [ 3,  4],\n       [-1, -2],\n       [-3, -4]])\n\n\na,b를 위아래가 아니라 좌우로 붙이고 싶다면?\n\nnp.concatenate([a,b],axis=1)\n\narray([[ 1,  2, -1, -2],\n       [ 3,  4, -3, -4]])\n\n\n- 도데체 axis=0, 혹은 axis=1의 의미가 무엇인가?\n\nnp.concatenate([a,b],axis=0) # 이건 아까 np.concatenate([a,b])랑 같네?\n\narray([[ 1,  2],\n       [ 3,  4],\n       [-1, -2],\n       [-3, -4]])\n\n\n\nnp.concatenate([a,b],axis=1) # 이건 아까 np.concatenate([a,b])랑 같네?\n\narray([[ 1,  2, -1, -2],\n       [ 3,  4, -3, -4]])\n\n\n\n관찰에 의한 정리: a,b가 2차원일때 axis=0 이라고 쓰면 위아래로, axis=1이라고 하면 좌우로 합쳐진다.\naxis=0은 생략할 수 있다.\n\n- 2D일 경우에 활용\n\na = np.array([1,2,3,4]).reshape(2,2)\nb = np.array([10,20]).reshape(2,1)\nc = -b\n\n\na,b,c\n\n(array([[1, 2],\n        [3, 4]]),\n array([[10],\n        [20]]),\n array([[-10],\n        [-20]]))\n\n\n\nnp.concatenate([a,b.T],axis=0) \n\narray([[ 1,  2],\n       [ 3,  4],\n       [10, 20]])\n\n\n\nnp.concatenate([a,b.T,c.T],axis=0) \n\narray([[  1,   2],\n       [  3,   4],\n       [ 10,  20],\n       [-10, -20]])\n\n\n\nnp.concatenate([a,b],axis=1) \n\narray([[ 1,  2, 10],\n       [ 3,  4, 20]])\n\n\n\nnp.concatenate([a,b,c],axis=1) \n\narray([[  1,   2,  10, -10],\n       [  3,   4,  20, -20]])\n\n\n\nnp.concatenate([a.reshape(4,1), np.concatenate([b,c])],axis=1)\n\narray([[  1,  10],\n       [  2,  20],\n       [  3, -10],\n       [  4, -20]])\n\n\n- axis의 의미가 뭔지 궁금함. 좀 더 예제를 살펴보자.\n\na = np.arange(2*3*4).reshape(2,3,4)\nb = -a\n\n\na.shape, b.shape\n\n((2, 3, 4), (2, 3, 4))\n\n\n\nnp.concatenate([a,b],axis=0)\n\narray([[[  0,   1,   2,   3],\n        [  4,   5,   6,   7],\n        [  8,   9,  10,  11]],\n\n       [[ 12,  13,  14,  15],\n        [ 16,  17,  18,  19],\n        [ 20,  21,  22,  23]],\n\n       [[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]]])\n\n\n\nnp.concatenate([a,b],axis=1)\n\narray([[[  0,   1,   2,   3],\n        [  4,   5,   6,   7],\n        [  8,   9,  10,  11],\n        [  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[ 12,  13,  14,  15],\n        [ 16,  17,  18,  19],\n        [ 20,  21,  22,  23],\n        [-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]]])\n\n\n\nnp.concatenate([a,b],axis=2)\n\narray([[[  0,   1,   2,   3,   0,  -1,  -2,  -3],\n        [  4,   5,   6,   7,  -4,  -5,  -6,  -7],\n        [  8,   9,  10,  11,  -8,  -9, -10, -11]],\n\n       [[ 12,  13,  14,  15, -12, -13, -14, -15],\n        [ 16,  17,  18,  19, -16, -17, -18, -19],\n        [ 20,  21,  22,  23, -20, -21, -22, -23]]])\n\n\n\n이번에는 axis=2 까지 계산이 가능함\n\n\nnp.concatenate([a,b],axis=3)\n\nAxisError: axis 3 is out of bounds for array of dimension 3\n\n\n\naxis=3까지는 불가능\n\n- 뭔가 나름의 방식으로 합쳐지는것 같은데, 원리를 잘 모르겠음\n(분석) np.concatenate([a,b],axis=??)에서 ?? 의 숫자를 바꿔가면서 결과의 차원만 관찰해보자.\n\nprint(f'입력: {a.shape} concat {b.shape}')\nprint(f'출력: {np.concatenate([a,b],axis=0).shape} -- axis=0')\n\n입력: (2, 3, 4) concat (2, 3, 4)\n출력: (4, 3, 4) -- axis=0\n\n\n\nprint(f'입력: {a.shape} concat {b.shape}')\nprint(f'출력: {np.concatenate([a,b],axis=1).shape} -- axis=1')\n\n입력: (2, 3, 4) concat (2, 3, 4)\n출력: (2, 6, 4) -- axis=1\n\n\n\nprint(f'입력: {a.shape} concat {b.shape}')\nprint(f'출력: {np.concatenate([a,b],axis=2).shape} -- axis=2')\n\n입력: (2, 3, 4) concat (2, 3, 4)\n출력: (2, 3, 8) -- axis=2\n\n\n- 2D의 경우도 재해석\n\na = np.array([1,2,3,4,5,6]).reshape(3,2)\nb = -a                         \n\n좌우로 합치고 싶다면?? (3,2) concat (3,2) = (3,4) 가 되어야함 –&gt; 그러면 차원의 두번째 숫자가 바뀌어야함.\n\nnp.concatenate([a,b],axis=1)\n\narray([[ 1,  2, -1, -2],\n       [ 3,  4, -3, -4],\n       [ 5,  6, -5, -6]])\n\n\n위아래로 합치고 싶다면? (3,2) concat (3,2) = (6,2) 가 되어야함 –&gt; 그러면 차원의 첫번째 숫자가 바뀌어야함.\n\nnp.concatenate([a,b],axis=0)\n\narray([[ 1,  2],\n       [ 3,  4],\n       [ 5,  6],\n       [-1, -2],\n       [-3, -4],\n       [-5, -6]])\n\n\n- axis=-1로 넣는 경우도 있음..\n\na = np.arange(2*3*4).reshape(2,3,4)\nb = -a\n\n\na.shape, b.shape\n\n((2, 3, 4), (2, 3, 4))\n\n\n(2,3,4) concat (2,3,4) = (2,3,8) 을 만들고 싶다면?? –&gt; 세번째(axis=2)축이 바뀌어야함.\n\nnp.concatenate([a,b],axis=2).shape\n\n(2, 3, 8)\n\n\n(2,3,4) concat (2,3,4) = (2,3,8) 을 만들고 싶다면?? –&gt; 마지막(axis=-1)축이 바껴야함.\n\nnp.concatenate([a,b],axis=-1).shape\n\n(2, 3, 8)\n\n\n(2,3,4) concat (2,3,4) = (2,6,4) 을 만들고 싶다면?? –&gt; 마지막에서 두번째 (axis=-2)축이 바껴야함.\n\nnp.concatenate([a,b],axis=-2).shape\n\n(2, 6, 4)\n\n\n(2,3,4) concat (2,3,4) = (4,3,4) 을 만들고 싶다면?? –&gt; 마지막에서 세번째 (axis=-3)축이 바껴야함.\n\nnp.concatenate([a,b],axis=-3).shape\n\n(4, 3, 4)\n\n\n- 2D의 경우에도 axis=-1, axis=-2를 적용가능\n\na = np.array([1,2,3,4]).reshape(2,2)\nb = np.array([10,20]).reshape(2,1)\n\n\na,b\n\n(array([[1, 2],\n        [3, 4]]),\n array([[10],\n        [20]]))\n\n\n\nnp.concatenate([a,b],axis=-1)\n\narray([[ 1,  2, 10],\n       [ 3,  4, 20]])\n\n\n\nnp.concatenate([b.T,a],axis=-2)\n\narray([[10, 20],\n       [ 1,  2],\n       [ 3,  4]])"
  },
  {
    "objectID": "posts/06wk-2.html#b.-np.stack",
    "href": "posts/06wk-2.html#b.-np.stack",
    "title": "06wk-2: numpy (1)",
    "section": "B. np.stack",
    "text": "B. np.stack\n- 혹시 아래가 가능할까?\n\n(3,) concat (3,) = (3,2)\n\n\na = np.array([1,2,3])\nb = -a \n\n\na,b\n\n(array([1, 2, 3]), array([-1, -2, -3]))\n\n\n\nnp.concatenate([a,b],axis=1)\n\nAxisError: axis 1 is out of bounds for array of dimension 1\n\n\n\n불가능\n\n- 아래와 같은 방식은 가능\n\nnp.concatenate([a.reshape(3,1), b.reshape(3,1)],axis=1)\n\narray([[ 1, -1],\n       [ 2, -2],\n       [ 3, -3]])\n\n\n- 위의 과정을 줄여서 아래와 같이 할 수 있음.\n\nnp.stack([a,b],axis=1)\n\narray([[ 1, -1],\n       [ 2, -2],\n       [ 3, -3]])\n\n\n- 아래와 같은 결합도 가능\n\nnp.stack([a,b],axis=0)\n\narray([[ 1,  2,  3],\n       [-1, -2, -3]])\n\n\n- stack에서 axis의 역할에 대한 분석\n\na = np.arange(5*3*4).reshape(5,3,4)\nb = -a\n\n\nprint(f'입력: {a.shape} stack {b.shape}')\nprint(f'출력: {np.stack([a,b],axis=0).shape} -- axis=0')\nprint(f'출력: {np.stack([a,b],axis=1).shape} -- axis=1')\nprint(f'출력: {np.stack([a,b],axis=2).shape} -- axis=2')\nprint(f'출력: {np.stack([a,b],axis=3).shape} -- axis=3')\n#print(f'출력: {np.stack([a,b],axis=4).shape} -- axis=4')\n\n입력: (5, 3, 4) stack (5, 3, 4)\n출력: (2, 5, 3, 4) -- axis=0\n출력: (5, 2, 3, 4) -- axis=1\n출력: (5, 3, 2, 4) -- axis=2\n출력: (5, 3, 4, 2) -- axis=3\n\n\n- 다시 (3,) stack (3,) 상황을 이해하여보면\n\na = np.array([1,2,3])\nb = -a\n\na,b 모두 1차원이지만 이를 위아래로 붙여서 2차원으로 만들고 싶어. 즉 (3,) stack (3,) = (2,3) 을 만들고 싶음. -&gt; 첫번째 위치에(axis=0)에 축을 추가해야겠음.\n\nnp.stack([a,b],axis=0)\n\narray([[ 1,  2,  3],\n       [-1, -2, -3]])\n\n\na,b 모두 1차원이지만 이를 좌우로 붙여서 2차원으로 만들고 싶어. 즉 (3,) stack (3,) = (3,2) 을 만들고 싶음. -&gt; 두번째 위치에(axis=1)에 축을 추가해야겠음.\n\nnp.stack([a,b],axis=1)\n\narray([[ 1, -1],\n       [ 2, -2],\n       [ 3, -3]])\n\n\nnote: np.concatenate은 축의 총 갯수를 유지하면서 결합, np.stack은 축의 갯수를 하나 증가시키면서 결합"
  },
  {
    "objectID": "posts/06wk-2.html#c.-sum",
    "href": "posts/06wk-2.html#c.-sum",
    "title": "06wk-2: numpy (1)",
    "section": "C. sum",
    "text": "C. sum\n- 1차원\n\na = np.array([1,2,3])\na\n\narray([1, 2, 3])\n\n\n\nnp.sum(a)\n\n6\n\n\n\na.sum() \n\n6\n\n\n\na.sum(axis=0)\n\n6\n\n\n- 2차원\n\na = np.array([1,2,3,4,5,6]).reshape(3,2)\na\n\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n\n\n\na.sum() # 전체합: 1+2+3+4+5+6\n\n21\n\n\n\na.sum(axis=0) # 1열의합, 2열의합\n\narray([ 9, 12])\n\n\n\na.sum(axis=1) # 1행의합, 2행의합, 3행의합\n\narray([ 3,  7, 11])\n\n\na를 2차원 array모양으로 만들고 axis을 잘 써주면 row-wise로 합을 구하거나 column-wise로 합을 구하기 좋음.\n- 넘파이 특수기능 .sum()에서 axis의 의미를 알아보자.\n\na.shape, a.sum(axis=0).shape, a.sum(axis=1).shape\n\n((3, 2), (2,), (3,))\n\n\n- 연습\n\na = np.arange(10).reshape(5,2)\na\n\narray([[0, 1],\n       [2, 3],\n       [4, 5],\n       [6, 7],\n       [8, 9]])\n\n\n행별로 합을 구하고 싶음 -&gt; (5,2)의 차원이 (5,) 와 같이 되어야함. -&gt; 두번째축이 사라져야함\n\na.sum(axis=1)\n\narray([ 1,  5,  9, 13, 17])\n\n\n열별로 합을 구하고 싶음 -&gt; (5,2)의 차원이 (2,) 와 같이 되어야함. -&gt; 첫번째축이 사라져야함\n\na.sum(axis=0)\n\narray([20, 25])\n\n\na의 모든 원소의 합을 구하고 싶다면? -&gt; (5,2)차원이 ()와 같이 되어야함 -&gt; 첫번째축과 두번째축이 다 사라져야함\n\na.sum(axis=(0,1))\n\n45\n\n\n\na.sum() # 아 이것은 사실 a.sum(axis=(0,1)) 의 생략된 표현이었군!\n\n45"
  },
  {
    "objectID": "posts/06wk-2.html#d.-mean-std-max-min-prod",
    "href": "posts/06wk-2.html#d.-mean-std-max-min-prod",
    "title": "06wk-2: numpy (1)",
    "section": "D. mean, std, max, min, prod",
    "text": "D. mean, std, max, min, prod\n- 모두 sum과 비슷한 논리로 mean, std, max, min, prod 을 구할 수 있음\n\na = np.array([1,2,3,4,5,6,7,8]).reshape(4,2)\na\n\narray([[1, 2],\n       [3, 4],\n       [5, 6],\n       [7, 8]])\n\n\n\na.mean(axis=0), a.std(axis=0), a.max(axis=0), a.min(axis=0), a.prod(axis=0)\n\n(array([4., 5.]),\n array([2.23606798, 2.23606798]),\n array([7, 8]),\n array([1, 2]),\n array([105, 384]))\n\n\n\na.mean(axis=1), a.std(axis=1), a.max(axis=1), a.min(axis=1), a.prod(axis=1)\n\n(array([1.5, 3.5, 5.5, 7.5]),\n array([0.5, 0.5, 0.5, 0.5]),\n array([2, 4, 6, 8]),\n array([1, 3, 5, 7]),\n array([ 2, 12, 30, 56]))"
  },
  {
    "objectID": "posts/06wk-2.html#e.-argmax-argmin",
    "href": "posts/06wk-2.html#e.-argmax-argmin",
    "title": "06wk-2: numpy (1)",
    "section": "E. argmax, argmin",
    "text": "E. argmax, argmin\n- 1차원\n\na = np.array([22,-2,3,10,4])\na\n\narray([22, -2,  3, 10,  4])\n\n\n\na.argmax(),a.argmin()\n\n(0, 1)\n\n\n- 2차원\n\nnp.random.seed(43052)\na = np.random.rand(10).reshape(5,2)\na\n\narray([[0.81768226, 0.04953212],\n       [0.83868626, 0.61977707],\n       [0.12254052, 0.11712779],\n       [0.8795562 , 0.97941543],\n       [0.90986893, 0.96667407]])\n\n\n\na.argmax(axis=0),a.argmin(axis=0)\n\n(array([4, 3]), array([2, 0]))\n\n\n\na.argmax(axis=1),a.argmin(axis=1)\n\n(array([0, 0, 0, 1, 1]), array([1, 1, 1, 0, 0]))"
  },
  {
    "objectID": "posts/06wk-2.html#f.-cumsum-cumprod",
    "href": "posts/06wk-2.html#f.-cumsum-cumprod",
    "title": "06wk-2: numpy (1)",
    "section": "F. cumsum, cumprod",
    "text": "F. cumsum, cumprod\n- 1차원\n\na = np.array([1,2,3,4])\na\n\narray([1, 2, 3, 4])\n\n\n\nnp.cumsum(a), a.cumsum()\n\n(array([ 1,  3,  6, 10]), array([ 1,  3,  6, 10]))\n\n\n\nnp.cumprod(a), a.cumprod()\n\n(array([ 1,  2,  6, 24]), array([ 1,  2,  6, 24]))\n\n\n- 2차원\n\na = np.array([1,2,3,4,5,6,7,8,9,10,11,12]).reshape(4,3)\na\n\narray([[ 1,  2,  3],\n       [ 4,  5,  6],\n       [ 7,  8,  9],\n       [10, 11, 12]])\n\n\n\na.cumsum(axis=0),a.cumsum(axis=1),a.cumprod(axis=0),a.cumprod(axis=1)\n\n(array([[ 1,  2,  3],\n        [ 5,  7,  9],\n        [12, 15, 18],\n        [22, 26, 30]]),\n array([[ 1,  3,  6],\n        [ 4,  9, 15],\n        [ 7, 15, 24],\n        [10, 21, 33]]),\n array([[   1,    2,    3],\n        [   4,   10,   18],\n        [  28,   80,  162],\n        [ 280,  880, 1944]]),\n array([[   1,    2,    6],\n        [   4,   20,  120],\n        [   7,   56,  504],\n        [  10,  110, 1320]]))"
  },
  {
    "objectID": "posts/06wk-2.html#g.-diff",
    "href": "posts/06wk-2.html#g.-diff",
    "title": "06wk-2: numpy (1)",
    "section": "G. diff",
    "text": "G. diff\n- 1차원 차분\n\na = np.array([1,2,4,7,15])\na\n\narray([ 1,  2,  4,  7, 15])\n\n\n\nnp.diff(a)\n\narray([1, 2, 3, 8])\n\n\n\nnp.diff(a,prepend=100)\n\narray([-99,   1,   2,   3,   8])\n\n\n\nnp.diff(a,prepend=a[0])\n\narray([0, 1, 2, 3, 8])\n\n\n\nnp.diff(a,append=100)\n\narray([ 1,  2,  3,  8, 85])\n\n\n\nnp.diff(a,append=a[-1])\n\narray([1, 2, 3, 8, 0])\n\n\n- 2차원 array의 미분\n\na = np.arange(24).reshape(4,6)\na\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17],\n       [18, 19, 20, 21, 22, 23]])\n\n\n\nnp.diff(a,axis=0) # 열별로 연산이 적용\n\narray([[6, 6, 6, 6, 6, 6],\n       [6, 6, 6, 6, 6, 6],\n       [6, 6, 6, 6, 6, 6]])\n\n\n\nnp.diff(a,axis=1) # 행별로 연산이 적용\n\narray([[1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1]])"
  },
  {
    "objectID": "posts/03wk-1.html",
    "href": "posts/03wk-1.html",
    "title": "03wk-1: 퀴즈2",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\n\n\n\n\n\nCaution\n\n\n\n\n전북대 학생들을 시험당일 학생증을 지참할 것. (출석체크 및 본인확인) 학생증 외에 신분증 여권등도 가능.\n부정행위 (카카오톡 채팅을 통한 코드공유, 생성형모델 사용, 대리시험 등) 적발시 F 처리함.\n퀴즈 중 지각할 경우 지각사실을 기록함. 하지만 별다른 감점은 하지 않음.\n.ipynb 파일 형태로 제출된 답안지만 채점하며 그 외의 형식 (.hwp, .py 등)은 채점하지 않음. 즉 0점 처리함.\n\n\n\n\n문제 1. – 10점\n\\(f(x)=x^3\\) 위의 임의의 점을 입력하면 접선을 리턴하는 함수를 구현하라. 이러한 함수를 이용하여 아래와 같은 그래프를 그려라. (범례는 표현하지 않아도 감점없음)\n\n#\n\n\n\n\n\n\n\n\n\n\\(x\\)의 범위는 \\((-5,5)\\) 이다.\n두 그래프는 \\(x=3\\) 에서 접한다.\n\n(풀이)\n\ndef make_func(x0):\n    f = lambda x: x**3\n    def func(x):\n        h = 0.0001\n        a = (f(x0+h)-f(x0))/h \n        return a*(x-x0) + f(x0)\n    return func\nx = np.linspace(-5,5,101)\ntan_line = make_func(3)\nplt.plot(x,x**3,'--')\nplt.plot(x,tan_line(x),'--')\n\n\n\n\n\n\n\n\n\n\n문제 2. – 10점1\n함수 \\(f(x)=(x+1)(x^2+3)\\)에 대하여 \\(f'(1)\\)의 값을 구하라.\n(풀이)\n\nf = lambda x: (x+1)*(x**2+3)\nh = 0.000001\n(f(1+h)-f(1))/h\n\n8.000004001473826\n\n\n\n1 2024년 수능 17번2 2024년 수능 4번 응용\n문제 3. – 10점2\n\\(0 \\leq x \\leq 4\\)의 범위에서 함수\n\\[f(x) =\\begin{cases} 3x-1 \\quad (x&lt;2) \\\\ x^2+1 \\quad (x\\geq 2) \\end{cases}\\]\n의 그래프를 그려라.\n(풀이)\n\nf = lambda x: 3*x-1 if x&lt;2 else x**2+1\nx = np.linspace(0,4,101)\nplt.plot(x,list(map(f,x)))\n\n\n\n\n\n\n\n\n\n\n문제 4. – 10점3\n\\(\\frac{3}{2}\\pi &lt; \\theta &lt; 2\\pi\\) 인 \\(\\theta\\) 에 대하여 \\(\\cos\\theta = \\frac{\\sqrt{6}}{3}\\) 일 때 \\(\\tan(\\theta)\\)의 값을 구하라.\n(풀이)\n\ntheta = np.linspace(3/2*np.pi,2*np.pi,100)\nnp.argmin(np.abs(np.cos(theta) - np.sqrt(6)/3))\n\n60\n\n\n\nnp.tan(theta[60])\n\n-0.7120967763793676\n\n\n\n3 2024년 9평 3번4 2024년 9평 25번\n문제 5. – 10점4\n함수 \\(f(x)=x+\\ln x\\)에 대하여 \\(\\int_1^{e} (1+\\frac{1}{x})f(x)dx\\)의 값은?\n(풀이)\n\nf = lambda x: x+np.log(x)\nx = np.linspace(1,np.exp(1),100)\nnp.mean((1+1/x)*f(x)) * (np.exp(1)-1)\n\n6.409521328970472\n\n\n\n\n문제 6. – 20점\n\n(2)번만 맞추어도 정답으로 인정\n\n(1) \\(f'(x)=x\\) 일 경우 \\(f(x)\\)의 그래프 개형을 그려라.\n(2) \\(f'(x)=|\\sin(x)|\\cos(x)\\) 일때 \\(f(x)\\)의 그래프 개형을 그려라.5\n5 2024년 수능 30번 변형\n\\(-3&lt;x&lt;3\\) 에서의 개형을 그릴것\n\n\n# 시각화예시\n\n\n\n\n\n\n\n\n(풀이)\n\nx = np.linspace(-3,3,101)\nff = np.abs(np.sin(x))*np.cos(x)\nf = np.cumsum(ff) * 0.06 \n\n\nplt.plot(x,ff)\nplt.plot(x,f)\n\n\n\n\n\n\n\n\n\n\n문제 7. – 30점\n첫째항이 1이고 공차가 \\(0&lt;d&lt;1\\) 인 등차수열에서, \\(\\sum_{n=1}^{75}a_n=1046.25\\) 를 만족하는 \\(d\\)를 찾아라.\n힌트1: 첫째항이 1이고 공차가 \\(d&gt;0\\)인 등차수열의 일반항은 \\(a_n = 1 +(n-1)d\\)와 같이 표현할 수 있다.\n힌트2: \\(d\\)는 아래중 하나의 값을 가진다.\n\nnp.linspace(0,1,101)[1:-1]\n\narray([0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1 , 0.11,\n       0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.2 , 0.21, 0.22,\n       0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3 , 0.31, 0.32, 0.33,\n       0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4 , 0.41, 0.42, 0.43, 0.44,\n       0.45, 0.46, 0.47, 0.48, 0.49, 0.5 , 0.51, 0.52, 0.53, 0.54, 0.55,\n       0.56, 0.57, 0.58, 0.59, 0.6 , 0.61, 0.62, 0.63, 0.64, 0.65, 0.66,\n       0.67, 0.68, 0.69, 0.7 , 0.71, 0.72, 0.73, 0.74, 0.75, 0.76, 0.77,\n       0.78, 0.79, 0.8 , 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87, 0.88,\n       0.89, 0.9 , 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99])\n\n\n(풀이)\n\ndef func(d):\n    n = np.arange(1,76)\n    an = 1+(n-1)*d\n    return np.abs(np.sum(an)-1046.25)\n\n\nd_arr = np.linspace(0,1,101)[1:-1]\nd_arr[np.argmin(list(map(func,d_arr)))]\n\n0.35000000000000003\n\n\n\n\n\n\n\n\nNote\n\n\n\n정답을 구하지 못하여도 논리전개가 올바르면 만점처리함. 노가다로 답을 구한 경우 정답으로 인정하지 않음."
  },
  {
    "objectID": "posts/08wk-2.html",
    "href": "posts/08wk-2.html",
    "title": "08wk-2: 랜덤모듈을 이용한 시뮬레이션 문제 예시",
    "section": "",
    "text": "0. break 와 while 이해\n(1) 아래의 예시를 보고 break 의 사용방법을 파악하라.\n\n# 주어진 문자열\nword = \"hello\"\n\n# 문자열에서 첫 번째 모음을 찾는 코드\nfor letter in word:\n    if letter in \"aeiou\":  # 현재 문제가 모음인지 확인\n        print(f\"첫번째 모음은: {letter}\")\n        break  # 첫번째 모음을 찾으면 반복을 종료 \n\n첫번째 모음은: e\n\n\n(2) 아래의 예시를 보고 while의 사용방법을 파악하라.\n\nnum = 6\n\n# 입력된 숫자의 팩토리얼을 계산\nfactorial = 1\nwhile num &gt; 0:\n    factorial = factorial*num\n    num = num - 1\n\n# 계산된 팩토리얼을 출력\nprint(f\"팩토리얼:\", factorial)\n\n팩토리얼: 720\n\n\n\nnum = 6\n\n# 입력된 숫자의 팩토리얼을 계산\nfactorial = 1\nwhile True:\n    factorial = factorial*num\n    num = num - 1\n    if num == 0: \n        break \n        \n# 계산된 팩토리얼을 출력\nprint(f\"팩토리얼:\", factorial)\n\n팩토리얼: 720\n\n\n\n\n1. 가위바위보 하나빼기\n(1) 보람과 서연은 “가위바위보 하나빼기” 게임을 하려고 한다. 보람은 현재 [‘가위’,‘바위’] 를 가지고 있으며 서연은 현재 [‘가위’,‘보’] 를 가지고 있다. 보람과 서연이 가지고 있는 패 중 랜덤으로 하나를 낸다고 하자. 보람과 서연중 누가 더 유리한가? 1000번의 시뮬레이션을 통하여 검증하고 결과를 해석하라.\n\n\n2. 공든탑 쌓기\n규빈과 다호가 블록을 사용하여 탑을 쌓는다. 규빈은 한 번에 2개의 블록을 사용하여 탑을 쌓지만, 실수로 탑을 무너뜨릴 확률이 50%이다. 한 번 무너진 탑은 다시 처음부터 쌓아야 한다. 다호는 한 번에 1개의 블록을 사용하여 신중하게 탑을 쌓는다. 다호는 천천히 탑을 쌓지만 실수로 탑을 무너뜨리지 않는다.\n(1) 2층 높이의 탑을 쌓을 때, 규빈과 다호 중 누가 먼저 탑을 올릴 확률이 높을까? 1000번의 시뮬레이션을 통해 결과를 확인해보라.\n\n\n3. 규빈과 하니의 내기\n(1) 앞면과 뒷면이 나올 확률이 각각 1/2인 동전을 생각하자. 하니와 규빈은 이 동전을 연속으로 던져서 아래와 같은 룰을 정하여 내기를 하였다.\n\n동전을 연속으로 반복하여 던진다. 최근 2회의 결과가 (뒷면,앞면) 이 나오면 하니의 승리\n동전을 연속으로 반복하여 던진다. 최근 2회의 결과가 (뒷면,뒷면) 이 나오면 규빈의 승리\n\n이 내기는 하니가 유리한가? 규빈이 유리한가? 시뮬레이션을 통해 검증하라.\n\n힌트: 똑같이 유리함\n\n(2) 앞면과 뒷면이 나올 확률이 각각 1/2인 동전을 생각하자. 하니와 규빈은 이 동전을 연속으로 던져서 아래와 같은 룰을 정하여 내기를 하였다.\n\n동전을 연속으로 반복하여 던진다. 최근 2회의 결과가 (앞면,뒷면) 이 나오면 하니의 승리\n동전을 연속으로 반복하여 던진다. 최근 2회의 결과가 (뒷면,뒷면) 이 나오면 규빈의 승리\n\n이 내기는 하니가 유리한가? 규빈이 유리한가? 시뮬레이션을 통해 검증하고 이유를 설명하라.\n\n힌트: 하니가 유리함"
  },
  {
    "objectID": "posts/07wk-2.html#a.-np.random.rand",
    "href": "posts/07wk-2.html#a.-np.random.rand",
    "title": "07wk-2: numpy (2)",
    "section": "A. np.random.rand()",
    "text": "A. np.random.rand()\n- 0~1 사이의 난수를 생성\n\nnp.random.rand(10)\n\narray([0.1088988 , 0.37600298, 0.47693689, 0.9080132 , 0.89285882,\n       0.55646521, 0.30530448, 0.80673809, 0.47271228, 0.39307233])\n\n\n- 0~2 사이의 난수를 생성\n\nnp.random.rand(10)*2\n\narray([0.76463268, 1.48478853, 0.87077971, 0.27115035, 1.80946471,\n       0.32479018, 0.70563006, 1.84855923, 1.40713373, 1.8003245 ])\n\n\n- 1~2사이의 난수를 생성\n\nnp.random.rand(10) + 1\n\narray([1.26688872, 1.466542  , 1.6286699 , 1.32346867, 1.94929863,\n       1.79061649, 1.21416972, 1.60339969, 1.23340892, 1.87725052])\n\n\n- 1~3사이의 난수를 생성\n\nnp.random.rand(10)*2+1 #1~3\n\narray([1.01418556, 1.41178021, 2.247176  , 2.40313287, 2.71599364,\n       1.33547793, 1.29492572, 2.11997705, 2.6255564 , 1.08540636])"
  },
  {
    "objectID": "posts/07wk-2.html#b.-np.random.randn",
    "href": "posts/07wk-2.html#b.-np.random.randn",
    "title": "07wk-2: numpy (2)",
    "section": "B. np.random.randn()",
    "text": "B. np.random.randn()\n- N(0,1)에서 난수생성\n\nnp.random.randn(10) # 표준정규분포에서 10개의 샘플 추출\n\narray([ 1.11130021, -0.72092669, -0.48191068,  0.43156103, -0.06850191,\n        0.1194882 , -1.88459261,  0.37488117, -0.38512838,  0.72947187])\n\n\n- N(1,1)에서 난수생성\n\nnp.random.randn(10) + 1 \n\narray([ 1.24137778, -0.09684431,  1.38100482,  0.01455149,  3.41866724,\n        0.25701759,  1.66288034, -0.06448819,  0.9563526 ,  1.94659513])\n\n\n- N(0,4)에서 난수생성\n\nnp.random.randn(10)*2\n\narray([ 3.48443268, -0.69172918,  0.56957012,  2.44095731,  0.06049988,\n        1.66648164, -1.87244278, -1.47143887, -0.05272601,  0.01798293])\n\n\n- N(3,4)에서 난수생성\n\nnp.random.randn(10)*2 + 3\n\narray([2.38179634, 3.71200412, 0.34203777, 1.84888258, 3.90660281,\n       1.42357852, 1.85172658, 2.27043661, 6.70173343, 2.25396495])"
  },
  {
    "objectID": "posts/07wk-2.html#c.-np.random.choice",
    "href": "posts/07wk-2.html#c.-np.random.choice",
    "title": "07wk-2: numpy (2)",
    "section": "C. np.random.choice()",
    "text": "C. np.random.choice()\n- [0,1,2,3,4] 에서 임의의 원소를 하나 뽑는 방법\n\nnp.random.choice([0,1,2,3,4])\n\n2\n\n\n- [0,1,2,3,4] 에서 30개의 원소를 뽑는 방법\n\nnp.random.choice([0,1,2,3,4],size=30)\n\narray([1, 2, 4, 2, 2, 3, 2, 2, 3, 0, 3, 0, 0, 4, 3, 0, 2, 0, 4, 0, 1, 3,\n       2, 3, 1, 4, 0, 4, 2, 1])\n\n\n\nnp.random.choice(range(5),size=30)\n\narray([4, 0, 3, 4, 4, 4, 4, 1, 3, 3, 4, 2, 1, 1, 2, 4, 1, 0, 1, 1, 2, 3,\n       4, 4, 0, 1, 0, 3, 2, 3])\n\n\n- [‘사과’,‘딸기’,‘딸기’,‘배’] 에서 10000개의 원소를 뽑는 방법\n\nlst = list(np.random.choice(['사과','딸기','딸기','배'],size=10000))\n{s:lst.count(s) for s in set(lst)}\n\n{'배': 2494, '사과': 2494, '딸기': 5012}\n\n\n- [‘사과’,‘딸기’,‘딸기’,‘배’] 에서 3개의 원소를 중복을 허용하지 않고 (= 뽑은걸 다시 넣지 않고) 뽑는 방법\n\nnp.random.choice(['사과','딸기','딸기','배'],size=3,replace=False) \n\narray(['딸기', '딸기', '사과'], dtype='&lt;U2')\n\n\n\nnp.random.choice(['사과','딸기','딸기','배'],size=4,replace=False) \n\narray(['딸기', '배', '사과', '딸기'], dtype='&lt;U2')\n\n\n\nnp.random.choice(['사과','딸기','딸기','배'],size=5,replace=False) \n\nValueError: Cannot take a larger sample than population when 'replace=False'"
  },
  {
    "objectID": "posts/07wk-2.html#d.-np.random.randint",
    "href": "posts/07wk-2.html#d.-np.random.randint",
    "title": "07wk-2: numpy (2)",
    "section": "D. np.random.randint()",
    "text": "D. np.random.randint()\n- [0,1,2,3] 에서 하나의 정수를 뽑는 방법\n\n#[0,1,2,3] 은 [0,4) 구간에 존재하는 정수로 해석가능함. \nnp.random.randint(low=0,high=4) # = np.random.choice(range(4))\n\n0\n\n\n- [0,1,2,3] 에서 30개의 정수를 뽑는 방법\n\nnp.random.randint(low=0,high=4,size=30)\n\narray([1, 2, 0, 2, 1, 0, 1, 2, 3, 1, 2, 2, 2, 1, 2, 3, 1, 2, 1, 2, 2, 2,\n       1, 3, 1, 0, 3, 2, 1, 1])"
  },
  {
    "objectID": "posts/07wk-2.html#e.-통계분포",
    "href": "posts/07wk-2.html#e.-통계분포",
    "title": "07wk-2: numpy (2)",
    "section": "E. 통계분포",
    "text": "E. 통계분포\n- 균등분포에서 난수생성\n\nnp.random.uniform(low=0,high=1,size=10) # np.random.rand(10) \n\narray([0.97503796, 0.0055021 , 0.94807051, 0.54400283, 0.8608399 ,\n       0.42374177, 0.55656185, 0.18683287, 0.84113128, 0.15987594])\n\n\n\nnp.random.uniform(low=0,high=2,size=10) # np.random.rand(10)*2\n\narray([1.92048296, 0.46776058, 0.88091555, 0.6673604 , 0.526995  ,\n       0.29801036, 0.09474962, 0.7326608 , 1.5746169 , 1.93166694])\n\n\n\nnp.random.uniform(low=2,high=4,size=10) # np.random.rand(10)*2+2\n\narray([3.84313973, 3.37684629, 2.39498209, 2.08586093, 2.40786316,\n       3.82188018, 3.35690899, 3.54373758, 3.73046583, 2.44734642])\n\n\n- 정규분포에서 난수생성\n\nnp.random.normal(loc=0,scale=1,size=10) # np.random.randn(10)\n\narray([ 1.41964858,  1.81804915,  1.90248078, -0.35544912,  0.74318258,\n       -0.20358438, -1.02604971,  1.21790816,  1.00842447,  1.32410826])\n\n\n\nnp.random.normal(loc=0,scale=2,size=10) # np.random.randn(10)*2 \n\narray([-2.43492087,  0.03145487,  0.19747163, -3.24386299, -0.15816569,\n       -4.11416044, -4.17102965,  1.56781517,  0.01883716, -1.86230904])\n\n\n\nnp.random.normal(loc=5,scale=2,size=10) # np.random.randn(10)*2 + 5 \n\narray([ 5.82768761,  3.1097944 ,  3.58905114,  3.95103801,  9.90936984,\n        5.98192221,  5.42354253,  4.69164569, -0.73867164,  6.98284749])\n\n\n- 이항분포\n\nlst = np.random.binomial(n=2, p=0.5, size=10000).tolist()\n{s:lst.count(s) for s in set(lst)}\n\n{0: 2506, 1: 5040, 2: 2454}\n\n\n- 포아송분포\n\nnp.random.poisson(lam=1.0,size=100)\n\narray([2, 2, 1, 1, 1, 1, 0, 4, 2, 0, 3, 0, 2, 3, 0, 1, 1, 0, 4, 0, 0, 1,\n       0, 0, 0, 2, 1, 0, 1, 0, 1, 0, 0, 2, 0, 2, 2, 0, 1, 1, 3, 1, 0, 0,\n       2, 0, 0, 1, 3, 0, 1, 2, 0, 1, 0, 0, 0, 0, 0, 3, 1, 1, 1, 3, 1, 1,\n       0, 0, 1, 0, 0, 3, 1, 0, 1, 0, 3, 1, 1, 2, 0, 1, 0, 0, 3, 1, 1, 1,\n       0, 2, 1, 1, 0, 1, 2, 0, 3, 2, 1, 0])"
  },
  {
    "objectID": "posts/07wk-2.html#a.-np.where-np.argwhere",
    "href": "posts/07wk-2.html#a.-np.where-np.argwhere",
    "title": "07wk-2: numpy (2)",
    "section": "A. np.where, np.argwhere",
    "text": "A. np.where, np.argwhere\n- 1차원\n\na = np.array([0,0,0,1,0])\na\n\narray([0, 0, 0, 1, 0])\n\n\n\nnp.where(a==1), np.where(a==0)\n\n((array([3]),), (array([0, 1, 2, 4]),))\n\n\n\nnp.argwhere(a==1), np.argwhere(a==0)\n\n(array([[3]]),\n array([[0],\n        [1],\n        [2],\n        [4]]))\n\n\n- 2차원\n\nnp.random.seed(43052)\na = np.random.randn(12).reshape(3,4)\na\n\narray([[ 0.38342049,  1.0841745 ,  1.14277825,  0.30789368],\n       [ 0.23778744,  0.35595116, -1.66307542, -1.38277318],\n       [-1.92684484, -1.4862163 ,  0.00692519, -0.03488725]])\n\n\n\nnp.where(a&lt;0),np.argwhere(a&lt;0)\n\n((array([1, 1, 2, 2, 2]), array([2, 3, 0, 1, 3])),\n array([[1, 2],\n        [1, 3],\n        [2, 0],\n        [2, 1],\n        [2, 3]]))\n\n\n\na[1,2],a[1,3],a[2,0],a[2,1],a[2,3] \n\n(-1.6630754187023522,\n -1.382773180699087,\n -1.9268448358915802,\n -1.4862162961554322,\n -0.03488724631833874)\n\n\n\n인덱스를 읽기에는 np.argwhere 이 편한듯\n\n의문: np.where()은 필요없는가? –&gt; 사실 np.where()이 np.argwhere()보다 쓸만함\n\nnp.random.seed(43052)\na = np.random.randn(12).reshape(3,4)\na\n\narray([[ 0.38342049,  1.0841745 ,  1.14277825,  0.30789368],\n       [ 0.23778744,  0.35595116, -1.66307542, -1.38277318],\n       [-1.92684484, -1.4862163 ,  0.00692519, -0.03488725]])\n\n\na의 원소중 0보다 작은것을 출력하고 싶다면?\n\na[np.where(a&lt;0)] # 출력가능\n\narray([-1.66307542, -1.38277318, -1.92684484, -1.4862163 , -0.03488725])\n\n\n\na[np.argwhere(a&lt;0)] # 출력불가능\n\nIndexError: index 3 is out of bounds for axis 0 with size 3\n\n\na의 원소중 0보다 작은것을 0으로 바꾸고 싶다면?\n\nnp.random.seed(43052)\na = np.random.randn(12).reshape(3,4)\na\n\narray([[ 0.38342049,  1.0841745 ,  1.14277825,  0.30789368],\n       [ 0.23778744,  0.35595116, -1.66307542, -1.38277318],\n       [-1.92684484, -1.4862163 ,  0.00692519, -0.03488725]])\n\n\n\nnp.where(a&lt;0,0,a) # a&lt;0을 체크 -&gt; 조건에 맞으면 0 -&gt; 조건에 안맞으면 a\n\narray([[0.38342049, 1.0841745 , 1.14277825, 0.30789368],\n       [0.23778744, 0.35595116, 0.        , 0.        ],\n       [0.        , 0.        , 0.00692519, 0.        ]])\n\n\n\nnp.where(a&lt;0,0,100) # a&lt;0을 체크 -&gt; 조건에 맞으면 0 -&gt; 조건에 안맞으면 100\n\narray([[100, 100, 100, 100],\n       [100, 100,   0,   0],\n       [  0,   0, 100,   0]])\n\n\n- 요약: np.argwhere()이 인덱스의 좌표를 읽을때 가독성이 있으나 조건에 맞는 원소를 출력하거나 처리할때는 np.where()이 유용함."
  },
  {
    "objectID": "posts/07wk-2.html#b.-인덱싱-실수하지마세요",
    "href": "posts/07wk-2.html#b.-인덱싱-실수하지마세요",
    "title": "07wk-2: numpy (2)",
    "section": "B. 인덱싱 (실수하지마세요)",
    "text": "B. 인덱싱 (실수하지마세요)\n- 아래와 같은 2d-array를 고려하자.\n\na = np.arange(12).reshape(3,4)\na\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n- 첫번째 행을 뽑을때, 축의 숫자를 줄이고 싶을때도 있고 축의 숫자를 유지하고 싶을때도 있음.\n\na[0,:] # 첫번째 행을 뽑는코드1 = 축이 하나 줄어든다\n\narray([0, 1, 2, 3])\n\n\n\na[[0],:] # 첫번째 행을 뽑는코드2 = 축의 숫자가 유지된다. \n\narray([[0, 1, 2, 3]])\n\n\n- 세번째 열을 뽑을때, 축의 숫자를 줄이고 싶을때도 있고 축의 숫자를 유지하고 싶을때도 있음.\n\na[:,2] # 세번째 열을 뽑는코드1 = 축이 하나 줄어든다\n\narray([ 2,  6, 10])\n\n\n\na[:,[2]] # 세번째 열을 뽑는코드2 = 축의 숫자가 유지된다. \n\narray([[ 2],\n       [ 6],\n       [10]])"
  },
  {
    "objectID": "posts/07wk-2.html#c.-np.ix_",
    "href": "posts/07wk-2.html#c.-np.ix_",
    "title": "07wk-2: numpy (2)",
    "section": "C. np.ix_",
    "text": "C. np.ix_\n\na = np.arange(12).reshape(3,4)\na\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n\na[0:3,0:3]\n\narray([[ 0,  1,  2],\n       [ 4,  5,  6],\n       [ 8,  9, 10]])\n\n\n\na[[0,1,2],0:3]\n\narray([[ 0,  1,  2],\n       [ 4,  5,  6],\n       [ 8,  9, 10]])\n\n\n\na[0:3,[0,1,2]]\n\narray([[ 0,  1,  2],\n       [ 4,  5,  6],\n       [ 8,  9, 10]])\n\n\n\na[[0,1,2],[0,1,2]] # 이건 왜이래?\n\narray([ 0,  5, 10])\n\n\n- 사실 np.where 에서 이러한 결과를 보긴했음\n\na[np.where(a % 5 ==0)]\n\narray([ 0,  5, 10])\n\n\n\na[[0,1,2],[0,1,2]] # 이 코드는 a[0:3,0:3] 와 다르다!\n\narray([ 0,  5, 10])\n\n\n\n헷갈리게 만든건 맞음. 결론은 실수하면 안됨.\n\n- 그런데 가끔은 a[[0,1,2],[0,1,2]] 이 a[0:3,0:3]를 의미하도록 하고 싶음.\n\na[[0,1,2],[0,1,2]] # 이건 이상하게 동작하는데..\n\narray([ 0,  5, 10])\n\n\n\na[np.ix_([0,1,2],[0,1,2])] # 이건 상식적으로 동작함..\n\narray([[ 0,  1,  2],\n       [ 4,  5,  6],\n       [ 8,  9, 10]])"
  },
  {
    "objectID": "posts/07wk-2.html#d.-메소드의-도움말을-자세히-확인하기",
    "href": "posts/07wk-2.html#d.-메소드의-도움말을-자세히-확인하기",
    "title": "07wk-2: numpy (2)",
    "section": "D. 메소드의 도움말을 자세히 확인하기",
    "text": "D. 메소드의 도움말을 자세히 확인하기\n- 넘파이에서 a.sum()에 대한 도움말은 np.sum을 확인하면 더 자세하게 읽을 수 있음."
  },
  {
    "objectID": "posts/07wk-2.html#e.-hstack-vstack",
    "href": "posts/07wk-2.html#e.-hstack-vstack",
    "title": "07wk-2: numpy (2)",
    "section": "E. hstack, vstack",
    "text": "E. hstack, vstack\n- hstack, vstack을 쓰는 사람도 있다.\n\na = np.arange(6)\nb = -a \n\n\nnp.vstack([a,b]) # 출력이 2차원\n# np.stack([a,b],axis=0) -- 이거랑 같은코드\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 0, -1, -2, -3, -4, -5]])\n\n\n\nnp.hstack([a,b]) # 출력이 1차원\n# np.concatenate([a,b],axis=0) -- 이거랑 같은 코드\n\narray([ 0,  1,  2,  3,  4,  5,  0, -1, -2, -3, -4, -5])"
  },
  {
    "objectID": "posts/07wk-2.html#f.-append",
    "href": "posts/07wk-2.html#f.-append",
    "title": "07wk-2: numpy (2)",
    "section": "F. append",
    "text": "F. append\n- 이걸 쓰는 사람도 있음\n- 활용방법1: reshape(-1) + concat\n\na = np.arange(30).reshape(5,6)\nb = -np.arange(8).reshape(2,2,2)\n\n\na, b\n\n(array([[ 0,  1,  2,  3,  4,  5],\n        [ 6,  7,  8,  9, 10, 11],\n        [12, 13, 14, 15, 16, 17],\n        [18, 19, 20, 21, 22, 23],\n        [24, 25, 26, 27, 28, 29]]),\n array([[[ 0, -1],\n         [-2, -3]],\n \n        [[-4, -5],\n         [-6, -7]]]))\n\n\n\na.shape, b.shape\n\n((5, 6), (2, 2, 2))\n\n\n\nnp.append(a,b)\n# np.concatenate([a.reshape(-1), b.reshape(-1)]) -- 같은코드\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,  0, -1, -2, -3,\n       -4, -5, -6, -7])\n\n\n- 활용방법2: reshape(-1) + concat\n\na = np.arange(2*3*4).reshape(2,3,4)\nb = -a\n\n\na.shape, b.shape\n\n((2, 3, 4), (2, 3, 4))\n\n\n\nnp.append(a,b,axis=0)\n#np.concatenate([a,b],axis=0) -- 이거랑 같은코드\n\narray([[[  0,   1,   2,   3],\n        [  4,   5,   6,   7],\n        [  8,   9,  10,  11]],\n\n       [[ 12,  13,  14,  15],\n        [ 16,  17,  18,  19],\n        [ 20,  21,  22,  23]],\n\n       [[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]]])\n\n\nappend와 concat은 약간의 차이가 있음 – append는 3개이상을 concat할 수 없음.\n\na = np.arange(2*3*4).reshape(2,3,4)\nb = -a\nc = 2*a\n\n\nnp.concatenate([a,b,c],axis=0)\n\narray([[[  0,   1,   2,   3],\n        [  4,   5,   6,   7],\n        [  8,   9,  10,  11]],\n\n       [[ 12,  13,  14,  15],\n        [ 16,  17,  18,  19],\n        [ 20,  21,  22,  23]],\n\n       [[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]],\n\n       [[  0,   2,   4,   6],\n        [  8,  10,  12,  14],\n        [ 16,  18,  20,  22]],\n\n       [[ 24,  26,  28,  30],\n        [ 32,  34,  36,  38],\n        [ 40,  42,  44,  46]]])\n\n\n\nnp.append(a,b,c,axis=0) # 3개는 에러..\n\nTypeError: append() got multiple values for argument 'axis'"
  },
  {
    "objectID": "posts/07wk-2.html#g.-ravel-faltten",
    "href": "posts/07wk-2.html#g.-ravel-faltten",
    "title": "07wk-2: numpy (2)",
    "section": "G. ravel, faltten",
    "text": "G. ravel, faltten\n\na = np.arange(2*3*4).reshape(2,3,4)\na\n\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n\n\n\na.reshape(-1)\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])\n\n\n\na.ravel()\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])\n\n\n\na.flatten()\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])"
  },
  {
    "objectID": "posts/07wk-2.html#h.-통계관련-함수들",
    "href": "posts/07wk-2.html#h.-통계관련-함수들",
    "title": "07wk-2: numpy (2)",
    "section": "H. 통계관련 함수들",
    "text": "H. 통계관련 함수들\n- 평균, 중앙값\n\na = np.random.randn(1000)*2 + 1 \na.mean(), np.median(a)\n\n(0.8895052521575179, 0.9436102467241907)\n\n\n- 표준편차, 분산\n\na = np.random.randn(1000)*2 + 1 \na.var(), a.std()\n\n(4.123382455103265, 2.0306113500872747)\n\n\n\n# 자유도의 조절\na.var(ddof=1), a.std(ddof=1)\n\n(4.127509965068334, 2.0316274178766967)\n\n\n- corr matrix, cov matrix\n\nx = np.random.randn(10000)\ny = np.random.randn(10000)*2\nz = np.random.randn(10000)*0.5\n\n\nnp.cov([x,y,z]).round(2)\n\narray([[ 1.  , -0.02,  0.  ],\n       [-0.02,  4.08,  0.01],\n       [ 0.  ,  0.01,  0.25]])\n\n\n\nnp.corrcoef([x,y,z]).round(2)\n\narray([[ 1.  , -0.01,  0.  ],\n       [-0.01,  1.  ,  0.01],\n       [ 0.  ,  0.01,  1.  ]])"
  },
  {
    "objectID": "posts/07wk-2.html#i.-dtype",
    "href": "posts/07wk-2.html#i.-dtype",
    "title": "07wk-2: numpy (2)",
    "section": "I. dtype",
    "text": "I. dtype\n- np.array 에는 항상 dtype이 있다.\n\na = np.array([1,2,3])\na.dtype\n\ndtype('int64')\n\n\n\na = np.array([1.0, 2.0, 3.0])\na.dtype\n\ndtype('float64')\n\n\n- 같은 int라고 해도 int16, int32, int64와 같이 타입이 다를 수 있다.\n\na = np.array([1,2,3], dtype=np.int64)\na\n\narray([1, 2, 3])\n\n\n\na = np.array([1,2,3], dtype=np.int32)\na\n\narray([1, 2, 3], dtype=int32)\n\n\n\na = np.array([1,2,3], dtype=np.int16)\na\n\narray([1, 2, 3], dtype=int16)\n\n\n- 같은 float라고 해도 float16, float32, float64와 같이 타입이 다를 수 있다.\n\na = np.array([1,2,3], dtype=np.float64)\na\n\narray([1., 2., 3.])\n\n\n\na = np.array([1,2,3], dtype=np.float32)\na\n\narray([1., 2., 3.], dtype=float32)\n\n\n\na = np.array([1,2,3], dtype=np.float16)\na\n\narray([1., 2., 3.], dtype=float16)\n\n\n- dtype은 아래와 같은 방법으로 변환할 수 있다.\n\na = np.array([1,2,3])\na\n\narray([1, 2, 3])\n\n\n\na.dtype\n\ndtype('int64')\n\n\n\nb = a.astype(np.float64)\n\n\na, b\n\n(array([1, 2, 3]), array([1., 2., 3.]))\n\n\n- 문자열이 넘파이의 원소로 있는 경우\n\na = np.array(['a','b','c'])\na\n\narray(['a', 'b', 'c'], dtype='&lt;U1')\n\n\n\na = np.array(['aa','b','c'])\na\n\narray(['aa', 'b', 'c'], dtype='&lt;U2')\n\n\n\na = np.array(['aaaa','b','c'])\na\n\narray(['aaaa', 'b', 'c'], dtype='&lt;U4')\n\n\n- 문자열+숫자의혼합 -&gt; 각 원소의 자료형이 문자열로 통일됨\n\na = np.array([['Korea', 89],['Japan', 55]])\na\n\narray([['Korea', '89'],\n       ['Japan', '55']], dtype='&lt;U21')\n\n\n\na[0,1] # 이것이 string으로 저장되어있다.\n\n'89'\n\n\n\na[:,[1]].astype(np.int64)\n\narray([[89],\n       [55]])"
  },
  {
    "objectID": "posts/07wk-2.html#j.-브로드캐스팅과-시간측정",
    "href": "posts/07wk-2.html#j.-브로드캐스팅과-시간측정",
    "title": "07wk-2: numpy (2)",
    "section": "J. 브로드캐스팅과 시간측정",
    "text": "J. 브로드캐스팅과 시간측정\n(예비학습)\n\nimport time \n\n\nt1 = time.time()\n\n\nt2 = time.time()\n\n\nt2 - t1 \n\n0.23241567611694336\n\n\n예비학습 끝\n# 예제 – x=[0,1,2,3,4] 인 벡터가 있다고 가정하자. \\((i,j)\\)-th 원소가 (x[i]-x[j])**2을 의미하는 (5,5) matrix를 구하라.\n(풀이1) – 이건 이해하기 쉬움\n\nx = np.array([0,1,2,3,4])\nx\n\narray([0, 1, 2, 3, 4])\n\n\n\ndist2 = np.zeros([5,5])\ndist2\n\narray([[0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.]])\n\n\n\nfor i in range(5):\n    for j in range(5):\n        dist2[i,j] = (x[i]-x[j])**2 \n\n\ndist2\n\narray([[ 0.,  1.,  4.,  9., 16.],\n       [ 1.,  0.,  1.,  4.,  9.],\n       [ 4.,  1.,  0.,  1.,  4.],\n       [ 9.,  4.,  1.,  0.,  1.],\n       [16.,  9.,  4.,  1.,  0.]])\n\n\n(풀이2) – 이건 좀 이해하기 어려움\n\nx1 = x.reshape(5,1)\nx2 = x.reshape(1,5)\n\n\nx1 # (5,1)\nx2 # (1,5) \nx1-x2 \n\narray([[ 0, -1, -2, -3, -4],\n       [ 1,  0, -1, -2, -3],\n       [ 2,  1,  0, -1, -2],\n       [ 3,  2,  1,  0, -1],\n       [ 4,  3,  2,  1,  0]])\n\n\n\n이 매트릭스의 (i,j)-th 원소는 x[i]-x[j]를 의미함\n\n따라서 우리가 원하는 것은 아래와 같이 구할 수 있다.\n\n(x1-x2)**2\n\narray([[ 0,  1,  4,  9, 16],\n       [ 1,  0,  1,  4,  9],\n       [ 4,  1,  0,  1,  4],\n       [ 9,  4,  1,  0,  1],\n       [16,  9,  4,  1,  0]])\n\n\n\n\nn = 10000\ny = np.random.rand(n)\ndist2 = np.zeros([n,n]) \nt1 = time.time()\nfor i in range(n):\n    for j in range(n):\n        dist2[i,j] = (y[i]-y[j])**2 \nt2 = time.time()\nt2-t1\n\n35.770061016082764\n\n\n\nt1 = time.time()\n(y.reshape(n,1) - y.reshape(1,n))**2\nt2 = time.time()\nt2-t1 \n\n0.12731027603149414"
  },
  {
    "objectID": "posts/07wk-2.html#a.-이미지자료의-이해",
    "href": "posts/07wk-2.html#a.-이미지자료의-이해",
    "title": "07wk-2: numpy (2)",
    "section": "A. 이미지자료의 이해",
    "text": "A. 이미지자료의 이해\n- plt.imshow(...) 에서 ...의 shape이 (??,??) 이러한 형태라면 흑백이미지를 출력\n\nplt.imshow([[0,150],[0,255]],cmap='gray')\nplt.colorbar()\n\n\n\n\n\n\n\n\n- plt.imshow(...) 에서 ...의 shape이 (??,??,3) 이러한 형태라면 칼라이미지를 출력\n\nr = [[0,255],[0,255]] # (2,2)\ng = [[255,0],[0,0]] # (2,2)\nb = [[0,0],[255,0]] # (2,2) \nplt.imshow(np.stack([r,g,b],axis=-1))\n\n\n\n\n\n\n\n\n- plt.imshow(...) 에서 ...의 dtype이 int인지 float인지에 따라서 인식이 다름\n\nr = [[0,1],[0,1]] # (2,2)\ng = [[1,0],[0,0]] # (2,2)\nb = [[0,0],[1,0]] # (2,2) \nplt.imshow(np.stack([r,g,b],axis=-1))\n\n\n\n\n\n\n\n\n\nr = [[0,1],[0,1]] # (2,2)\ng = [[1,0],[0,0]] # (2,2)\nb = [[0,0],[1,0]] # (2,2) \nplt.imshow(np.stack([r,g,b],axis=-1).astype(np.float64))\n\n\n\n\n\n\n\n\n\n이건 마치 1을 255로 생각한 결과\n\n### – 예비학습 끝"
  },
  {
    "objectID": "posts/07wk-2.html#b.-hani",
    "href": "posts/07wk-2.html#b.-hani",
    "title": "07wk-2: numpy (2)",
    "section": "B. hani",
    "text": "B. hani\n\n!wget https://raw.githubusercontent.com/guebin/SC2022/main/hani.jpeg\nhani = np.einsum('ijk-&gt;jik',np.array(PIL.Image.open('hani.jpeg'),dtype=np.int64)/255)\n!rm hani.jpeg\n\n--2024-04-20 14:44:18--  https://raw.githubusercontent.com/guebin/SC2022/main/hani.jpeg\nResolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.111.133, 185.199.108.133, 185.199.109.133, ...\nConnecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.111.133|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 2445959 (2.3M) [image/jpeg]\nSaving to: ‘hani.jpeg’\n\nhani.jpeg           100%[===================&gt;]   2.33M  --.-KB/s    in 0.05s   \n\n2024-04-20 14:44:18 (51.6 MB/s) - ‘hani.jpeg’ saved [2445959/2445959]\n\n\n\n\nnote: 위 코드는 코랩 혹은 리눅스기반 환경에서 동작가능.\n\n불러온 이미지는 아래와 같다.\n\nhani,hani.shape\n\n(array([[[0.44705882, 0.48627451, 0.49411765],\n         [0.43137255, 0.46666667, 0.48627451],\n         [0.45882353, 0.50196078, 0.5254902 ],\n         ...,\n         [0.6627451 , 0.6627451 , 0.70196078],\n         [0.63529412, 0.62745098, 0.67058824],\n         [0.64313725, 0.63529412, 0.67843137]],\n \n        [[0.45882353, 0.49803922, 0.50588235],\n         [0.44313725, 0.48235294, 0.49019608],\n         [0.4627451 , 0.50588235, 0.52156863],\n         ...,\n         [0.63921569, 0.63921569, 0.67843137],\n         [0.64313725, 0.63529412, 0.67843137],\n         [0.63137255, 0.62352941, 0.66666667]],\n \n        [[0.45490196, 0.49411765, 0.50196078],\n         [0.4627451 , 0.49803922, 0.51764706],\n         [0.45882353, 0.50196078, 0.5254902 ],\n         ...,\n         [0.64313725, 0.64313725, 0.68235294],\n         [0.65490196, 0.65490196, 0.69411765],\n         [0.64313725, 0.64313725, 0.68235294]],\n \n        ...,\n \n        [[0.69411765, 0.69803922, 0.70588235],\n         [0.68627451, 0.69019608, 0.69803922],\n         [0.69411765, 0.69803922, 0.70588235],\n         ...,\n         [0.60784314, 0.6       , 0.60392157],\n         [0.6       , 0.59215686, 0.59607843],\n         [0.59607843, 0.58823529, 0.59215686]],\n \n        [[0.70196078, 0.70588235, 0.71372549],\n         [0.72156863, 0.7254902 , 0.73333333],\n         [0.69019608, 0.69411765, 0.70196078],\n         ...,\n         [0.61176471, 0.60392157, 0.60784314],\n         [0.60392157, 0.59607843, 0.6       ],\n         [0.61568627, 0.60784314, 0.61176471]],\n \n        [[0.7254902 , 0.72941176, 0.7372549 ],\n         [0.73333333, 0.7372549 , 0.74509804],\n         [0.70980392, 0.71372549, 0.72156863],\n         ...,\n         [0.61176471, 0.60392157, 0.60784314],\n         [0.60392157, 0.59607843, 0.6       ],\n         [0.61960784, 0.61176471, 0.61568627]]]),\n (4032, 3024, 3))\n\n\n\n이미지는 4032 \\(\\times\\) 3024 개의 격자(픽셀)로 이루어져 있음\n\n이미지를 보는 방법은 아래와 같다.\n\nplt.imshow(hani) # 모든이미지, 하니매트릭스\n\n\n\n\n\n\n\n\n\nplt.imshow(hani[1000:1500, 1000:2000,:]) # 얼굴만 확대, 하니의 서브매트릭스 \n\n\n\n\n\n\n\n\n(1) 하니이미지를 나타내는 어레이를 변형하여 빨간색을 의미하는 칼라만 남겨서 “빨간하니”를 만들고 이미지를 출력하라.\n(풀이1) – 제가 원래 하려고 했던 풀이\n\nplt.imshow(np.stack([hani[:,:,0], hani[:,:,0]*0, hani[:,:,0]*0],axis=-1))\n\n\n\n\n\n\n\n\n(풀이2) – GPT이용하여 얻은 힌트\n\n# hani[:,:,1].fill(0)\n# hani[:,:,2].fill(0)\n\n\n# plt.imshow(hani)\n\n(2) 하니의 모든 값에 루트를 취하여 “루트하니”를 만들고 “원본하니”와 “루트하니”를 좌우로 나란히 배치하여 출력하라.\n(풀이)\n\nroot_hani = np.sqrt(hani) \n\n\nplt.imshow(np.concatenate([hani,root_hani],axis=1))\n\n\n\n\n\n\n\n\n(3) 하니의 모든값에 아래와 같은 함수를 적용하라.\n\n\\(f(x)=\\begin{cases} \\sqrt{x} & x&gt;0.75 \\\\ x & x \\leq 0.75 \\end{cases}\\)\n\n함수의 결과로 얻어진 매트릭스를 “후광하니”라고 부르자. “원본하니”와 “후광하니”를 좌우로 나란히 배치하여 출력하라.\n(풀이)\n\nshining_hani = np.where(hani&gt;0.75, np.sqrt(hani), hani)\n\n\nplt.imshow(np.concatenate([hani,shining_hani],axis=1))"
  },
  {
    "objectID": "posts/07wk-2.html#c.-mnist-data",
    "href": "posts/07wk-2.html#c.-mnist-data",
    "title": "07wk-2: numpy (2)",
    "section": "C. MNIST data",
    "text": "C. MNIST data\n아래는 0~9가지의 숫자이미지가 저장된 이미지데이터를 불러오는 코드이다.\n\n# URL 설정\nurl = 'https://github.com/guebin/PP2023/raw/main/posts/02_DataScience/mnist.npz'\n\n# URL에서 파일 다운로드\nurllib.request.urlretrieve(url, './mnist.npz')\n\n# 데이터 로드\ndata = np.load('./mnist.npz')\nxtrain, ytrain, xtest, ytest = data['x_train']/255, data['y_train'], data['x_test']/255, data['y_test']\n\n# mnist.npz 삭제\n!rm mnist.npz\n\n\nprint(f'이미지: xtrain -- {xtrain.shape}, xtest -- {xtest.shape}')\nprint(f'라벨: ytrain -- {ytrain.shape}, ytest -- {ytest.shape}')\n\n이미지: xtrain -- (60000, 28, 28), xtest -- (10000, 28, 28)\n라벨: ytrain -- (60000,), ytest -- (10000,)\n\n\n아래는 데이터에 대한 설명이다.\n\n전체의 이미지의 수는 70000개이며, 60000개의 이미지 \\({\\tt xtrain}\\)에 10000개의 이미지는 \\({\\tt xtest}\\)에 저장되어 있다.\n이미지에 대한 라벨은 각각 \\({\\tt ytrain}\\)과 \\(\\tt ytest\\)에 저장되어 있다. 따라서 \\(\\tt ytrain\\)에는 60000개의 이미지에 해당하는 라벨이, \\(\\tt ytest\\)에는 10000개의 이미지에 해당하는 라벨이 기록되어 있다.\n\n\nfig, ax = plt.subplots(2,5,figsize=(10,4))\n\nax[0][0].imshow(xtrain[0],cmap='gray'); ax[0][0].set_title(f'label={ytrain[0]}');\nax[0][1].imshow(xtrain[1],cmap='gray'); ax[0][1].set_title(f'label={ytrain[1]}');\nax[0][2].imshow(xtrain[2],cmap='gray'); ax[0][2].set_title(f'label={ytrain[2]}');\nax[0][3].imshow(xtrain[3],cmap='gray'); ax[0][3].set_title(f'label={ytrain[3]}');\nax[0][4].imshow(xtrain[4],cmap='gray'); ax[0][4].set_title(f'label={ytrain[4]}');\n\nax[1][0].imshow(xtrain[5],cmap='gray'); ax[1][0].set_title(f'label={ytrain[5]}');\nax[1][1].imshow(xtrain[6],cmap='gray'); ax[1][1].set_title(f'label={ytrain[6]}');\nax[1][2].imshow(xtrain[7],cmap='gray'); ax[1][2].set_title(f'label={ytrain[7]}');\nax[1][3].imshow(xtrain[8],cmap='gray'); ax[1][3].set_title(f'label={ytrain[8]}');\nax[1][4].imshow(xtrain[9],cmap='gray'); ax[1][4].set_title(f'label={ytrain[9]}');\n\nfig.tight_layout()\n\n\n\n\n\n\n\n\n(1) 70000개의 이미지중 0~9에 해당하는 이미지는 각각 몇장씩 들어있는가?\n(풀이)\n\ny = np.concatenate([ytrain,ytest]).tolist()\n\n\n{s:y.count(s) for s in set(y)}\n\n{0: 6903,\n 1: 7877,\n 2: 6990,\n 3: 7141,\n 4: 6824,\n 5: 6313,\n 6: 6876,\n 7: 7293,\n 8: 6825,\n 9: 6958}\n\n\n(2) \\({\\tt xtrain}\\)에서 손글씨 0을 의미하는 이미지만을 모아서 새로운 다차원 array \\({\\tt xtrain0}\\)를 만들어라. 이 다차원 array 에서 처음과 마지막 이미지를 출력하라.\nhint: \\({\\tt xtrain0}\\) 의 shape은 (5923,28,28)이어야 한다.\n(풀이)\n\nxtrain0 = xtrain[ytrain == 0] # 숫자0이 라벨로 기록된 이미지들 \n\n\nplt.imshow(xtrain0[0],cmap=\"gray\")\n\n\n\n\n\n\n\n\n\nplt.imshow(xtrain0[-1],cmap=\"gray\")\n\n\n\n\n\n\n\n\n(3) \\({\\tt xtrain}\\)에서 손글씨 0을 의미하는 이미지들의 평균을 계산하라. 즉 아래를 계산하라.\n\n\\({\\tt xtrain0mean} = \\frac{1}{5923}\\sum_{i=1}^{5923} {\\tt xtrain0[i, :, :]}\\)\n\n계산결과를 출력하라.\n(풀이)\n첫번째 이미지 (왼쪽) 두번째 이미지 (가운데) 와 처음 두개의 이미지의 평균 (오른쪽) 은 아래와 같이 나타낼 수 있다.\n\nfig,ax = plt.subplots(1,3)\nax[0].imshow(xtrain0[0],cmap=\"gray\")\nax[1].imshow(xtrain0[1],cmap=\"gray\")\n#ax[2].imshow((xtrain0[0]+xtrain0[1])/2,cmap=\"gray\")\nax[2].imshow(xtrain0[[0,1]].mean(axis=0),cmap=\"gray\")\n\n\n\n\n\n\n\n\n전체이미지의 평균은 아래와 같다.\n\nplt.imshow(xtrain0.mean(axis=0),cmap='gray')\n\n\n\n\n\n\n\n\n(4) \\({\\tt xtrain}\\)에서 각 라벨에 대한 평균이미지를 계산하고 계산결과를 \\({\\tt imgmean}\\)에 길이가 10인 list로 저장하라. 즉 \\({\\tt imgmean}\\)은 아래와 같은 자료구조를 가지고 있어야 한다.\n\n\\({\\tt imgmean}=\\big[{\\tt imgmean[0]},\\dots, {\\tt imgmean[9]}\\big]\\)\n\\({\\tt imgmean[0]}, \\dots, {\\tt imgmean[9]}\\) 는 각각 (28,28)의 shape을 가진 numpy array\n\\({\\tt imgmean[0]}, \\dots, {\\tt imgmean[9]}\\) 는 각각 숫자 0,1, …, 9의 평균이미지를 의미\n\n\\({\\tt imgmean[0]},\\dots, {\\tt imgmean[9]}\\)를 시각화 하라.\n(풀이)\n\nimgmean = [xtrain[ytrain == i].mean(axis=0) for i in range(10)]\n\n\nfig, ax = plt.subplots(2,5,figsize=(10,4))\n\nax[0][0].imshow(imgmean[0],cmap='gray')\nax[0][1].imshow(imgmean[1],cmap='gray')\nax[0][2].imshow(imgmean[2],cmap='gray')\nax[0][3].imshow(imgmean[3],cmap='gray')\nax[0][4].imshow(imgmean[4],cmap='gray')\n\nax[1][0].imshow(imgmean[5],cmap='gray')\nax[1][1].imshow(imgmean[6],cmap='gray')\nax[1][2].imshow(imgmean[7],cmap='gray')\nax[1][3].imshow(imgmean[8],cmap='gray')\nax[1][4].imshow(imgmean[9],cmap='gray')\n\nfig.tight_layout()\n\n\n\n\n\n\n\n\n(5) \\({\\tt xtrain}\\)의 두번째 이미지와 \\({\\tt imgmean[0]}\\)의 차이를 제곱한 값의 평균을 구하라. 즉 아래를 계산하라.\n\n\\(mean\\Big(({\\tt xtrain[1]}-{\\tt imgmean[0]})^2\\Big)\\)\n\n(풀이)\n\nfig, ax = plt.subplots(1,3)\nax[0].imshow(xtrain[1],cmap=\"gray\")\nax[1].imshow(imgmean[0],cmap=\"gray\")\nax[2].imshow((xtrain[1]-imgmean[0])**2,cmap=\"gray\")\n\n\n\n\n\n\n\n\n\n((xtrain[1]-imgmean[0])**2).mean()\n\n0.03537037336385432\n\n\n(6) 모든 \\(j=0,1,\\dots,9\\) 에 대하여 아래를 계산하라.\n\n\\(mean\\Big(({\\tt xtrain[1]}-{\\tt imgmean[j]})^2\\Big)\\)\n\n계산값이 가장 작게 나오는 \\(j\\)는 얼마인가? 위의 계산결과를 토대로 \\({\\tt xtrain}\\)의 두번째 이미지는 어떠한 숫자를 의미한다고 “분류”하는 것이 타당한가?\n(풀이)\n\n{j:((xtrain[1]-imgmean[j])**2).mean() for j in range(10)}\n\n{0: 0.03537037336385432,\n 1: 0.11495388576147866,\n 2: 0.09465585697275321,\n 3: 0.09057822103883667,\n 4: 0.10401706236099066,\n 5: 0.07100192423576142,\n 6: 0.09006332783104219,\n 7: 0.09943866938812378,\n 8: 0.09098879425485074,\n 9: 0.09820108036961576}\n\n\n((xtrain[1]-imgmean[j])**2).mean() 를 가장 작게만드는 j는 0 이다.\n\nfig, ax = plt.subplots(10,3,figsize=(7.5,30))\nfor j in range(10):\n    ax[j][0].imshow(xtrain[1],cmap=\"gray\"); \n    ax[j][0].set_title(\"xtrain[1]\")\n    ax[j][1].imshow(imgmean[j],cmap=\"gray\")\n    ax[j][1].set_title(f\"imgmean[{j}]\")\n    ax[j][2].imshow((xtrain[1]-imgmean[j])**2,cmap=\"gray\")\n    ax[j][2].set_title(f'loss = {((xtrain[1]-imgmean[j])**2).mean():.4f}')\nfig.tight_layout()\n\n\n\n\n\n\n\n\nxtrain[1] 이미지는 0으로 분류하는게 타당해보인다.\n(7) 아래와 같은 numpy array 를 생성하라.\n\\[{\\tt loss}=\n\\begin{bmatrix}\n{\\tt loss[0,0]} & \\dots & {\\tt loss[0,9]} \\\\\n{\\tt loss[1,0]} & \\dots & {\\tt loss[1,9]} \\\\\n\\dots & \\dots &  \\dots \\\\\n{\\tt loss[59999,0]}& \\dots &{\\tt loss[59999,9]} \\\\\n\\end{bmatrix}\\]\n단, \\({\\tt loss[i,j]} = mean\\Big(({\\tt xtrain[i]}-{\\tt imgmean[j]})^2\\Big)\\)\n위에서 생성한 \\({\\tt loss}\\)를 이용해 (6)와 같은 방식으로 \\({\\tt xtrain}\\)의 모든 이미지에 대한 분류를 수행하라.\nhint: \\({\\tt loss}\\)에서 “최소값을 가지는 원소의 인덱스를 출력”하는 함수를 각 행별로 적용하면 된다.\n(풀이)\n\nloss = np.array([[np.mean((xtrain[i] - imgmean[j])**2) for j in range(10)] for i in range(60000)])\nloss\n\narray([[0.08436263, 0.08777293, 0.08016276, ..., 0.07754168, 0.06951451,\n        0.07958829],\n       [0.03537037, 0.11495389, 0.09465586, ..., 0.09943867, 0.09098879,\n        0.09820108],\n       [0.10793399, 0.09755518, 0.08827192, ..., 0.08612435, 0.09451805,\n        0.0769925 ],\n       ...,\n       [0.09429922, 0.08422548, 0.09809041, ..., 0.07034968, 0.06364432,\n        0.06299717],\n       [0.06883611, 0.07933228, 0.0698403 , ..., 0.07655916, 0.08341635,\n        0.07272038],\n       [0.08297837, 0.0728127 , 0.06969071, ..., 0.07119765, 0.05851329,\n        0.06540166]])\n\n\n\nloss.argmin(axis=-1) # 꽤 그럴듯하게 예측하고 있음\n\narray([5, 0, 4, ..., 5, 6, 8])\n\n\n(8) (7)에서 수행한 분류결과와 실제 라벨 \\({\\tt ytrain}\\)을 비교하라. 얼마나 많은 결과가 일치하는지 비율을 계산하라.\n(풀이)\n\nsum(ytrain == loss.argmin(axis=-1)) / 60000\n\n0.8079833333333334\n\n\n\n(ytrain == loss.argmin(axis=-1)).mean()\n\n0.8079833333333334\n\n\n(9) \\({\\tt xtrain}\\)에서 학습한 평균이미지 \\({\\tt imgmean}\\)를 바탕으로 \\({\\tt xtest}\\)의 이미지를 분류하라. 분류결과를 \\({\\tt ytest}\\)와 비교하라. 얼마나 많은 결과가 일치하는지 비율을 계산하라.\n(풀이)\n\nloss = np.array([[np.mean((xtest[i] - imgmean[j])**2) for j in range(10)] for i in range(10000)])\n(loss.argmin(axis=-1) == ytest).mean()\n\n0.8203\n\n\n(10) (9)의 과정에서 잘못분류된 이미지 10개를 선택하여 시각화 하라.\n\n실제 라벨과 잘못된 라벨을 구분하여 시각화 할 것\n\n\nnp.sum(loss.argmin(axis=-1) != ytest) # 잘못분류된것\n\n1797\n\n\n\nimg = xtest[loss.argmin(axis=-1) != ytest] # 잘못분류된 이미지\nlabel = ytest[loss.argmin(axis=-1) != ytest] # 잘못분류된 이미지의 실제라벨\nestimated = loss.argmin(axis=-1)[loss.argmin(axis=-1) != ytest] # 잘못분류된 이미지의 예측된라벨\n\n\nfig,ax = plt.subplots(2,5,figsize=(10,4))\nfor i in range(2):\n    for j in range(5):      \n        ax[i][j].imshow(img[i*5+j],cmap='gray')\n        ax[i][j].set_title(f\"{label[0]} / {estimated[0]}\")\nfig.tight_layout()"
  },
  {
    "objectID": "posts/03wk-2.html#a.-벡터화연산브로드캐스팅-불가능",
    "href": "posts/03wk-2.html#a.-벡터화연산브로드캐스팅-불가능",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "A. 벡터화연산(브로드캐스팅) 불가능",
    "text": "A. 벡터화연산(브로드캐스팅) 불가능\n- 벡터화연산 불가능 (최악의 단점)\n\nlst = [1,2,3]\nlst + 1\n\nTypeError: can only concatenate list (not \"int\") to list\n\n\n\narr = np.array([1,2,3])\narr + 1\n\narray([2, 3, 4])"
  },
  {
    "objectID": "posts/03wk-2.html#b.-bool을-이용한-인덱싱이-불가능",
    "href": "posts/03wk-2.html#b.-bool을-이용한-인덱싱이-불가능",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "B. bool을 이용한 인덱싱이 불가능",
    "text": "B. bool을 이용한 인덱싱이 불가능\n- True, False 가 포함된 array를 이용한 인덱싱이 불가능하다.\n- 넘파이에서 bool을 이용한 인덱싱\n\narr = np.array([1,2,3,4,5])\narr[arr&gt;3]\n\narray([4, 5])\n\n\n- 리스트는 불가능\n\nlst = [1,2,3,4,5]\nlst[lst&gt;3]\n\nTypeError: '&gt;' not supported between instances of 'list' and 'int'\n\n\n\nlst&gt;3\n\nTypeError: '&gt;' not supported between instances of 'list' and 'int'"
  },
  {
    "objectID": "posts/03wk-2.html#c.-넘파이-특화-메소드-사용불가능",
    "href": "posts/03wk-2.html#c.-넘파이-특화-메소드-사용불가능",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "C. 넘파이 특화 메소드 사용불가능",
    "text": "C. 넘파이 특화 메소드 사용불가능\n- 넘파이 특화 메소드\n\narr = np.array([5,4,3,2,1])\narr\n\narray([5, 4, 3, 2, 1])\n\n\n\narr.min(), arr.max(), arr.mean(), arr.argmin(), arr.argmax()\n\n(1, 5, 3.0, 4, 0)\n\n\n\narr.sort()\narr\n\narray([1, 2, 3, 4, 5])\n\n\n- 리스트는?\n\nlst = [5,4,3,2,1]\nlst\n\n[5, 4, 3, 2, 1]\n\n\n\nlst.min(), lst.max(), lst.mean(), lst.argmin(), lst.argmax()\n\nAttributeError: 'list' object has no attribute 'min'\n\n\n\nlst.sort()\nlst\n\n[1, 2, 3, 4, 5]\n\n\n# 메소드란? – 자료형에 종속된 특수기술\n\n# 넘파이 특수기술\narr = np.array([1,2,3])\narr.max() # max(arr)로 해석\n\n3\n\n\n\n# ?.max() 이런건 넘파이 특수기술 이니까 ?자리에 리스트일 경우는 실행안됨\nlst = [1,2,3]\nlst.max() \n\nAttributeError: 'list' object has no attribute 'max'\n\n\n\n# 리스트의 특수기술 \nlst = [1,2,3]\nlst.append(4) # append(lst,4) 로 해석\nlst\n\n[1, 2, 3, 4]\n\n\n\n# 문자열 특수기술\ns = 'asdf'\ns.capitalize() # capitalize(s) 로 해석\n\n'Asdf'\n\n\n\n# 문자열 특수기술\ns = '-'\nlst = ['x','y','z']\ns.join(lst) # join(s,lst) 로 해석\n\n'x-y-z'\n\n\n\njoin(s,lst)의 뜻: lst의 각 원소를 모두 “이어서” 하나의 문자열로 만들어라. 단, 원소간의 구분은 s에 저장된 문자열로 하라.\n\n\n# 문자열 특수기술 응용\n''.join(['x','y','z'])\n\n'xyz'\n\n\n\n# 문자열 특수기능 \ns = \"제 이름은 {} 입니다.\" \nname = \"최규빈\"\ns.format(name) # format(s,name)\n\n'제 이름은 최규빈 입니다.'\n\n\n\nformat(s,name)의 뜻: s라는 문자열의 포맷에 {} 자리에 name을 끼워넣어라."
  },
  {
    "objectID": "posts/03wk-2.html#d.-파이썬에서-쓰레기-같은-자료형은-없다.",
    "href": "posts/03wk-2.html#d.-파이썬에서-쓰레기-같은-자료형은-없다.",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "D. 파이썬에서 쓰레기 같은 자료형은 없다.",
    "text": "D. 파이썬에서 쓰레기 같은 자료형은 없다.\n- 파이썬에는 각 자료형마다 사용할 수 있는 고유기술(=메소드)이나 문법이 있음.\n- 내가 생각할 때 리스트는 필요없는 자료형이야 = 난 리스트만 가지고 있는 어떠한 고유특징을 활용하지 못해.\n- 파이썬을 잘 하려면 자료형에 따른 고유 특징을 이해하고 활용할 줄 알아야 한다.\n\n기본자료형: str, list, tuple, dict, set – 이러한 자료형을 이해하고 기능을 활용해야함\n모듈: 넘파이배열, 판다스"
  },
  {
    "objectID": "posts/03wk-2.html#a.-문제파악",
    "href": "posts/03wk-2.html#a.-문제파악",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "A. 문제파악",
    "text": "A. 문제파악\n\n- 기존의 문제들과 다르게 numpy를 이용하여 풀기는 어려울 것 같다. 뭔가 기존문제들과 결이 다름\n- 그런데 코딩으로 해결가능할 것 같긴 함"
  },
  {
    "objectID": "posts/03wk-2.html#b.-슈도알고리즘",
    "href": "posts/03wk-2.html#b.-슈도알고리즘",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "B. 슈도알고리즘",
    "text": "B. 슈도알고리즘\n1. 편의상 \\([x,x,y,y,z]\\)를 \\([x_1,x_2,y_1,y_2,z]\\)와 같이 생각하고 나열한다. (5! = 120 개만큼 경우가 나열되겠지)\n2. 중복을 제거한다. 즉 아래는 모두 같은 경우로 생각한다.\n\n\\([x_1,x_2,y_1,y_2,z]\\)\n\\([x_1,x_2,y_2,y_1,z]\\)\n\\([x_2,x_1,y_1,y_2,z]\\)\n\\([x_2,x_1,y_2,y_1,z]\\)"
  },
  {
    "objectID": "posts/03wk-2.html#c.-예비학습",
    "href": "posts/03wk-2.html#c.-예비학습",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "C. 예비학습",
    "text": "C. 예비학습\n# 개념1 – 집합이라는 자료형이 있음.\n\na = {1,2,3}\ntype(a)\n\nset\n\n\n그런데 집합은 중복된 원소를 포함하지 않았음 (중학교때 배운듯)\n\na = {1,2,3,3,3}\na\n\n{1, 2, 3}\n\n\n#\n# 개념2 – 자료형변환을 이용하여 중복된 원소를 제거\n아래와 같은 자료형이 있다고 하자.\n\nlst = [1,2,3,3,3] \nlst\n\n[1, 2, 3, 3, 3]\n\n\n중복된 것을 제외하고 싶다면?\n\nlist(set(lst)) # 자료형변환\n\n[1, 2, 3]\n\n\n#\n# 개념3 – 고유의 원소 숫자 세기\n\nlst = [1,2,3,3,3,4,4,5,5,6] \nlst\n\n[1, 2, 3, 3, 3, 4, 4, 5, 5, 6]\n\n\n\nlen(set(lst))\n\n6\n\n\n#\n# 개념4 – for문\n아래를 출력하고 싶다고 하자.\n이효리는 핑클의 멤버이다. \n옥주현은 핑클의 멤버이다.\n성유리는 핑클의 멤버이다. \n이진은 핑클의 멤버이다. \n(풀이1) – 단순한 풀이\n\nprint(\"이효리는 핑클의 멤버이다.\")\nprint(\"옥주현은 핑클의 멤버이다.\")\nprint(\"성유리는 핑클의 멤버이다.\")\nprint(\"이진은 핑클의 멤버이다.\")\n\n이효리는 핑클의 멤버이다.\n옥주현은 핑클의 멤버이다.\n성유리는 핑클의 멤버이다.\n이진은 핑클의 멤버이다.\n\n\n(풀이2) – 문자열 특수기능을 이용해볼까?\n“{} 핑클의 멤버이다.” 이 공통포맷이므로, 아래와 같이 수행할 수 있겠다.\n\nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\ni = 0\nprint(\"{} 핑클의 멤버이다.\".format(lst[i]))\ni = 1 \nprint(\"{} 핑클의 멤버이다.\".format(lst[i]))\ni = 2 \nprint(\"{} 핑클의 멤버이다.\".format(lst[i]))\ni = 3 \nprint(\"{} 핑클의 멤버이다.\".format(lst[i]))\n\n이효리는 핑클의 멤버이다.\n옥주현은 핑클의 멤버이다.\n성유리는 핑클의 멤버이다.\n이진은 핑클의 멤버이다.\n\n\n(풀이3) - for와 문자열 특수기능을 이용해볼까?\n\nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\nfor i in [0,1,2,3]:\n    print(\"{} 핑클의 멤버이다.\".format(lst[i]))\n\n이효리는 핑클의 멤버이다.\n옥주현은 핑클의 멤버이다.\n성유리는 핑클의 멤버이다.\n이진은 핑클의 멤버이다.\n\n\n(풀이4) - for와 문자열 특수기능을 이용해볼까? (2)\n[0,1,2,3]은 대충 range(4)와 비슷한 것이므로 아래와 같이 수행할 수도 있겠음.\n\nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\nfor i in range(4):\n    print(\"{} 핑클의 멤버이다.\".format(lst[i]))\n\n이효리는 핑클의 멤버이다.\n옥주현은 핑클의 멤버이다.\n성유리는 핑클의 멤버이다.\n이진은 핑클의 멤버이다.\n\n\n(풀이5) - for와 문자열 특수기능을 이용해볼까? (3)\n아래의 코드는 \\(i\\) 자리에 [0,1,2,3]의 원소가 번갈아 대입되며 ??????가 수행되었음.\nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\nfor i in [0,1,2,3]:\n    ??????\n아래의 코드도 \\(i\\) 자리에 range(4)의 원소가 번갈아 대입되며 ??????가 수행되었다고 해석가능.\nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\nfor i in range(4):\n    ??????\n아래의 코드는 어떻게 실행될까??\nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\nfor i in lst:\n    ??????\n\n# R과 다른 방식으로 동작하는 for문 \nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\nfor l in lst:\n    print(\"{} 핑클의 멤버이다.\".format(l))\n\n이효리는 핑클의 멤버이다.\n옥주현은 핑클의 멤버이다.\n성유리는 핑클의 멤버이다.\n이진은 핑클의 멤버이다.\n\n\n#\n# 개념5 – for문을 이용하여 리스트의 원소 추가하기\n\nlst2 = [] # lst2 = list() 와 같은결과임\nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\nfor l in lst: \n    lst2.append(\"{} 핑클의 멤버이다.\".format(l))\n\n\nlst2\n\n['이효리는 핑클의 멤버이다.', '옥주현은 핑클의 멤버이다.', '성유리는 핑클의 멤버이다.', '이진은 핑클의 멤버이다.']\n\n\n그런데 이걸 아래와 같이 해결할 수도 있다.\n\nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\n[\"{} 핑클의 멤버이다.\".format(l) for l in lst] # 리스트컴프리헨션 \n\n['이효리는 핑클의 멤버이다.', '옥주현은 핑클의 멤버이다.', '성유리는 핑클의 멤버이다.', '이진은 핑클의 멤버이다.']\n\n\n#\n# 개념6 – 리스트컴프리헨션\n집합을 표현하는 방법에는 원소나열법과 조건제시법이 있다.\n\n원소나열법: \\(\\{2^0,2^1,2^2,2^3\\}\\)\n조건제시법: \\(\\{2^i: \\text{ for } i=0,1,2,3\\}\\)\n\n이중에서 조건제시법은 아래와 같이 표현할 수 있음.\n\n\\(\\{2^i: \\text{ for } i \\in \\{0,1,2,3\\}\\}\\)\n\n여기에서 \\(\\in\\) 은 in 으로 읽으므로, 위의 표기법을 연상하여 파이썬 코드로 바꿔보면\n[2^i: for i in [0,1,2,3]]\n와 같은 방식으로 리스트의 원소를 표현할 수 있을 것 같다. 위의 코드는 실행되지 않지만 아래의 코드는 실행가능하다.\n\n[2**i for i in [0,1,2,3]]\n\n[1, 2, 4, 8]\n\n\n\n[2**i for i in range(4)]\n\n[1, 2, 4, 8]\n\n\n이를 응용하면\n\n[\"asdf{}\".format(2**i) for i in range(4)]\n\n['asdf1', 'asdf2', 'asdf4', 'asdf8']\n\n\n이것을 다시 응용하면\n\nlst = [\"이효리는\", \"성유리는\", \"옥주현은\", \"이진은\"]\n[\"{} 핑클의 멤버이다.\".format(l) for l in lst]\n\n['이효리는 핑클의 멤버이다.', '성유리는 핑클의 멤버이다.', '옥주현은 핑클의 멤버이다.', '이진은 핑클의 멤버이다.']\n\n\n#\n# 개념7 – 스트링의 인덱싱 (파이썬에서는 스트링을 array로 취급)\n\ns = 'asdf'\ns\n\n'asdf'\n\n\n\ns[0]\n\n'a'\n\n\n\ns[-1]\n\n'f'\n\n\n\ns[:2]\n\n'as'\n\n\n#\n# 개념8 – 스트링과 리스트의 변환\n\ns = 'asdf' \ns\n\n'asdf'\n\n\n\nlst = list(s)\nlst\n\n['a', 's', 'd', 'f']\n\n\n\n''.join(lst)\n\n'asdf'\n\n\n# 개념9 – 튜플자료형\n\nlst = [1,2,3]\nlst\n\n[1, 2, 3]\n\n\n\ntpl = (1,2,3)\ntpl\n\n(1, 2, 3)\n\n\n튜플은 (의미가 명확할때) 괄호를 생략할 수 있음\n\ntpl = 1,2,3\ntpl\n\n(1, 2, 3)\n\n\n튜플은 리스트와 매우 비슷함.\n\n[1,2,3] + [4,5] \n\n[1, 2, 3, 4, 5]\n\n\n\n(1,2,3) + (4,5)\n\n(1, 2, 3, 4, 5)\n\n\n아래도 가능\n\n''.join(['a','b','c'])\n\n'abc'\n\n\n\n''.join(('a','b','c'))\n\n'abc'\n\n\n#\n# 개념10 – for를 수행하는 다양한 테크닉\n우리가 알고 있는 for: 리스트 비슷한 것을 만든 뒤, 그 리스트의 원소를 하나씩 뽑아가면서 어떠한 반복구문 “??????” 수행하는 것.\n\nimport itertools\n\n\nfor i in itertools.permutations(['a','b','c']):\n    print(i)\n\n('a', 'b', 'c')\n('a', 'c', 'b')\n('b', 'a', 'c')\n('b', 'c', 'a')\n('c', 'a', 'b')\n('c', 'b', 'a')\n\n\n\nfor i in itertools.product(['x','y'],['a','b','c']):\n    print(i)\n\n('x', 'a')\n('x', 'b')\n('x', 'c')\n('y', 'a')\n('y', 'b')\n('y', 'c')\n\n\n#"
  },
  {
    "objectID": "posts/03wk-2.html#d.-풀이",
    "href": "posts/03wk-2.html#d.-풀이",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "D. 풀이",
    "text": "D. 풀이\n아래의 문제를 풀어보자..\n\n(풀이)\n\nlen(set([''.join(i) for i in itertools.permutations(['x','x','y','y','z'])]))\n\n30"
  },
  {
    "objectID": "posts/03wk-2.html#a.-문제이해",
    "href": "posts/03wk-2.html#a.-문제이해",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "A. 문제이해",
    "text": "A. 문제이해"
  },
  {
    "objectID": "posts/03wk-2.html#b.-슈도알고리즘-1",
    "href": "posts/03wk-2.html#b.-슈도알고리즘-1",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "B. 슈도알고리즘",
    "text": "B. 슈도알고리즘\n1. 아래의 경우를 모두 나열한다.\na,b,c,d = 1,1,1,1 \na,b,c,d = 1,1,1,2 \n....\na,b,c,d = 6,6,6,6\n2. 조건 \\(a \\leq c \\leq d\\) 와 \\(b \\leq c \\leq d\\) 를 동시에 만족하는 경우를 센다."
  },
  {
    "objectID": "posts/03wk-2.html#c.-예비학습-1",
    "href": "posts/03wk-2.html#c.-예비학습-1",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "C. 예비학습",
    "text": "C. 예비학습\n# 개념1 – for문과 튜플\n\nlst = [['최규빈',43052,'M'],['아이유',54321,'F'],['하니',11223,'F']]\nlst[0]\n\n['최규빈', 43052, 'M']\n\n\n아래의 코드가 가능하다.\n\nfor [name,student_id,sex] in lst:\n    print([name,student_id,sex])\n# [name,student_id,sex] = ['최규빈', 43052, 'M']\n# print([name,student_id,sex])\n# [name,student_id,sex] = ['아이유', 54321, 'F']\n# print([name,student_id,sex])\n# [name,student_id,sex] = ['하니', 11223, 'F']\n# print([name,student_id,sex])\n\n['최규빈', 43052, 'M']\n['아이유', 54321, 'F']\n['하니', 11223, 'F']\n\n\n리스트를 튜플로 바꾼다면?\n\nfor (name,student_id,sex) in lst:\n    print((name,student_id,sex))\n# (name,student_id,sex) = ['최규빈', 43052, 'M']\n# print((name,student_id,sex))\n# (name,student_id,sex) = ['아이유', 54321, 'F']\n# print((name,student_id,sex))\n# (name,student_id,sex) = ['하니', 11223, 'F']\n# print((name,student_id,sex))\n\n('최규빈', 43052, 'M')\n('아이유', 54321, 'F')\n('하니', 11223, 'F')\n\n\nfor (name,student_id,sex) in lst: 대신에 for name,student_id,sex in lst: 도 가능\n\nfor name,student_id,sex in lst:\n    print((name,student_id,sex))\n# name,student_id,sex = ['최규빈', 43052, 'M']\n# print((name,student_id,sex))\n# name,student_id,sex = ['아이유', 54321, 'F']\n# print((name,student_id,sex))\n# name,student_id,sex = ['하니', 11223, 'F']\n# print((name,student_id,sex))\n\n('최규빈', 43052, 'M')\n('아이유', 54321, 'F')\n('하니', 11223, 'F')\n\n\n아래와 같이 컴프리헨션으로 만들 수도 있음.\n\n[[name,student_id,sex] for name,student_id,sex in lst]\n\n[['최규빈', 43052, 'M'], ['아이유', 54321, 'F'], ['하니', 11223, 'F']]\n\n\n\n[(name,student_id,sex) for name,student_id,sex in lst]\n\n[('최규빈', 43052, 'M'), ('아이유', 54321, 'F'), ('하니', 11223, 'F')]\n\n\n아래는 불가능\n\n[name,student_id,sex for name,student_id,sex in lst]\n\nSyntaxError: did you forget parentheses around the comprehension target? (905514563.py, line 1)\n\n\n하지만 괄호를 명확하게 쓰기만 하면 만들어짐\n\n[(name,sex) for name,student_id,sex in lst]\n\n[('최규빈', 'M'), ('아이유', 'F'), ('하니', 'F')]\n\n\n\n[(sex,name) for name,student_id,sex in lst]\n\n[('M', '최규빈'), ('F', '아이유'), ('F', '하니')]\n\n\n\n[name for name,student_id,sex in lst]\n\n['최규빈', '아이유', '하니']\n\n\n언더스코어(_)를 사용할 수도 있음.\n\n[name for name,_,_ in lst]\n\n['최규빈', '아이유', '하니']\n\n\n언더스코어(_)를 사용시 lst[0], lst[1] 등의 원소숫자와 일치하도록 사용해야함\n\n[name for name,_ in lst] # 이건 또 실행불가능..\n\nValueError: too many values to unpack (expected 2)\n\n\n\n[name for name, *args in lst] # 이건 실행가능\n\n['최규빈', '아이유', '하니']\n\n\n# 개념2 – 조건문\n아래의 리스트 원소 \\(l\\) 중에서 조건 \\(1 &lt; l \\leq 5\\)를 만족하는 원소는 모두 몇개인가?\n\nlst = [1,2,3,4,5,6,7,8,9] \nlst\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n(풀이)\n\nsum([1&lt;l and l&lt;=5 for l in lst])\n\n4\n\n\n\nsum([1&lt;l&lt;=5 for l in lst])\n\n4"
  },
  {
    "objectID": "posts/03wk-2.html#d.-풀이-1",
    "href": "posts/03wk-2.html#d.-풀이-1",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "D. 풀이",
    "text": "D. 풀이\n\n(풀이)\n\nlst = [1,2,3,4,5,6]\nsum([a&lt;=c&lt;=d and b&lt;=c&lt;=d for a,b,c,d in itertools.product(lst,lst,lst,lst)])\n\n196"
  },
  {
    "objectID": "posts/03wk-2.html#a.-문제파악-1",
    "href": "posts/03wk-2.html#a.-문제파악-1",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "A. 문제파악",
    "text": "A. 문제파악"
  },
  {
    "objectID": "posts/03wk-2.html#b.-예비학습",
    "href": "posts/03wk-2.html#b.-예비학습",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "B. 예비학습",
    "text": "B. 예비학습\n- 예제: 제곱수중에서 12로 나누어서 떨어지는 수만 원소르 가지는 리스트를 만들고 싶다.\n\n제곱수: 1,4,9,16,25,36,…\n12로 나누어서 떨어지는 수: 36\n\n(복습1)\n\n12 % 4 # % 는 나머지를 계산하는 연산자, 12를 4로 나누었더니 나머지가 0\n\n0\n\n\n\n12 % 5 # 12 = 5*2 +2 \n\n2\n\n\n(복습2)\n\na = 3 # a에 2를 대입하라...\n\n\na == 2 # a에 들어있는 값이 2이인지 테스트하라..\n\nFalse\n\n\n\na == 3\n\nTrue\n\n\n(풀이1) – 비어있는 리스트를 만들고, for + if 를 사용\n\nlst = []\nfor i in range(1,101):\n    if i**2 % 12 == 0: # i^2을 12로 나누어서 나누어 떨어진다면\n        lst.append(i**2)\n\n\nlst\n\n[36,\n 144,\n 324,\n 576,\n 900,\n 1296,\n 1764,\n 2304,\n 2916,\n 3600,\n 4356,\n 5184,\n 6084,\n 7056,\n 8100,\n 9216]\n\n\n(풀이2) - if문이 포함된 리스트 컴프리헨션\n\n[i**2 for i in range(1,101) if i**2 % 12 ==0] \n\n[36,\n 144,\n 324,\n 576,\n 900,\n 1296,\n 1764,\n 2304,\n 2916,\n 3600,\n 4356,\n 5184,\n 6084,\n 7056,\n 8100,\n 9216]"
  },
  {
    "objectID": "posts/03wk-2.html#c.-풀이",
    "href": "posts/03wk-2.html#c.-풀이",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "C. 풀이",
    "text": "C. 풀이\n\n(풀이)\n\nx = list(range(1,16))\nf = lambda x: np.sin(np.pi/4*x)\nsum([xi for xi in x if f(2+xi)*f(2-xi)&lt;1/4])\n\n32"
  },
  {
    "objectID": "posts/07wk-1.html",
    "href": "posts/07wk-1.html",
    "title": "07wk-1: 퀴즈4",
    "section": "",
    "text": "Caution\n\n\n\n\n전북대 학생들을 시험당일 학생증을 지참할 것. (출석체크 및 본인확인) 학생증 외에 신분증 여권등도 가능.\n부정행위 (카카오톡 채팅을 통한 코드공유, 생성형모델 사용, 대리시험 등) 적발시 F 처리함.\n퀴즈 중 지각할 경우 지각사실을 기록함. 하지만 별 다른 감점은 하지 않음.\n.ipynb 파일 형태로 제출된 답안지만 채점하며 그 외의 형식 (.hwp, .py 등)은 채점하지 않음. 즉 0점 처리함.\n\n\n\n\nimport numpy as np\nimport pandas as pd\n\n\n1. – 10점\n아래는 파이썬프로그래밍 수강생들의 학번, 이름, 출석점수, 과제점수, 중간고사점수, 기말고사점수를 저장한 중첩리스트이다.\n\nlst = [['2021-43052', 'GuebinChoi', 5, 10, 20, 25],\n       ['2019-12342', 'Heung-min Son', 10, 15, 30, 15],\n       ['2018-32234', 'hynn', 7, 20, 30, 15],\n       ['2022-42323', 'Minji', 8, 20, 20, 35],\n       ['2023-55342', 'Hanni', 7, 20, 30, 35],\n       ['2022-46624', 'Danielle', 3, 15, 30, 40],\n       ['2022-11239', 'Haerin', 10, 20, 30, 40],\n       ['2022-32114', 'Hyein', 10, 20, 20, 35]]\nlst \n\n[['2021-43052', 'GuebinChoi', 5, 10, 20, 25],\n ['2019-12342', 'Heung-min Son', 10, 15, 30, 15],\n ['2018-32234', 'hynn', 7, 20, 30, 15],\n ['2022-42323', 'Minji', 8, 20, 20, 35],\n ['2023-55342', 'Hanni', 7, 20, 30, 35],\n ['2022-46624', 'Danielle', 3, 15, 30, 40],\n ['2022-11239', 'Haerin', 10, 20, 30, 40],\n ['2022-32114', 'Hyein', 10, 20, 20, 35]]\n\n\n중간고사와 기말고사의 합이 60점 이상인 학생은 몇명인가? (확장 가능한 코드만 정답으로 인정)\n(풀이)\n\nlen([l for l in lst if sum(l[-2:])&gt;=60])\n\n3\n\n\n\n\n2. – 10점\n아래의 list를 관찰하라.\n\nlst = ['2022/09/21','2022/10/30','2022/12/25','2023/01/01','2023/01/31','2023/03/20']\n\n이를 아래와 같은 리스트로 변환하는 코드를 작성하라. (확장 가능한 코드만 정답으로 인정)\n\n['2022.09.21.','2022.10.30.','2022.12.25.','2023.01.01.','2023.01.31.','2023.03.20.']\n\n['2022.09.21.',\n '2022.10.30.',\n '2022.12.25.',\n '2023.01.01.',\n '2023.01.31.',\n '2023.03.20.']\n\n\n(풀이)\n\n[l.replace('/','.')+'.' for l in lst]\n\n['2022.09.21.',\n '2022.10.30.',\n '2022.12.25.',\n '2023.01.01.',\n '2023.01.31.',\n '2023.03.20.']\n\n\n\n\n3. – 10점\n아래의 문자열을 관찰하라.\n\ntest_arr = 'ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@mylaptop.local'\n\n‘A’ 가 몇개 있는지 count하라\n(풀이)\n\nlist(test_arr).count('A')\n\n18\n\n\n\ntest_arr.count('A')\n\n18\n\n\n\n\n4. – 10점\n\n모두 맞출경우만 정답으로 인정\n\n(1) 아래의 조건을 만족하는 자료형 a를 선언하라.\n\ntype(a), len(a), a[0]\n\n(tuple, 1, 'a')\n\n\n(풀이)\n\na= ('a',)\n\n\ntype(a), len(a), a[0]\n\n(tuple, 1, 'a')\n\n\n(2) 아래와 같은 출력결과를 보이는 numpy array a,b 를 선언하라.\n\na, a.shape\n\n(array(3), ())\n\n\n\nb, b.shape\n\n(array([3]), (1,))\n\n\n(풀이)\n\na = np.array(3)\nb = np.array([3])\n\n\na, a.shape\n\n(array(3), ())\n\n\n\nb, b.shape\n\n(array([3]), (1,))\n\n\n\n\n5. – 20점\n\n모두 맞출경우만 정답으로 인정\n\n아래와 같은 2차원 numpy array를 선언하라.\n\nnp.random.seed(43052)\nX = np.random.randn(20,5).round(2)\nX\n\narray([[ 0.38,  1.08,  1.14,  0.31,  0.24],\n       [ 0.36, -1.66, -1.38, -1.93, -1.49],\n       [ 0.01, -0.03, -0.34,  0.71, -1.55],\n       [ 1.35, -0.06, -0.83, -1.46, -0.35],\n       [-0.34,  0.76,  2.22, -1.72,  1.59],\n       [ 0.37,  0.77, -0.43,  0.77,  0.92],\n       [-0.45,  0.32,  0.82, -0.17,  1.13],\n       [ 0.21, -1.68, -0.3 ,  0.62, -0.3 ],\n       [-0.25, -1.16, -1.29, -0.63, -0.7 ],\n       [ 1.27,  0.84, -1.46, -0.17,  1.29],\n       [ 0.36, -0.1 , -0.83, -0.65,  0.07],\n       [-2.47,  1.39, -0.06, -0.84, -0.38],\n       [ 1.33,  0.17, -0.51, -1.27,  1.74],\n       [-0.36, -0.18,  0.62,  0.45, -0.4 ],\n       [-1.07, -0.18, -1.42, -0.69,  0.74],\n       [ 2.19, -1.15, -0.28, -0.5 , -1.66],\n       [-2.22,  0.42, -0.59,  0.17, -0.01],\n       [-1.83,  0.26, -0.61,  0.14, -0.02],\n       [-0.99,  0.73,  0.37,  0.34,  0.55],\n       [ 1.31,  0.41, -0.19,  1.06,  1.19]])\n\n\n(1) 열별로(column-wise) X의 평균을 계산하라.\n\n# 답: np.array([-0.042 ,  0.0475, -0.2675, -0.273 ,  0.13  ])\n\n(풀이)\n\nX.mean(axis=0)\n\narray([-0.042 ,  0.0475, -0.2675, -0.273 ,  0.13  ])\n\n\n(2) 행별로(row-wise) X의 최대값과 최소값의 차이를 계산하라.\n\n# 답: np.array([0.9 , 2.29, 2.26, 2.81, 3.94, 1.35, 1.58, 2.3 , 1.04, 2.75, 1.19, 3.86, 3.01, 1.02, 2.16, 3.85, 2.64, 2.09, 1.72, 1.5 ])\n\n(풀이)\n\nX.max(axis=1) - X.min(axis=1) \n\narray([0.9 , 2.29, 2.26, 2.81, 3.94, 1.35, 1.58, 2.3 , 1.04, 2.75, 1.19,\n       3.86, 3.01, 1.02, 2.16, 3.85, 2.64, 2.09, 1.72, 1.5 ])\n\n\n\n\n6. – 40점\n\n각 20점\n\n아래의 코드를 실행하여 data를 생성하라.\n\ndata = pd.read_csv('https://raw.githubusercontent.com/guebin/DV2021/master/_notebooks/2021-10-25-FIFA22_official_data.csv').drop(['Loaned From','Marking'],axis=1).dropna().loc[:,['Name','Nationality','Overall']].to_numpy().tolist()\n\ndata는 list로 만들어져 있으며 각 원소는 축구선수들의 능력치를 나타낸다. data의 각 원소는 [이름,소속국가,능력치]를 의미하며 처음 5개의 원소는 아래와 같다.\n\ndata[:5]\n\n[['Bruno Fernandes', 'Portugal', 88],\n ['L. Goretzka', 'Germany', 87],\n ['L. Suárez', 'Uruguay', 88],\n ['K. De Bruyne', 'Belgium', 91],\n ['M. Acuña', 'Argentina', 84]]\n\n\n(1) 아래의 dictionary를 이용하여 data의 국가이름을 대륙이름으로 바꾸라.\n\ncontinent_dict = {\n    'Asia': ['Afghanistan', 'Japan', 'Macau', 'Chinese Taipei', 'Indonesia', 'Korea Republic', 'Kazakhstan', 'Kyrgyzstan', 'Bhutan', 'Philippines', 'Syria', 'China PR', 'Oman', 'Guam', 'Vietnam', 'Jordan', 'Palestine', 'Malaysia', 'Hong Kong', 'Korea DPR', 'Lebanon', 'Uzbekistan', 'India','Iraq', 'Iran', 'Saudi Arabia', 'United Arab Emirates','Australia'],\n    'Europe': ['Portugal', 'Germany', 'Belgium', 'Netherlands', 'Croatia', 'Spain', 'Austria', 'Italy', 'France', 'Serbia', 'England', 'Poland', 'Ukraine', 'Wales', 'Scotland', 'Czech Republic', 'Slovakia', 'Romania', 'Bosnia and Herzegovina', 'Republic of Ireland', 'Norway', 'Sweden', 'Bulgaria', 'Lithuania', 'Estonia', 'Latvia', 'Liechtenstein','Albania','Denmark','Finland','Greece','Hungary','Iceland','Luxembourg','Northern Ireland','Slovenia','Switzerland','Andorra','Azerbaijan','Belarus','Cyprus','Faroe Islands','Georgia','Kosovo','Malta','Moldova','Montenegro','North Macedonia','Armenia','Gibraltar','Russia','Turkey','Israel'],\n    'South America': ['Uruguay', 'Argentina', 'Brazil', 'Chile', 'Colombia', 'Ecuador', 'Paraguay', 'Venezuela', 'Suriname', 'Bolivia','Peru','Guyana'],\n    'Africa': ['Egypt', \"Côte d'Ivoire\", 'Senegal', 'Morocco', 'Ghana', 'Algeria', 'Guinea', 'Mali', 'Congo DR', 'Liberia', 'Cameroon', 'Tunisia', 'Comoros', 'Kenya', 'South Africa', 'Zimbabwe', 'Madagascar', 'Mozambique', 'Equatorial Guinea', 'Congo', 'Burundi', 'Grenada', 'Thailand', 'Togo', 'Sudan', 'Mauritania','Guinea Bissau','Libya','Nigeria','Zambia','Angola','Benin','Burkina Faso','Cape Verde Islands','Central African Republic','Chad','Eritrea','Gabon','Gambia','Mauritius','Namibia','Rwanda','Sierra Leone','South Sudan','São Tomé e Príncipe','Uganda','Niger'],\n    'North and Central America': ['Antigua and Barbuda', 'Barbados', 'Belize', 'Bermuda', 'Canada', 'Costa Rica', 'Cuba', 'Curacao', 'Dominican Republic', 'El Salvador', 'Guatemala', 'Haiti', 'Honduras', 'Jamaica', 'Mexico', 'Montserrat', 'Panama', 'Puerto Rico', 'Saint Kitts and Nevis', 'Saint Lucia', 'Trinidad and Tobago', 'United States'],\n    'Oceania': ['New Zealand', 'Fiji', 'Papua New Guinea','New Caledonia'],\n}\n\n바뀐 data의 처음 5개의 출력결과는 아래와 같다.\n[['Bruno Fernandes', 'Europe', 88],\n ['L. Goretzka', 'Europe', 87],\n ['L. Suárez', 'South America', 88],\n ['K. De Bruyne', 'Europe', 91],\n ['M. Acuña', 'South America', 84]]\n(풀이)\n\ndata2 = [\n    [name,continent,overall] \\\n    for name,nationality,overall in data \\\n    for continent in continent_dict \\\n    if nationality in continent_dict[continent]\n]\ndata2[:5]\n\n[['Bruno Fernandes', 'Europe', 88],\n ['L. Goretzka', 'Europe', 87],\n ['L. Suárez', 'South America', 88],\n ['K. De Bruyne', 'Europe', 91],\n ['M. Acuña', 'South America', 84]]\n\n\n(2) 능력치가 80 보다 큰 선수들은 대륙별로 몇명의 선수가 있는가? count하라.\n\n# 답\n# {'South America': 71,\n#  'Africa': 21,\n#  'North and Central America': 8,\n#  'Europe': 272,\n#  'Asia': 1}\n\n(풀이)\n\nlst = [continent for _,continent,overall in data2 if overall&gt;80]\n\n\n{s:lst.count(s) for s in set(lst)}\n\n{'Africa': 21,\n 'North and Central America': 8,\n 'Europe': 272,\n 'South America': 71,\n 'Asia': 1}"
  },
  {
    "objectID": "posts/05wk-2.html#a.-리스트-vs-튜플",
    "href": "posts/05wk-2.html#a.-리스트-vs-튜플",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "A. 리스트 vs 튜플",
    "text": "A. 리스트 vs 튜플\n- 공통점: (1) 컨테이너형타입이라는 점, 그리고 (2) 연산 및 인덱싱을 하는 방법은 리스트와 같음 - 차이점1: [] 대신에 ()를 사용한다. - 차이점2: 불변형이다. (원소의 값을 바꿀 수 없음) - 차이점3: 하나의 원소를 선언할 때는 (1,)와 같이 해야 한다. - 차이점4: 의미가 명확할때는 튜플의 ()를 생략가능하다.\n- 컨테이너형이라는 것이 무슨의미?\n\na=(4,6,'pencil', 3.2+4.6j, [3,4])\n\n\ntype(a[2])\n\nstr\n\n\n\ntype(a[3])\n\ncomplex\n\n\n- 연산의 유사성\n\n(1,2) + (3,4,5)\n\n(1, 2, 3, 4, 5)\n\n\n\n(1,2) * 2\n\n(1, 2, 1, 2)\n\n\n- 인덱싱의 유사성\n\ntpl = (11,21,31)\ntpl[1:]\n\n(21, 31)\n\n\n- 차이점2: 불변형이라는 것은 무슨의미?\n\na[2] = 'Pencil'\n\nTypeError: 'tuple' object does not support item assignment\n\n\n참고로 a를 튜플이 아니라 리스트로 선언하면 값이 잘 바뀐다.\n\na=[4,6,'pencil', 3.2+4.6j, [3,4]]\n\n\na[2]\n\n'pencil'\n\n\n\na[2]='Pencil'\n\n\na\n\n[4, 6, 'Pencil', (3.2+4.6j), [3, 4]]\n\n\n- 차이점3: 하나의 원소로 이루어진 튜플을 만들때는 쉼표를 붙여야 함.\n\n[1]+[2,3,4]\n\n[1, 2, 3, 4]\n\n\n\n(1,)+(2,3,4)\n\n(1, 2, 3, 4)\n\n\n- 차이점4: 의미가 명확할때 튜플의 괄호는 생략가능하다. (이게 중요합니다)\n\na=1,2\na\n\n(1, 2)\n\n\n의미가 명확할때 생략해야함\n\n1,2 + 3,4,5 \n\n(1, 5, 4, 5)\n\n\n\n(1,2) + (3,4,5) \n\n(1, 2, 3, 4, 5)"
  },
  {
    "objectID": "posts/05wk-2.html#b.-선언",
    "href": "posts/05wk-2.html#b.-선언",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "B. 선언",
    "text": "B. 선언\n- 소괄호를 이용\n\na=(1,2,3)\na\n\n(1, 2, 3)\n\n\n\ntype(a)\n\ntuple\n\n\n- 생략가능하다는 점이 포인트\n\na=1,2,3\na\n\n(1, 2, 3)\n\n\n\ntype(a)\n\ntuple\n\n\n- 원소가 하나인 튜플을 만들고 싶다면?\n\na=(1,)\na\n\n(1,)"
  },
  {
    "objectID": "posts/05wk-2.html#c.-연산",
    "href": "posts/05wk-2.html#c.-연산",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "C. 연산",
    "text": "C. 연산\n- 리스트와 동일\n\n(1,2)+(3,4,5)\n\n(1, 2, 3, 4, 5)\n\n\n\n(1,2)*2\n\n(1, 2, 1, 2)"
  },
  {
    "objectID": "posts/05wk-2.html#d.-인덱싱",
    "href": "posts/05wk-2.html#d.-인덱싱",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "D. 인덱싱",
    "text": "D. 인덱싱\n- 리스트와 동일\n\na=(1,2,3,-4,-5)\na\n\n(1, 2, 3, -4, -5)\n\n\n\na[-1]\n\n-5\n\n\n\na[-3:]\n\n(3, -4, -5)"
  },
  {
    "objectID": "posts/05wk-2.html#e.-슬기로운-튜플사용-star",
    "href": "posts/05wk-2.html#e.-슬기로운-튜플사용-star",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "E. 슬기로운 튜플사용 (\\(\\star\\))",
    "text": "E. 슬기로운 튜플사용 (\\(\\star\\))\n# 예제 – 여러변수를 동시에 출력하고 싶을 경우 (다중출력?)\n변수를 아래와 같이 선언하였다고 하자.\n\na=1\nb=2\nc=3\n\n선언된 값을 확인하려면?\n\na\n\n1\n\n\n\nb\n\n2\n\n\n\nc\n\n3\n\n\n튜플을 이용하면?\n\na,b,c # 괄호하나 생략하는것이 이렇게 편하다..\n\n(1, 2, 3)\n\n\n#\n# 예제2 – 다중할당1 (여러개의 변수를 동시에 선언하고 싶을 경우)\n아래와 같이 =를 5번 쓰면 5개의 변수를 선언할 수 있다.\n\nname = 'Tom'\nage = 20 \nsex = 'M'\nheight = 180\nweight = 70\n\n튜플을 이용하면 좀더 간단히 하나의 = 로도 아래와 같이 선언할 수 있다.\n\nname, age, sex, height, weight = 'Tom', 20, 'M', 180, 70  # 다중할당\n\n#\n# 예제2 – 다중할당2, 위도와 경도\n\ncoor = (37,127) # 서울 \ncoor\n\n(37, 127)\n\n\n\nlat, long = coor # 다중할당\n\n\nlat \n\n37\n\n\n\nlong \n\n127\n\n\n#\n# 잠깐만 – 다중할당은 꼭 튜플에서만 가능한가?\n그건 아니다…\n\n[x,y,z] = [1,2,3] \nx,y,z # 다중출력 \n\n(1, 2, 3)\n\n\n\n[x,y] = 'hi'\nx,y \n\n('h', 'i')\n\n\n튜플과 같이 사용하면 가독성이 극대화 (그래서 다중할당은 거의 튜플과 세트로 사용함)\n\nx,y,z = 1,2,3\nx,y,z # 다중출력 \n\n(1, 2, 3)\n\n\n\nx,y = 'hi'\nx,y \n\n('h', 'i')\n\n\n#\n# 예제 – 임시변수 사용없이 두 변수의 값을 교환\n\na=10\nb=20\n\n\na,b\n\n(10, 20)\n\n\n\na,b = b,a \n\n\na,b\n\n(20, 10)\n\n\n#\n# 예제 – for문과 튜플\n\nlst = [['guebin', 202112345, 'M'],\n       ['iu',202254321, 'F'],\n       ['hodong', 202011223, 'M']]\nlst\n\n[['guebin', 202112345, 'M'],\n ['iu', 202254321, 'F'],\n ['hodong', 202011223, 'M']]\n\n\n\nlst[0]\n\n['guebin', 202112345, 'M']\n\n\n\nfor name,studentid,sex in lst: \n    print(name,sex)\n\nguebin M\niu F\nhodong M\n\n\n#\n# 예제 – for문과 튜플, dummy variable _\n\nfor name,studentid,sex in lst: \n    print(studentid)\n\n202112345\n202254321\n202011223\n\n\n\nfor _,studentid,_ in lst: \n    print(studentid)\n\n202112345\n202254321\n202011223\n\n\n\nfor _,_,sex in lst: \n    print(sex)\n\nM\nF\nM\n\n\n\nfor name,_,sex in lst: \n    print(name,sex)\n\nguebin M\niu F\nhodong M\n\n\n\nfor name,_,_  in lst: \n    print(name)\n\nguebin\niu\nhodong\n\n\n#\n# 예제 – 튜플과 언패킹연산자 *\n아래와 같이 관심없는것 모두를 other라는 이름으로 받을 수 있음\n\nfor name,*other  in lst: \n    print(name,other)\n\nguebin [202112345, 'M']\niu [202254321, 'F']\nhodong [202011223, 'M']\n\n\n*의 동작을 더 세심히 살펴보자.\n\nhead, body, *tail = range(1,11) \nhead, body, tail\n\n(1, 2, [3, 4, 5, 6, 7, 8, 9, 10])\n\n\n\nhead1,head2, *body, tail1,tail2,tail3 = range(1,11) \nhead1,head2, body, tail1,tail2,tail3 \n\n(1, 2, [3, 4, 5, 6, 7], 8, 9, 10)\n\n\n\n*head, body, tail = range(1,11) \nhead, body, tail\n\n([1, 2, 3, 4, 5, 6, 7, 8], 9, 10)\n\n\n(관찰)\n그러고 보니까..\n[*head, body, tail] = [1,2,3,4,5,6,7,8,9,10] \n[head, body, tail] = [[1,2,3,4,5,6,7,8],9,10] \n이렇다는 거잖아?\n*를 붙이면 1차원 자료구조가 풀린다..?\n\n[1,2,[1,2,3]]\n\n[1, 2, [1, 2, 3]]\n\n\n\n[1,2,*[1,2,3]]\n\n[1, 2, 1, 2, 3]\n\n\n- 단독사용은 불가능\n\n*[1,2,3]\n\nSyntaxError: can't use starred expression here (386627056.py, line 1)"
  },
  {
    "objectID": "posts/05wk-2.html#f.-튜플을-왜-쓸까-제-생각..",
    "href": "posts/05wk-2.html#f.-튜플을-왜-쓸까-제-생각..",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "F. 튜플을 왜 쓸까? – 제 생각..",
    "text": "F. 튜플을 왜 쓸까? – 제 생각..\n- 질문: 리스트를 쓰지 않고 왜 튜플을 써야하나?\n- 답변1: (책의 설명)\n\n초보적인 설명: 실수방지\n더 정확한 설명: 빠르다, 여러사람과 작업하기 유리하다, 깊은복사/얕은복사시 원하지 않는 오류 (side effect 이라고 함) 방지\n\n- 답변2: 괄호를 생략할 수 있기 때문에, 리스트 말고 튜플을 쓰면 편함.\n\n소괄호의 생략 + 언패킹 \\(\\Rightarrow\\) 엄청난 가독성.\n컴공과 사람들 의견: 튜플 + 언패킹 \\(\\Rightarrow\\) 엄청난 가독성 \\(\\Rightarrow\\) 충격 \\(\\Rightarrow\\) “파이썬 편하더라고요..”\n\n- 근본적인 의문: 파이썬을 처음 만들때 리스트에 괄호를 생략하는 기능을 추가했으면 편했잖아?\n- 저의 설명: 리스트=신라면, 튜플=라면사리 같은 느낌으로 이해하면 된다. 불변형(튜플)은 기능제한이 있는데, 가변형(리스트)는 기능이 풍부하다. 대신에, 가변형은 느리고 무겁다.\n\n기능적으로만 보면, 신라면이 있으면 스프를 버리고 라면사리를 얻을 수 있음, 그래서 라면사리는 필요없음.\n그런데 신라면에서 스프를 버려서 라면사리를 항상 얻는다면, 비효율적임.\n우리가 원하는게 (1) 원소를 벡터형태로 모은뒤 (2) 벡터자체를 출력해보고 (3) 각 원소를 sort하고 (4) 원소를 추가 append하고 (5) 원소를 삭제 remove 하는 것 일수도 있음. 그렇지만 진짜 단순하게 (1),(2) 만 원할수도있음.\n단순히 (1)-(2)의 목적으로 리스트를 사용하는건 비효율적이니까 불변형인 튜플을 만듦. (1)-(2)를 사용함에 있어서 편리성을 극대화 하기위해 괄호도 생략하게 해줌.\n\n\ndef mycal(a,b):\n    return a+b, a-b, a*b, a/b # 여러개의 값을 리턴하는듯 보임 -&gt; 사실은 길이가 4인 튜플 1개를 리턴\n\n\nmycal(1,2)\n\n(3, -1, 2, 0.5)\n\n\n\n_,_,mul,_ = mycal(1,2)\n\n\nmul\n\n2"
  },
  {
    "objectID": "posts/05wk-2.html#g.-연습문제들",
    "href": "posts/05wk-2.html#g.-연습문제들",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "G. 연습문제들",
    "text": "G. 연습문제들\n# 문제. 길이가 1인 튜플을 만들어 자신의 학번을 저장하라. 길이가 1인 튜플을 만들어 자신의 영문이름을 저장하라. 두 튜플을 + 연산자로 합쳐아래와 같은 출력결과를 얻어라. 최종 결과는 예를들면 아래와 같아야 한다.\n\n('2021-43052', 'GuebinChoi')\n\n('2021-43052', 'GuebinChoi')\n\n\n(풀이)\n\nsid = ('2021-43052',)\nname = ('GuebinChoi',)\n\n\nsid+name\n\n('2021-43052', 'GuebinChoi')\n\n\n파이썬프로그래밍 수강생. 아래는 파이썬프로그래밍 수강생들의 학번, 이름, 출석점수, 과제점수, 중간고사점수, 기말고사점수를 저장한 중첩리스트이다.\n\nlst = [['2021-43052', 'GuebinChoi', 5, 10, 20, 25],\n       ['2019-12342', 'Heung-min Son', 10, 15, 30, 15],\n       ['2018-32234', 'hynn', 7, 20, 30, 15],\n       ['2022-42323', 'Minji', 8, 20, 20, 35],\n       ['2023-55342', 'Hanni', 7, 20, 30, 35],\n       ['2022-46624', 'Danielle', 3, 15, 30, 40],\n       ['2022-11239', 'Haerin', 10, 20, 30, 40],\n       ['2022-32114', 'Hyein', 10, 20, 20, 35]]\nlst \n\n[['2021-43052', 'GuebinChoi', 5, 10, 20, 25],\n ['2019-12342', 'Heung-min Son', 10, 15, 30, 15],\n ['2018-32234', 'hynn', 7, 20, 30, 15],\n ['2022-42323', 'Minji', 8, 20, 20, 35],\n ['2023-55342', 'Hanni', 7, 20, 30, 35],\n ['2022-46624', 'Danielle', 3, 15, 30, 40],\n ['2022-11239', 'Haerin', 10, 20, 30, 40],\n ['2022-32114', 'Hyein', 10, 20, 20, 35]]\n\n\n# 문제. 파이썬프로그래밍 수강생의 수는 모두 몇명인가?\n(풀이)\n\nlen(lst)\n\n8\n\n\n#. 전북대학교 지침에 따라 출석점수가 7보다 작은 학생은 (즉 출석점수 &lt; 7 일 경우) F학점을 부여하게 되어있다. 이 기준에 따르면 F를 받는 학생은 모두 몇명인가?\n(풀이)\n\nsum([att&lt;7 for _,_,att,*other in lst])\n\n2\n\n\n# 문제. 파이썬프로그래밍 수업의 경우 출석+레포트 &lt; 21 일 경우 F학점을 부여한다고 한다. 이 기준에 따르면 F를 받는 학생은 모두 몇명인가?\n(풀이)\n\nsum([att+rep&lt;21 for _,_,att,rep,*other in lst])\n\n2\n\n\n# 문제. 리스트의 정렬순서를 [학번, 이름, …, 기말고사점수] 가 아니라 [이름, 학번, … , 기말고사점수] 와 같이 되도록 변경하는 코드를 작성하라.\n(출력예시)\n\n[['GuebinChoi', '2021-43052', 5, 10, 20, 25],\n ['Heung-min Son', '2019-12342', 10, 15, 30, 15],\n ['hynn', '2018-32234', 7, 20, 30, 15],\n ['Minji', '2022-42323', 8, 20, 20, 35],\n ['Hanni', '2023-55342', 7, 20, 30, 35],\n ['Danielle', '2022-46624', 3, 15, 30, 40],\n ['Haerin', '2022-11239', 10, 20, 30, 40],\n ['Hyein', '2022-32114', 10, 20, 20, 35]]\n\n[['GuebinChoi', '2021-43052', 5, 10, 20, 25],\n ['Heung-min Son', '2019-12342', 10, 15, 30, 15],\n ['hynn', '2018-32234', 7, 20, 30, 15],\n ['Minji', '2022-42323', 8, 20, 20, 35],\n ['Hanni', '2023-55342', 7, 20, 30, 35],\n ['Danielle', '2022-46624', 3, 15, 30, 40],\n ['Haerin', '2022-11239', 10, 20, 30, 40],\n ['Hyein', '2022-32114', 10, 20, 20, 35]]\n\n\n(풀이)\n\n[[name,sid,*other] for sid,name,*other in lst]\n\n[['GuebinChoi', '2021-43052', 5, 10, 20, 25],\n ['Heung-min Son', '2019-12342', 10, 15, 30, 15],\n ['hynn', '2018-32234', 7, 20, 30, 15],\n ['Minji', '2022-42323', 8, 20, 20, 35],\n ['Hanni', '2023-55342', 7, 20, 30, 35],\n ['Danielle', '2022-46624', 3, 15, 30, 40],\n ['Haerin', '2022-11239', 10, 20, 30, 40],\n ['Hyein', '2022-32114', 10, 20, 20, 35]]"
  },
  {
    "objectID": "posts/05wk-2.html#a.-인덱싱고급-스트라이딩",
    "href": "posts/05wk-2.html#a.-인덱싱고급-스트라이딩",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "A. 인덱싱고급 (스트라이딩)",
    "text": "A. 인덱싱고급 (스트라이딩)\n- 스트라이딩 [start:end:step]\n\nlst = list('abcdefghijk')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']\n\n\n\nlen(lst)\n\n11\n\n\n\nlst[0:9:2]\n\n['a', 'c', 'e', 'g', 'i']\n\n\n- 생략\n\nlst[0:9]\n#lst[0:9:]\n#lst[0:9:1]\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']\n\n\n\nlst[1::3]\n\n['b', 'e', 'h', 'k']\n\n\n\nlst[:8:3]\n\n['a', 'd', 'g']\n\n\n# 예제1: 짝수/홀수 원소 추출\n아래와 같은 문자열이 있다고 하자.\n\nlst = list('abcdefghijk')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']\n\n\nindex = 0,2,4, ... 에 해당하는 원소를 출력하라.\n\nlst[::2]\n\n['a', 'c', 'e', 'g', 'i', 'k']\n\n\nindex = 1,4,7 ... 에 해당하는 원소를 출력하라.\n\nlst[1::3]\n\n['b', 'e', 'h', 'k']\n\n\n#\n# 예제2 – 세로로..\n\n(예제2를 위한 예비학습) 문자열에서 \\n을 출력하면 출력시 줄바꿈이 일어난다.\n\nprint('1행\\n2행\\n3행')\n\n1행\n2행\n3행\n\n\n예비학습 끝\n\n아래와 같은 문자열이 있다고 하자.\n\ntxt = '너같이사랑스럽고\\n또예쁘고도멋지고\\n속훤히보이는너알\\n았어그동안고마웠\\n지정말정말사랑해'\nprint(txt)\n\n너같이사랑스럽고\n또예쁘고도멋지고\n속훤히보이는너알\n았어그동안고마웠\n지정말정말사랑해\n\n\n위 문자열을 세로로 읽는 코드를 작성하라. (9칸씩 점프하면서 읽으면 된다)\n(풀이)\n\ntxt[::9]\n\n'너또속았지'\n\n\n#\n- step = -1 이면?\n\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']\n\n\n\nlst[::-1]\n\n['k', 'j', 'i', 'h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n- 스트라이딩으로 step = -1 옵션 주기 vs 리스트의 .reverse() 메소드 이용하기\n관찰1: reverse 메소드는 리스트 자체를 변화시킴\n\nlst = list('abcdefgh')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n\nlst.reverse()  \nlst\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n관찰2: [::-1]는 리스트는 변화시키지 않음\n\nlst = list('abcdefgh')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n\nlst[::-1]\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n- -step 은 쓰기 까다롭다.\n(예제) 처음과 끝을 생략하지 않고 아래와 동일한 효과를 주는 코드를 만들어 보자.\n(풀이)\n결국 lst[?:?:-1]의 꼴에서 적당히 ?의 값을 채우면 된다. –&gt; 어려워\n\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n\nlst[::-1]\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n\n\n\nNone\na\nb\nc\nd\ne\nf\ng\nh\nNone\n\n\n\n\n?\n0\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n-9\n-8\n-7\n-6\n-5\n-4\n-3\n-2\n-1\n?\n\n\n\n\nlst[-1:-9:-1]  # 지양 &lt;-- 쓰지마..\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']"
  },
  {
    "objectID": "posts/05wk-2.html#b.-len함수",
    "href": "posts/05wk-2.html#b.-len함수",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "B. len함수",
    "text": "B. len함수\n- 0차원 자료형은 len함수가 동작하지 않음\n\na=1 \nlen(a)\n\nTypeError: object of type 'int' has no len()\n\n\n\na=True\nlen(a)\n\nTypeError: object of type 'bool' has no len()\n\n\n\na=3.14\nlen(a)\n\nTypeError: object of type 'float' has no len()\n\n\n\nnote: 이것이 어떠한 수학적인 의미를 가지거나 0차원의 본질적진리를 뜻하는 것은 아님. R에서는 1,3.14,TRUE의 길이가 1로 존재함.\n\n- 1차원 자료형은 len함수가 동작\n\na='guebin'\nlen(a)\n\n6\n\n\n\na=[1,2,3,4,5,6]\nlen(a)\n\n6\n\n\n\na=1,2,3,4,5,6 \nlen(a)\n\n6\n\n\n\na=range(10)\nlen(a)\n\n10\n\n\n- 길이가 1인 1차원 자료형과 0차원 자료형은 다른것임\n\na='g'\nlen(a)\n\n1\n\n\n\na=[1]\nlen(a)\n\n1\n\n\n\na=(1,)\nlen(a)\n\n1\n\n\n\na=range(1)\nlen(a)\n\n1\n\n\n- 길이가 0인 1차원 자료형도 존재함\n\na=''\nlen(a)\n\n0\n\n\n\na=[]\nlen(a)\n\n0\n\n\n\na=()\nlen(a)\n\n0\n\n\n\na=range(0)\nlen(a)\n\n0"
  },
  {
    "objectID": "posts/05wk-2.html#a.-intro-str-list-tuple-정리",
    "href": "posts/05wk-2.html#a.-intro-str-list-tuple-정리",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "A. intro: str, list, tuple 정리",
    "text": "A. intro: str, list, tuple 정리\n- str, list, tuple은 모두 시퀀스형이라는 공통점이 있다. \\(\\to\\) 원소의 위치번호로 인덱싱이 가능\n\nlst = [1,2,3,4]\n\n\nlst[0] # 위치번호=0\n\n1\n\n\n\nlst[-1] # 위치번호=-1\n\n4\n\n\n- str, list, tuple은 차이점도 존재함. 잠깐 정리해보자.\n시퀀스형의 카테고리\n\n컨테니어형: list, tuple\n균일형: str\n가변형: list\n불변형: tuple, str\n\n표로 정리하면\n\n\n\n\n컨테니어형\n균일형\n\n\n\n\n가변형\nlist\n.\n\n\n불변형\ntuple\nstr\n\n\n\n- 시퀀스형이 아닌 1차원 자료형도 있을까? 원소의 위치번호로 인덱싱이 불가능한 자료형\n- 왜 이런게 필요할까?\n\n벡터에서 원소를 뽑는것은 정보의 모임에서 정보를 검색하는 것과 같다.\n정보를 순서대로 나열한뒤에 그 순서를 이용하여 검색하는 방법은 유용하다.\n하지만 경우에 따라서는 키워드를 기억해서 그 키워드를 바탕으로 정보에 접근하는 방법이 유용할 수 있다.\n\n카카오톡 대화내용검색\n(상황1) 오늘아침에 와이프가 뭔가를 카톡으로 부탁했었음. 그런데 그 뭔가가 기억안남.\n(상황2) 방학전에 동료교수과 개강이후 저녁약속을 카톡으로 잡았었음. 그런데 그게 언제인지 기억안남.\n- 순서대로 정리된 자료를 검색할때는 시퀀스형이 유리하다. 그런데 키워드로 검색하고 싶을 경우는 딕셔너리 타입이 유리하다."
  },
  {
    "objectID": "posts/05wk-2.html#b.-선언-1",
    "href": "posts/05wk-2.html#b.-선언-1",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "B. 선언",
    "text": "B. 선언\n- 방법1: 가장 일반적\n\ndct = {'guebin':49, 'hanni':80}\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n- 방법2: dict() 이용\n\ndct = dict(guebin=49, hanni=80)\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n- 방법3: 중첩된 리스트를 만든 뒤에 형태변환\n\n_lst = [['guebin',49],['hanni',80]]\n_lst \n\n[['guebin', 49], ['hanni', 80]]\n\n\n\ndict(_lst)\n\n{'guebin': 49, 'hanni': 80}\n\n\n- 방법4: 중첩된 튜플을 만든 뒤에 형태변환\n\n_tpl = ('guebin',49), ('hanni',80)\n_tpl\n\n(('guebin', 49), ('hanni', 80))\n\n\n\ndict(_tpl)\n\n{'guebin': 49, 'hanni': 80}"
  },
  {
    "objectID": "posts/05wk-2.html#c.-원소추출",
    "href": "posts/05wk-2.html#c.-원소추출",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "C. 원소추출",
    "text": "C. 원소추출\n- 원소의 위치로 추출할 수 없고, key로 추출해야 한다.\n\ndct = {'guebin':49, 'hanni':80}\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\nguebin의 점수를 추출하고 싶다면?\n\ndct['guebin']\n\n49\n\n\n- 만약에 dict가 아니라 list로 정보를 저장했다면?\n(예제) 아래와 같은 리스트에서 guebin의 점수를 추출하고 싶다면?\n\nlst=[['guebin',49],['hanni',80]]\nlst\n\n[['guebin', 49], ['hanni', 80]]\n\n\n(풀이1)\n\nlst[0][1] # guebin의 점수를 출력하란 의미\n\n49\n\n\n(풀이2) – 진짜 최악\n\n[lst[i][1] for i in range(len(lst)) if lst[i][0] == 'guebin']\n\n[49]\n\n\n(풀이3) – 덜 최악\n\n[score for name,score in lst if name == 'guebin']\n\n[49]\n\n\n- ’guebin’의 점수를 추출하는 코드 비교\n\ndct['guebin'] # 코드1: 단순하고, 가독성있음\n\n49\n\n\n\nlst[0][1] # 코드2: 단순하지만, 가독성이 있는건 아님, 확장성이 없음\n\n49\n\n\n\n[lst[i][1] for i in range(len(lst)) if lst[i][0] =='guebin'] # 코드3: 단순하지도 않고, 가독성도 없음.\n\n[49]\n\n\n\n[score for name,score in lst if name=='guebin' ] # 코드4: 단순하지 않지만, 가독성은 있음\n\n[49]"
  },
  {
    "objectID": "posts/05wk-2.html#d.-원소추가-변경-삭제",
    "href": "posts/05wk-2.html#d.-원소추가-변경-삭제",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "D. 원소추가, 변경, 삭제",
    "text": "D. 원소추가, 변경, 삭제\n\ndct={'guebin':49, 'hanni':80}\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n- 원소에 접근: guebin의 점수 출력\n\ndct['guebin']\n\n49\n\n\n- 추가: hynn학생의 점수를 추가\n\ndct['hynn'] = 99\n\n\ndct\n\n{'guebin': 49, 'hanni': 80, 'hynn': 99}\n\n\n- 변경: hanni의 점수를 변경\n\ndct['hanni'] = 100 \n\n\ndct\n\n{'guebin': 49, 'hanni': 100, 'hynn': 99}\n\n\n- 삭제\n(방법1)\n\ndct={'guebin':49, 'hanni':80, 'hynn':99}\ndel dct['guebin']  \ndct\n\n{'hanni': 80, 'hynn': 99}\n\n\n(방법2)\n\ndct={'guebin':49, 'hanni':80, 'hynn':99} \ndct.pop('guebin')\n\n49\n\n\n\ndct\n\n{'hanni': 80, 'hynn': 99}\n\n\n- 참고로 리스트였다면 이러한 삭제작업역시 비효율적이었을 것임\n\nlst = [['guebin',49],['hanni',80],['hynn',99]] \nlst\n\n[['guebin', 49], ['hanni', 80], ['hynn', 99]]\n\n\nguebin의 점수를 삭제하려면?\n\n[[name,score] for name,score in lst if name != 'guebin']\n\n[['hanni', 80], ['hynn', 99]]"
  },
  {
    "objectID": "posts/05wk-2.html#e.-연산",
    "href": "posts/05wk-2.html#e.-연산",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "E. 연산",
    "text": "E. 연산\n- 하나있어요..\n\ndct = {'guebin':49, 'hanni':80} \ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n\n'guebin' in dct\n\nTrue\n\n\n\n'hanni' in dct\n\nTrue\n\n\n\n'hynn' in dct\n\nFalse\n\n\n- in은 사실 다른자료형도 가능했음\n(관찰1)\n\n'a' in 'guebin' \n\nFalse\n\n\n\n'b' in 'guebin' \n\nTrue\n\n\n\n'c' in 'guebin' \n\nFalse\n\n\n(관찰2)\n\ntpl = 1,2,3 \ntpl\n\n(1, 2, 3)\n\n\n\n1 in tpl\n\nTrue\n\n\n\n4 in tpl\n\nFalse\n\n\n(관찰3)\n\nlst = [['guebin',49],['hanni',80],['hynn',99]] \nlst\n\n[['guebin', 49], ['hanni', 80], ['hynn', 99]]\n\n\n\n['guebin',49] in lst\n\nTrue\n\n\n- in연산자가 dict형에 사용되면 key를 기준으로 True, False를 판단한다."
  },
  {
    "objectID": "posts/05wk-2.html#f.-딕셔너리-특수기능",
    "href": "posts/05wk-2.html#f.-딕셔너리-특수기능",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "F. 딕셔너리 특수기능",
    "text": "F. 딕셔너리 특수기능\n(pop)\n\ndct = {'guebin':49, 'hanni':80} \ndct.pop('hanni')\ndct\n\n{'guebin': 49}\n\n\n(get)\n\ndct = {'guebin':49, 'hanni':80} \ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n\ndct.get('guebin') \n\n49\n\n\n아래와 같은 기능\n\ndct['guebin']\n\n49\n\n\n미묘한 차이점이 존재함\n\ndct['hynn'] # hynn이 없어서 키에러 출력, 그런 key는 없다.. \n\nKeyError: 'hynn'\n\n\n\ndct.get('hynn') # hynn이 없으면 아무것도 출력안함 \n\n(keys,values,items)\n\nfor k,v in dct.items():\n    print(k,v)\n\nguebin 49\nhanni 80\n\n\n- .keys()는 딕셔너리의 키를 리턴한다.\n\ndct = {'guebin':49, 'hanni':80} \ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n\n_keys=dct.keys()\n_keys\n\ndict_keys(['guebin', 'hanni'])\n\n\n\ntype(_keys) # 리턴된 자료형은 이상한것임\n\ndict_keys\n\n\n\nlist(_keys) # 아무튼 그 이상한 자료형도 리스트화 가능 \n\n['guebin', 'hanni']\n\n\n- .values()는 딕셔너리의 값들을 리턴한다.\n\n_values = dct.values()\n_values \n\ndict_values([49, 80])\n\n\n\ntype(_values)\n\ndict_values\n\n\n\nlist(_values)\n\n[49, 80]\n\n\n- .items()는 딕셔너리의 (키,값)을 리턴한다.\n\n_items = dct.items()\n_items \n\ndict_items([('guebin', 49), ('hanni', 80)])\n\n\n\ntype(_items)\n\ndict_items\n\n\n\nlist(_items)\n\n[('guebin', 49), ('hanni', 80)]"
  },
  {
    "objectID": "posts/05wk-2.html#g.-for문과-dict-star",
    "href": "posts/05wk-2.html#g.-for문과-dict-star",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "G. for문과 dict (\\(\\star\\))",
    "text": "G. for문과 dict (\\(\\star\\))\n\ndct = {'guebin': 49, 'hanni': 80}\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n(예시1)\n\nfor k in dct.keys():\n    print(k)\n\nguebin\nhanni\n\n\n\nfor k in dct:\n    print(k)\n\nguebin\nhanni\n\n\n\n딕셔너리 그자체도 for문에 넣을 수 있다. 그때는 딕셔너리의 key가 반복된다.\n결과를 보면 dct 대신에 dct.keys()와 list(dct)를 넣었을때와 결과가 같다.\n\n\nNote: list(dct) 하면 key만 리턴된다.\n\n(예시2)\n\nfor v in dct.values():\n    print(v)\n\n49\n80\n\n\n(예시3)\n\nfor i in dct.items():\n    print(i)\n\n('guebin', 49)\n('hanni', 80)\n\n\n(예시4)\n\nfor k,v in dct.items():\n    print(k,v)\n\nguebin 49\nhanni 80\n\n\n(예시5) – {}의 중간고사 점수는 {}점 입니다.\n\nfor name,score in dct.items():\n    print(f'{name}의 중간고사 점수는 {score}점 입니다.')\n\nguebin의 중간고사 점수는 49점 입니다.\nhanni의 중간고사 점수는 80점 입니다."
  },
  {
    "objectID": "posts/05wk-2.html#h.-dict에서-key혹은-value만-뽑아내기",
    "href": "posts/05wk-2.html#h.-dict에서-key혹은-value만-뽑아내기",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "H. dict에서 key혹은 value만 뽑아내기",
    "text": "H. dict에서 key혹은 value만 뽑아내기\n- 예제: 아래의 dict에서 key만 뽑아내고 싶다.\n\ndct = {'guebin':49, 'hanni':80} \n\n(풀이1)\n\nlist(dct)\n\n['guebin', 'hanni']\n\n\n(풀이2)\n\nlist(dct.keys())\n\n['guebin', 'hanni']\n\n\n(풀이3)\n\n[k for k in dct]\n\n['guebin', 'hanni']\n\n\n(풀이4)\n\n[k for k,v in dct.items()]\n\n['guebin', 'hanni']\n\n\n- 예제: 아래의 dict에서 value만 뽑아내고 싶다.\n\ndct = {'guebin':49, 'hanni':80} \n\n(풀이1)\n\nlist(dct.values())\n\n[49, 80]\n\n\n(풀이2)\n\n[dct[k] for k in dct]\n\n[49, 80]\n\n\n(풀이3)\n\n[v for v in dct.values()]\n\n[49, 80]\n\n\n(풀이4)\n\n[v for k,v in dct.items()]\n\n[49, 80]"
  },
  {
    "objectID": "posts/05wk-2.html#a.-바꿔치기",
    "href": "posts/05wk-2.html#a.-바꿔치기",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "A. 바꿔치기",
    "text": "A. 바꿔치기\n# 예제1 – 아래와 같은 리스트를 고려하자.\n\nlst = ['딸기','사과','바나나','딸기','사과','오토바이','자동차','버스','기차','오토바이','자동차']\n\n다음의 맵핑규칙에 따라서 위의 리스트의 원소를 바꾸어라.\n\n\n\n변환전\n변환후\n\n\n\n\n딸기\n과일\n\n\n사과\n과일\n\n\n바나나\n과일\n\n\n오토바이\n탈것\n\n\n자동차\n탈것\n\n\n버스\n탈것\n\n\n기차\n탈것\n\n\n\n(풀이1) – elif를 한번 써본정도의 의미. 추천하는 풀이 X\n\nlst2 = []\nfor l in lst:\n    if l=='딸기':\n        lst2.append('과일')\n    elif l=='사과':\n        lst2.append('과일')\n    elif l=='바나나':\n        lst2.append('과일')\n    elif l=='오토바이':\n        lst2.append('탈것')\n    elif l=='자동차':\n        lst2.append('탈것')\n    elif l=='버스':\n        lst2.append('탈것')\n    else:\n        lst2.append('탈것')        \n\n\nlst,lst2\n\n(['딸기', '사과', '바나나', '딸기', '사과', '오토바이', '자동차', '버스', '기차', '오토바이', '자동차'],\n ['과일', '과일', '과일', '과일', '과일', '탈것', '탈것', '탈것', '탈것', '탈것', '탈것'])\n\n\n(풀이2) – 코드는 쉽고 편함. dct를 만들기 힘듦.\n\ndct = {'딸기':'과일','사과':'과일','바나나':'과일','오토바이':'탈것','자동차':'탈것','버스':'탈것','기차':'탈것'}\ndct\n\n{'딸기': '과일',\n '사과': '과일',\n '바나나': '과일',\n '오토바이': '탈것',\n '자동차': '탈것',\n '버스': '탈것',\n '기차': '탈것'}\n\n\n\n[dct[l] for l in lst]\n\n['과일', '과일', '과일', '과일', '과일', '탈것', '탈것', '탈것', '탈것', '탈것', '탈것']\n\n\n(풀이3) – 코드가 매우 어려움. dct를 만들기 쉬움.\n\ndct = {'과일':['딸기','사과','바나나'], '탈것':['오토바이','자동차','버스','기차']}\ndct\n\n{'과일': ['딸기', '사과', '바나나'], '탈것': ['오토바이', '자동차', '버스', '기차']}\n\n\n\nlst\n\n['딸기', '사과', '바나나', '딸기', '사과', '오토바이', '자동차', '버스', '기차', '오토바이', '자동차']\n\n\n\n[k for l in lst for k in dct if l in dct[k]]\n\n['과일', '과일', '과일', '과일', '과일', '탈것', '탈것', '탈것', '탈것', '탈것', '탈것']\n\n\n#\n# 예제2 – 아래와 같은 리스트가 있다고 하자.\n\nlst = list('abcd'*2+'bbb')\nlst\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'b', 'b', 'b']\n\n\n아래의 규칙에 의하여 lst의 각 원소의 값을 바꾸고 싶다고 하자. 이를 구현하는 코드를 작성하라.\n\n\n\n변환전\n변환후\n\n\n\n\n‘a’\n[1,0,0,0]\n\n\n‘b’\n[0,1,0,0]\n\n\n‘c’\n[0,0,1,0]\n\n\n‘d’\n[0,0,0,1]\n\n\n\n(풀이)\n\ndct = {'a':[1,0,0,0], 'b':[0,1,0,0], 'c':[0,0,1,0], 'd':[0,0,0,1]}\ndct\n\n{'a': [1, 0, 0, 0], 'b': [0, 1, 0, 0], 'c': [0, 0, 1, 0], 'd': [0, 0, 0, 1]}\n\n\n\n[dct[l] for l in lst]\n\n[[1, 0, 0, 0],\n [0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 1],\n [1, 0, 0, 0],\n [0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 1],\n [0, 1, 0, 0],\n [0, 1, 0, 0],\n [0, 1, 0, 0]]\n\n\n# 예제3 – 예제2을 역변환하라. 즉 아래의 리스트를\n\nlst2= [[1, 0, 0, 0],\n       [0, 1, 0, 0],\n       [0, 0, 1, 0],\n       [0, 0, 0, 1],\n       [1, 0, 0, 0],\n       [0, 1, 0, 0],\n       [0, 0, 1, 0],\n       [0, 0, 0, 1],\n       [0, 1, 0, 0],\n       [0, 1, 0, 0],\n       [0, 1, 0, 0]]\n\n아래와 같이 바꾸라.\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'b', 'b', 'b']\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'b', 'b', 'b']\n\n\n(풀이) – 실패\n\ndct = {[1,0,0,0]:'a', [0,1,0,0]:'b', [0,0,1,0]:'c', [0,0,0,1]:'d'}\ndct\n\nTypeError: unhashable type: 'list'\n\n\ndct의 key에 대응하는것은 불변형만 가능\n(풀이1)\n\ndct = {(1,0,0,0):'a', (0,1,0,0):'b', (0,0,1,0):'c', (0,0,0,1):'d'}\ndct\n\n{(1, 0, 0, 0): 'a', (0, 1, 0, 0): 'b', (0, 0, 1, 0): 'c', (0, 0, 0, 1): 'd'}\n\n\n\n[dct[tuple(l)] for l in lst2]\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'b', 'b', 'b']\n\n\n(풀이2)\n\ndct = {'a':[1,0,0,0], 'b':[0,1,0,0], 'c':[0,0,1,0], 'd':[0,0,0,1]} # 예제2의 dct\n\n\n[k for l in lst2 for k in dct if dct[k]==l]\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'b', 'b', 'b']"
  },
  {
    "objectID": "posts/05wk-2.html#b.-연습문제",
    "href": "posts/05wk-2.html#b.-연습문제",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "B. 연습문제",
    "text": "B. 연습문제\n# 문제. 아래와 같은 맵핑을 고려하자.\n\n\n\n문자\n숫자\n\n\n\n\na\n0\n\n\nb\n1\n\n\n\n이를 딕셔너리로 표현하면 아래와 같다.\n\ndct = {'a':0, 'b':1} \n\n위 규칙에 따라서 아래의 리스트의 원소를 문자로 각각 변환하라.\n\nlst = [1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1]\n\n# 출력은 아래와 같아야 한다. \n['b', 'a', 'b', 'a', 'b', 'a', 'b', 'b', 'b', 'b', 'a', 'a', 'b', 'a', 'b']\n(풀이)\n\n[k for l in lst for k in dct if l == dct[k]]\n\n['b', 'a', 'b', 'a', 'b', 'a', 'b', 'b', 'b', 'b', 'a', 'a', 'b', 'a', 'b']\n\n\n# 문제. 아래와 같은 맵핑을 고려하자.\n\n\n\n월\n의미\n\n\n\n\n1,2\n겨울방학\n\n\n3,4,5,6\n1학기\n\n\n7,8\n여름방학\n\n\n9,10,11,12\n2학기\n\n\n\n이러한 규칙에 맞게 아래의 리스트를 적절한 문자열로 변환하라.\n\nmonth = [1,2,2,3,4,5,6,7,8,9,9,10,11,12] \n\n## 출력은 아래와 같아야 한다. \n['겨울방학', '겨울방학', '겨울방학', '1학기', '1학기', '1학기', '1학기', '여름방학', '여름방학', '2학기', '2학기', '2학기', '2학기', '2학기']\n(풀이1) – 좀 더 추천함\n\ndct = {'겨울방학':range(1,3), '1학기':range(3,7), '여름방학':range(7,9), '2학기':range(9,13)}\n\n\n[k for m in month for k in dct if m in dct[k]]\n\n['겨울방학',\n '겨울방학',\n '겨울방학',\n '1학기',\n '1학기',\n '1학기',\n '1학기',\n '여름방학',\n '여름방학',\n '2학기',\n '2학기',\n '2학기',\n '2학기',\n '2학기']\n\n\n(풀이2) – 추천안함\n\ndct = {1:'겨울방학',2:'겨울방학',3:'1학기',4:'1학기',5:'1학기',6:'1학기',7:'여름방학',8:'여름방학',9:'2학기',10:'2학기',11:'2학기',12:'2학기'}\n\n\n[dct[m] for m in month]\n\n['겨울방학',\n '겨울방학',\n '겨울방학',\n '1학기',\n '1학기',\n '1학기',\n '1학기',\n '여름방학',\n '여름방학',\n '2학기',\n '2학기',\n '2학기',\n '2학기',\n '2학기']\n\n\n## – 합성변환\n아래와 같은 맵핑을 고려하자.\n(규칙1)\n\n\n\n문자\n숫자\n\n\n\n\n바나나\n0\n\n\n사과\n1\n\n\n오토바이\n2\n\n\n자동차\n3\n\n\n자전거\n4\n\n\n\n(규칙2)\n\n\n\n아이템\n카테고리\n\n\n\n\n바나나\n과일\n\n\n사과\n과일\n\n\n오토바이\n탈것\n\n\n자동차\n탈것\n\n\n자전거\n탈것\n\n\n\n각각의 규칙을 나타내는 딕셔너리는 아래와 같이 선언되어있다고 하자.\n\ndct1 = {'바나나':0, '사과':1, '오토바이':2, '자동차':3, '자전거':4} \ndct2 = {'과일':['바나나','사과'], '탈것':['오토바이','자동차','자전거']} \n\n# 문제. 규칙1를 이용하여 아래와 같은 리스트를 변환하는 함수를 구현하고 그 함수를 f라 선언하라.\n# 입력 \n[0,1,0,1,4]\n\n# 출력 \n['바나나', '사과', '바나나', '사과', '자전거']\n(사용예시)\n\nf([0,1,0,1,4])\n\n['바나나', '사과', '바나나', '사과', '자전거']\n\n\n(풀이)\n\nf = lambda lst: [k for l in lst for k in dct1 if l == dct1[k]]\n\n\nf([0,1,0,1,4])\n\n['바나나', '사과', '바나나', '사과', '자전거']\n\n\n# 문제. 규칙2를 이용하여 아래와 같이 리스트를 변환하는 함수를 구현하고 그 함수를 g라고 선언하라.\n# 입력 \n['바나나','바나나','바나나','자동차']\n\n# 출력 \n['과일','과일','과일','탈것']\n(사용예시)\n\ng(['바나나','바나나','바나나','자동차'])\n\n['과일', '과일', '과일', '탈것']\n\n\n(풀이)\n\ng = lambda lst: [k for l in lst for k in dct2 if l in dct2[k]]\n\n\ng(['바나나','바나나','바나나','자동차'])\n\n['과일', '과일', '과일', '탈것']\n\n\n# 문제. 규칙1-2를 이용하여 아래와 같은 숫자로 이루어진 입력을 ‘과일’, ‘탈것’ 중 하나로 바꾸는 코드를 구현하라.\n# 입력 \n[0,1,0,1,3,4,2,2,3,4,1,0]\n\n# 출력 \n['과일', '과일', '과일', '과일', '탈것', '탈것', '탈것', '탈것', '탈것', '탈것', '과일', '과일']\nhint \\(g(f(x))\\) 를 이용하라.\n(풀이)\n\ng(f([0,1,0,1,3,4,2,2,3,4,1,0]))\n\n['과일', '과일', '과일', '과일', '탈것', '탈것', '탈것', '탈것', '탈것', '탈것', '과일', '과일']"
  },
  {
    "objectID": "posts/04wk-2.html#a.-사용자가-직접형태변환",
    "href": "posts/04wk-2.html#a.-사용자가-직접형태변환",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "A. 사용자가 직접형태변환",
    "text": "A. 사용자가 직접형태변환\n- 형태변환: float \\(\\to\\) int\n(예시1)\n\na=3.0\ntype(a)\n\nfloat\n\n\n\na=int(a)\n\n\ntype(a)\n\nint\n\n\n(예시2) 이경우는 정보의 손실이 발생\n\na=3.14 \nint(a)\n\n3\n\n\n- 형태변환: int \\(\\to\\) float\n\na=3\ntype(a)\n\nint\n\n\n\na=float(a)\ntype(a)\n\nfloat\n\n\n- 형태변환: bool \\(\\to\\) int/float, int/float \\(\\to\\) bool\n(예시1)\n\na=True\ntype(a)\n\nbool\n\n\n\nint(a)\n\n1\n\n\n\nfloat(a)\n\n1.0\n\n\n(예시2)\n\na=1 \nbool(a)\n\nTrue\n\n\n\na=0\nbool(a)\n\nFalse\n\n\n(예시3)\n\na=1.0\nbool(a)\n\nTrue\n\n\n\na=0.0\nbool(a)\n\nFalse\n\n\n- 이상한 형태변환도 가능하다. (이런것도 바꿔주나 싶은것도 바꿔줌)\n\nbool(-3.14)\n\nTrue\n\n\n\n저는 이런 코드를 의도적으로 사용하지 않아요..\n\n\nint(3.14)\n\n3\n\n\n- 형태변환이 항상가능한것도 아님\n\nfloat(3+0j) # 사실상 3+0j=3 이므로 float으로 형변환하면 3.0이 되어야 할 것 같은데 변환불가능하다. \n\nTypeError: float() argument must be a string or a real number, not 'complex'"
  },
  {
    "objectID": "posts/04wk-2.html#b.-암묵적형변환",
    "href": "posts/04wk-2.html#b.-암묵적형변환",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "B. 암묵적형변환",
    "text": "B. 암묵적형변환\n- 암묵적형변환 (implicit)\n(예비학습) implicit의 의미\n\n추운날씨 -&gt; 보일러좀 틀자! (explicit) / 오늘 날씨 좀 추운 것 같지 않아? (implicit)\n짜장면 먹을래? -&gt; 싫어! (explicit) / 난 어제 짜장면 먹었는데.. (implicit)\n\n(예제)\n\nTrue * 1 # 1을 곱할건데 너 계속 True로 있을꺼야? \n\n1\n\n\n\n1 * 1.0 # 1.0을 곱할건데 너 계속 int로 있을꺼야? \n\n1.0\n\n\n\nTrue+True # +연산을 할건데 계속 True로 있을꺼야? \n\n2"
  },
  {
    "objectID": "posts/04wk-2.html#a.-선언",
    "href": "posts/04wk-2.html#a.-선언",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "A. 선언",
    "text": "A. 선언\n- 예시1\n\na='guebin'\n\n\na\n\n'guebin'\n\n\n- 예시2\n\na=\"guebin\"\n\n\na\n\n'guebin'\n\n\n- 예시3\n\na=\"asdf'a'sdf\"\na\n\n\"asdf'a'sdf\"\n\n\n- 예시4\n\na='asdf\"a\"sdf'\na\n\n'asdf\"a\"sdf'"
  },
  {
    "objectID": "posts/04wk-2.html#b.-연산",
    "href": "posts/04wk-2.html#b.-연산",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "B. 연산",
    "text": "B. 연산\n- 더하기(+)연산\n\na='X'\nb='2'\n\n\nc=a+b\nc\n\n'X2'\n\n\n- 빼기(-)연산\n\na='X2'\nb='2'\na-b\n\nTypeError: unsupported operand type(s) for -: 'str' and 'str'\n\n\n\n이런건 없다.\n\n- 곱하기(*)연산\n\na='X'\n\n\na+a+a\n\n'XXX'\n\n\n\na*3 # a*3 = a+a+a = 'X'+'X+'X'\n\n'XXX'\n\n\n아래도 가능하다.\n\n3*a\n\n'XXX'\n\n\n그리고 아래도 가능하다.\n\na='X'\nb=3 \na*b\n\n'XXX'\n\n\n대신에 의미상 맞지 않는 것은 수행되지 않고 에러가 난다.\n\na='X'\nb='Y'\na+b\n\n'XY'\n\n\n\na*b\n\nTypeError: can't multiply sequence by non-int of type 'str'\n\n\n- 나눗셈(/)연산\n\n2*'X'\n\n'XX'\n\n\n\na='XX'\n\n\na/2\n\nTypeError: unsupported operand type(s) for /: 'str' and 'int'\n\n\n\n이런건 없다.."
  },
  {
    "objectID": "posts/04wk-2.html#c.-인덱싱",
    "href": "posts/04wk-2.html#c.-인덱싱",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "C. 인덱싱",
    "text": "C. 인덱싱\n- str은 하나의 벡터 문자가 여러개 있는 형태라고 생각하면 된다.\n\na='guebin'\n\n\na\n\n'guebin'\n\n\n\n6개의 칸에 글씨가 하나씩 들어가 있음.\n\n- 대괄호 []안에 숫자를 넣는 방식으로 벡터의 원소를 호출할 수 있다. (주의: 인덱스가 0부터 시작함)\n\na[0] #첫번째원소\n\n'g'\n\n\n\na[1] #두번째원소 \n\n'u'\n\n\n마지막원소는 -1로 호출할 수도 있다.\n\na[-1]\n\n'n'\n\n\n마지막에서 2번째 원소는 -2로 호출가능하다.\n\na[-2]\n\n'i'\n\n\n- 요약하면 아래와 같은 방식으로 호출가능함.\n\n\n\ng\nu\ne\nb\ni\nn\n\n\n\n\n0\n1\n2\n3\n4\n5\n\n\n0\n-5\n-4\n-3\n-2\n-1\n\n\n\n\na[4]\n\n'i'\n\n\n\na[-2]\n\n'i'\n\n\n\na[-4]\n\n'e'\n\n\n- :을 이용하여 여러개의 원소를 호출할 수 있음.\n\na='guebin'\n\n\na[0:3] # a[0],a[1],a[2],a[3]이 아니라 a[0],a[1],a[2]까지만 뽑힌다. 즉 마지막의 3은 호출되지 않는다. \n\n'gue'\n\n\n\na[1:3] # a[1], a[2] 만 호출 // start=1,  stop=3 \n\n'ue'\n\n\nindex=1부터 시작해서 마지막원소까지 호출하려면?\n\na='guebin'\n\n\na[5] # guebin의 마지막원소 'n'이 출려 \n\n'n'\n\n\n\na[1:5] # 5는 포함되지 않으므로 틀림\n\n'uebi'\n\n\n\na[1:6] # 정답\n\n'uebin'\n\n\n안 헷갈리는 방법은 없을까? 생략한다.\n\na[1:]\n\n'uebin'\n\n\n- 생략의 응용1\n\na='k-pop' \na\n\n'k-pop'\n\n\n\na[2:]\n\n'pop'\n\n\n- 생략의 응용2\n\na='k-pop'\na\n\n'k-pop'\n\n\n\n0,1 -&gt; 0,1,2\n\n\na[0:2] # a[0],a[1]\n\n'k-'\n\n\n\na[:2] # a[0],a[1] \n\n'k-'\n\n\n\na[:2] 는 a의 원소중 처음 2개를 뽑는다는 의미\n\n- 생략의 응용3\n\na='k-pop'\na\n\n'k-pop'\n\n\n\na[0:5] # a[0],...,a[4]\n\n'k-pop'\n\n\n\na[:]\n\n'k-pop'"
  },
  {
    "objectID": "posts/04wk-2.html#d.-str-특수기능",
    "href": "posts/04wk-2.html#d.-str-특수기능",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "D. str 특수기능",
    "text": "D. str 특수기능\n- 파이썬의 변수는 단순히 정보를 담는 그릇이 아니다. 유용한 기능을 제공하는 경우가 있다.\n\na='ABCD' # a라는 변수는 'ABCD'라는 정보를 담는 그릇의 역할만 하지 않고, 특화된 어떠한 기능도 제공한다. \na\n\n'ABCD'\n\n\n\na.lower() # a.lower()를 쓰면 a의 모든 문자를 소문자로 바꾸는 기능을 제공, lower(a)라고 읽자!\n\n'abcd'\n\n\n여기에서 lower()는 문자열에 특화된 기능임. 따라서 당연히 아래는 불가능\n\na=3.14\na.lower() # lower(a)\n\nAttributeError: 'float' object has no attribute 'lower'\n\n\n- 자료형에 특화된 기능(=함수)을 확인하는 방법? a.+ tab 으로 목록 확인 가능\n\na='guebin'\n\n\na.upper?\n\n\nSignature: a.upper()\nDocstring: Return a copy of the string converted to uppercase.\nType:      builtin_function_or_method\n\n\n\n\na.upper() # upper(a) \n\n'GUEBIN'\n\n\n\na.capitalize() # capitalize(a) \n\n'Guebin'\n\n\n- 유용한 특수기능 \\((\\star\\star\\star)\\)\n\n'-'.join(['1','2','3'])\n\n'1-2-3'\n\n\n\n'1-2-3'.split('-')\n\n['1', '2', '3']\n\n\n\n'1-2-3'.replace('-','*')\n\n'1*2*3'"
  },
  {
    "objectID": "posts/04wk-2.html#e.-len",
    "href": "posts/04wk-2.html#e.-len",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "E. len",
    "text": "E. len\n- len함수 소개: 원소의 갯수를 알려주는 함수.\n\na='ABCD' \nlen(a)\n\n4\n\n\n- 참고: len은 0차원 변수형에서는 동작하지 않고 1차원 변수형에서만 동작한다.\n(0차원) len 함수가 동작하지 않음.\n\na=3.14\n\n\nlen(a)\n\nTypeError: object of type 'float' has no len()\n\n\n\nb=True\n\n\nlen(b)\n\nTypeError: object of type 'bool' has no len()\n\n\n(1차원) len 함수가 잘 동작함.\n\na='3.14'\nlen(a)\n\n4\n\n\n\nb=[1,2,3]\n\n\nlen(b)\n\n3"
  },
  {
    "objectID": "posts/04wk-2.html#f.-fstring",
    "href": "posts/04wk-2.html#f.-fstring",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "F. fstring",
    "text": "F. fstring\n- 예제1\n\na=1\nb=2\nprint(f'a+b = {a+b}')\n\na+b = 3\n\n\n- 예제2\n\na=2\nb=3.141592\nprint(f'a*b = {a*b:.2f}')\n\na*b = 6.28\n\n\n- 예제3\n\na=3.141592\nprint(f'2a = {2*a:.2f}\\t3a = {3*a:.2f}')\n\n2a = 6.28   3a = 9.42\n\n\n- 예제4\n\nlst = ['장하니','최다호','주성재','이슬기']\n\n\n[f'{l}학생 안녕하세요, 통계학과 최규빈 교수입니다. 다름이 아니라 전공진로설계관련 상담일자를 잡고자 메일을 보냈습니다.' for l in lst]\n\n['장하니학생 안녕하세요, 통계학과 최규빈 교수입니다. 다름이 아니라 전공진로설계관련 상담일자를 잡고자 메일을 보냈습니다.',\n '최다호학생 안녕하세요, 통계학과 최규빈 교수입니다. 다름이 아니라 전공진로설계관련 상담일자를 잡고자 메일을 보냈습니다.',\n '주성재학생 안녕하세요, 통계학과 최규빈 교수입니다. 다름이 아니라 전공진로설계관련 상담일자를 잡고자 메일을 보냈습니다.',\n '이슬기학생 안녕하세요, 통계학과 최규빈 교수입니다. 다름이 아니라 전공진로설계관련 상담일자를 잡고자 메일을 보냈습니다.']"
  },
  {
    "objectID": "posts/04wk-2.html#g.-string과-for문",
    "href": "posts/04wk-2.html#g.-string과-for문",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "G. string과 for문",
    "text": "G. string과 for문\n- 예제1\n\nfor s in 'jbnu':\n    print(2*s)\n\njj\nbb\nnn\nuu\n\n\n- 예제2\n\n[s*4 for s in 'jbnu']\n\n['jjjj', 'bbbb', 'nnnn', 'uuuu']"
  },
  {
    "objectID": "posts/04wk-2.html#h.-in-연산자",
    "href": "posts/04wk-2.html#h.-in-연산자",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "H. in 연산자",
    "text": "H. in 연산자\n\ns = 'jbnu'\n\n\n'b' in s\n\nTrue\n\n\n\n'c' in s\n\nFalse\n\n\n\n'jb' in s\n\nTrue\n\n\n\n'jn' in s\n\nFalse"
  },
  {
    "objectID": "posts/04wk-2.html#i.-연습문제들",
    "href": "posts/04wk-2.html#i.-연습문제들",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "I. 연습문제들",
    "text": "I. 연습문제들\n전북대학교 – 아래와 같은 문자열이 있다고 하자.\n\na='Jeonbuk National University' \n\n# 문제. 적당한 인덱싱을 통하여 출력결과가 아래와 같도록 하라.\n\n# 적당한 인덱싱\n\n'University'\n\n\nhint: University는 10글자이다.\n(풀이)\n\na[-10:]\n\n'University'\n\n\n# 문제. 출력결과가 아래와 같도록 하는 코드를 작성하라. (lower 함수를 이용할 것)\n\n# 적당한 코드 \n\n'jeonbuk national university'\n\n\n(풀이)\n\na.lower()\n\n'jeonbuk national university'\n\n\n# 문제. 아래의 코드를 관찰하고 isupper()의 기능이 무엇인지 스스로 정리해보라.\n\n'A'.isupper()\n\nTrue\n\n\n\n'AA'.isupper()\n\nTrue\n\n\n\n'Aa'.isupper()\n\nFalse\n\n\n\n'aa'.isupper()\n\nFalse\n\n\n\n'aA'.isupper()\n\nFalse\n\n\n유추한 기능이 맞는지 ChatGPT를 통하여 확인하라.\nDitto – 다음은 인터넷에서 긁어온 어떠한 텍스트이다.\n\ntext = \"국내뿐 아니라 해외 인기도 심상치 않다. 2023년 1월 18일 'Ditto'가 빌보드 핫 100에 96위로 진입했다. 이는 K-pop 역사상 데뷔후 최단 빌보드 Hot 100 차트 입성 기록이다. 다른 뮤지션들이 보통 데뷔 후 수년간 쌓아온 팬덤을 기반으로 빌보드에 입성한데 비해, 뉴진스의 기록은 이례적인 것으로 평가받고 있다. 또한 'OMG'가 빌보드 핫 100에 91위로 진입한 동시에 'Ditto'는 85위로 순위가 상승, 핫 100 주간차트에 두 곡을 올려놓았다. K-Pop 역사상 이 차트에 두 곡 이상을 진입시킨 아티스트는 방탄소년단과 블랙핑크가 유일하다. 'Ditto'는 1월 셋째주 기준, 빌보드뿐만 아니라 영국 오피셜 싱글 차트 '톱 100'에 2주 연속 진입하기도 했다.\"\n\n# 문제. text는 총 몇개의 문장으로 이루어져 있는가?\nhint: 이 텍스트의 문장은 모두 .로 끝난다.\n(풀이)\n\nlen(text.split('. '))\n\n7\n\n\n# 문제. 각 문장은 몇개의 단어로 이루어져 있는가?\nhint: 각 단어는 공백으로 구분된다.\n(풀이)\n\nlst = text.split('. ')\n[len(l.split(' ')) for l in lst]\n\n[6, 9, 11, 18, 18, 12, 16]\n\n\n# 문제. 100이라는 단어가 포함된 문장은 모두 몇 개 인가?\nhint: 아래의 코드를 관찰\n\n'a' in 'abcd'\n\nTrue\n\n\n(풀이)\n\nsum(['100' in l for l in lst])\n\n4"
  },
  {
    "objectID": "posts/04wk-2.html#a.-선언-1",
    "href": "posts/04wk-2.html#a.-선언-1",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "A. 선언",
    "text": "A. 선언\n- 리스트의 선언\n\na= [1,2,3,22] \n\n- 비어있는 리스트의 선언\n\na= []\na\n\n[]\n\n\n\na= list()\na\n\n[]"
  },
  {
    "objectID": "posts/04wk-2.html#b.-연산-1",
    "href": "posts/04wk-2.html#b.-연산-1",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "B. 연산",
    "text": "B. 연산\n- 더하기연산\n\n[1,2,3] + [-3,4,5]\n\n[1, 2, 3, -3, 4, 5]\n\n\n\n우리의 예상과 다른 결과가 나옴 \\(\\to\\) 파이썬은 R처럼 자체적으로 좋은 계산기능을 내장하고 있지 않음.\n\n- 브로드캐스팅과 같이 R에서는 당연히 가능했던 기능을 사용할 수 없음.\n\n[1,2,3,4,5] + 1 \n\nTypeError: can only concatenate list (not \"int\") to list\n\n\n- 뺄셈은 정의되지 않음\n\na= [1,2,1,2]\na-[1,2]\n\nTypeError: unsupported operand type(s) for -: 'list' and 'list'\n\n\n- 곱하기는 정의가능\n\n[1,2]*3\n\n[1, 2, 1, 2, 1, 2]\n\n\n- 나눗셈은 정의되지 않음\n\n[1,2,1,2,1,2] /3\n\nTypeError: unsupported operand type(s) for /: 'list' and 'int'\n\n\n- 더하기와 곱하기는 원소의 추가와 반복추가를 의미하지만 그렇다고 해서 뺄셈과 나눗셈이 원소의 삭제를 의미하는것은 아님\n- 더하기와 곱하기가 원소의 추가와 반복추가를 의미하여 편리할때도 있긴하지만, 우리는 산술적인 +, * 를 원하는 경우도 있다. 이럴 경우는 어떻게 할 수 있을까?\n(예제)\n\na=[1,2]\nb=[3,4]\n\na+b = [4,6] 이 되도록 하려면?\n(풀이1)\n\n[a[0]+b[0],a[1]+b[1]]\n\n[4, 6]\n\n\n풀이가 가능한 이유? a,b는 리스트이지만 a[0], a[1], b[0], b[1] 은 각각 인트형임. 인트형은 + 연산이 가능했음.\n(풀이2)\nnumpy 패키지 (파이썬의 여러 수치연산들을 담당하는 라이브러리)\n\n이러한 벡터연산은 누구나 필요로 하는 연산임.\n내가 아니더라도 누군가가 프로그램화 해놓았을 것임.\n그 누군가가 자신이 만든 코드를 잘 정리하여 무료로 배포했을 수도 있음. (패키지를 배포한다고 표현)\n그 패키지를 우리는 가져와서 설치한뒤 사용하기만 하면된다.\n\n설치된 패키지를 사용하는 방법\n\nimport numpy 한뒤에 numpy.??로 기능을 사용\nimport numpy as np 한뒤에 np.??로 기능을 사용\n\n\nimport numpy \n\n\na=[1,2]\nb=[3,4]\n\n\naa = numpy.array(a)\nbb = numpy.array(b)\n\n\naa+bb\n\narray([4, 6])\n\n\n여러가지 연산 가능 (마치 R처럼 쓸 수 있음)\n\n2*aa\n\narray([2, 4])\n\n\n\n2*aa+1\n\narray([3, 5])\n\n\n\n2*aa+1+bb\n\narray([6, 9])\n\n\n(풀이3)\n\nimport numpy as np ## 설치가 되어있는 numpy라는 패키지를 쓰겠음. 그런데 numpy말고 np라는 이름으로 쓰겠음\n\n\nnp.array(a)+np.array(b)\n\narray([4, 6])"
  },
  {
    "objectID": "posts/04wk-2.html#c.-인덱싱-1",
    "href": "posts/04wk-2.html#c.-인덱싱-1",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "C. 인덱싱",
    "text": "C. 인덱싱\n- str형과 동일한 방식\n\na=[11,22,33,44,55] # 0 -4 -3 -2 -1\n\n\na[-2:] # 끝의 2개의 원소를 뽑음 \n\n[44, 55]"
  },
  {
    "objectID": "posts/04wk-2.html#d.-콘테이너형-객체로서의-리스트",
    "href": "posts/04wk-2.html#d.-콘테이너형-객체로서의-리스트",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "D. 콘테이너형 객체로서의 리스트",
    "text": "D. 콘테이너형 객체로서의 리스트\n- 리스트의 원소는 int, float 따위만 가능한 것이 아니다. (리스트는 컨테이너형 객체이므로)\n\nlst = [1,3.14,True,'a',[1,2], \n       (1,2),{'name':'iu','age':27},{1,2,3}]\nlst\n\n[1, 3.14, True, 'a', [1, 2], (1, 2), {'name': 'iu', 'age': 27}, {1, 2, 3}]\n\n\n\n[type(l) for l in lst]\n\n[int, float, bool, str, list, tuple, dict, set]\n\n\n- str은 컨테이너형이 아니다.\n\n'abcd'[2]\n\n'c'\n\n\n\nstr의 모든 원소는 문자임"
  },
  {
    "objectID": "posts/04wk-2.html#e.-가변객체",
    "href": "posts/04wk-2.html#e.-가변객체",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "E. 가변객체",
    "text": "E. 가변객체\n- 리스트는 원소를 수정할 수 있다. (리스트는 가변객체이므로)\n\na=[11,22,33]\na\n\n[11, 22, 33]\n\n\n\na[0] = -77\n\n\na\n\n[-77, 22, 33]\n\n\n- 원소수정은 당연한 기능같은데 이것이 불가능한 경우도 있다.\n(가능한경우)\n\na=['g','u','e','b','i','n']\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na[0] = 'G'\n\n\na\n\n['G', 'u', 'e', 'b', 'i', 'n']\n\n\n(불가능한경우)\n\na='guebin'\na\n\n'guebin'\n\n\n\na[0]\n\n'g'\n\n\n\na[0]='G'\n\nTypeError: 'str' object does not support item assignment"
  },
  {
    "objectID": "posts/04wk-2.html#f.-리스트의-원소-삭제",
    "href": "posts/04wk-2.html#f.-리스트의-원소-삭제",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "F. 리스트의 원소 삭제",
    "text": "F. 리스트의 원소 삭제\n(예제1) del을 이용한 원소삭제\n아래와 같이 문자로 된 리스트를 선언하자.\n\na=['g','u','e','b','i','n']\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n사실 더 쉽게 선언할 수 있음\n\nlist('guebin')\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n첫번째 원소를 삭제하고 싶다면?\n\ndel a[0]\na\n\n['u', 'e', 'b', 'i', 'n']\n\n\n이 상태에서 다시 첫번째 원소를 삭제한다면?\n\ndel a[0]\na\n\n['e', 'b', 'i', 'n']\n\n\n(예제2) pop을 이용한 원소삭제\n\na=list('guebin')\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na.pop(0)\n\n'g'\n\n\n\na.pop(0)\n\n'u'\n\n\n\na\n\n['e', 'b', 'i', 'n']\n\n\n(예제3) remove를 이용한 원소삭제\n\na=list('guebin')\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na.remove('b')\na\n\n['g', 'u', 'e', 'i', 'n']"
  },
  {
    "objectID": "posts/04wk-2.html#g.-리스트-원소-추가",
    "href": "posts/04wk-2.html#g.-리스트-원소-추가",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "G. 리스트 원소 추가",
    "text": "G. 리스트 원소 추가\n(예제) 비어있는 리스트를 만들고 원소 0,1,2를 차례로 추가하여 보자.\n(풀이1) + 연산이용\n\na=[]\na\n\n[]\n\n\n\na= a+[0]\na\n\n[0]\n\n\n\na= a+[1] # a = [0]+[1]\na\n\n[0, 1]\n\n\n\na= a+[2] # a = [0,1] + [2]\na\n\n[0, 1, 2]\n\n\n(풀이2) += 이용\n\na=[]\na+=[0]\na+=[1] \na+=[2] \na\n\n[0, 1, 2]\n\n\n\n반복되는 문자를 제거하고 연산의 순서를 바꾼다.\n\n(풀이3) 리스트 특수기능 .append()를 이용\n\na=[] \n\n\na.append(0)\na.append(1)\na.append(2)\na\n\n[0, 1, 2]\n\n\n- 아래는 불가능하다.\n\na.append(0).append(1).append(2)\n\nAttributeError: 'NoneType' object has no attribute 'append'\n\n\n\na.append(0,1,2)\n\nTypeError: append() takes exactly one argument (3 given)"
  },
  {
    "objectID": "posts/04wk-2.html#h.-a4와-a.append4의-차이점은",
    "href": "posts/04wk-2.html#h.-a4와-a.append4의-차이점은",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "H. a+[4]와 a.append(4)의 차이점은?",
    "text": "H. a+[4]와 a.append(4)의 차이점은?\n(관찰1)\n\na=[1,2,3]\na+[4] ## 리스트 a와 리스트 [4]의 연산결과를 알려줘 \n\n[1, 2, 3, 4]\n\n\n\na ## a는 그대로임. 변화없음 \n\n[1, 2, 3]\n\n\n(관찰2)\n\na=[1,2,3]\na.append(4)\n\n\na ## a자체가 변화함 \n\n[1, 2, 3, 4]\n\n\n비슷해보이지만 굉장히 미묘한 차이가 있음\na.append(4): a에 4를 append하라 \\(\\to\\) a가 변함\na+[4]: a와 [4]를 연산하라"
  },
  {
    "objectID": "posts/04wk-2.html#i.-리스트-특수기능",
    "href": "posts/04wk-2.html#i.-리스트-특수기능",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "I. 리스트 특수기능",
    "text": "I. 리스트 특수기능\n(append)\n\na=[1,2,3,4]\na.append?\n\n\nSignature: a.append(object, /)\nDocstring: Append object to the end of the list.\nType:      builtin_function_or_method\n\n\n\n\na.append(5)\na\n\n[1, 2, 3, 4, 5]\n\n\n(clear)\n\na=[1,2,3,4]\na.clear?\n\n\nSignature: a.clear()\nDocstring: Remove all items from list.\nType:      builtin_function_or_method\n\n\n\n\n\na.clear()\na\n\n[]\n\n\n(copy)\n\na=[1,2,3,4]\na.copy?\n\n\nSignature: a.copy()\nDocstring: Return a shallow copy of the list.\nType:      builtin_function_or_method\n\n\n\n\n\nb=a.copy()\nb\n\n[1, 2, 3, 4]\n\n\n(count)\n\na=['a','a','b','b','b','c']\na.count?\n\n\nSignature: a.count(value, /)\nDocstring: Return number of occurrences of value.\nType:      builtin_function_or_method\n\n\n\n\na.count('a')\n\n2\n\n\n\na.count('b')\n\n3\n\n\n\na.count('c')\n\n1\n\n\n(extend)\n\na=[1,2,3,4]\nb=[-1,-2,-3,-4]\n\n\na.extend(b)\na\n\n[1, 2, 3, 4, -1, -2, -3, -4]\n\n\n\na=[1,2,3,4]\nb=[-1,-2,-3,-4]\n\n\na.append(b)\n\n\na\n\n[1, 2, 3, 4, [-1, -2, -3, -4]]\n\n\n(index)\n\na=[11,22,'a',True, 22,'a']\na.index?\n\n\nSignature: a.index(value, start=0, stop=9223372036854775807, /)\nDocstring:\nReturn first index of value.\nRaises ValueError if the value is not present.\nType:      builtin_function_or_method\n\n\n\n\na.index(11)\n\n0\n\n\n\na.index(22)\n\n1\n\n\n\na.index('a')\n\n2\n\n\n\na.index(True)\n\n3\n\n\n(insert)\n\na=[1,2,3]\na.insert?\n\n\nSignature: a.insert(index, object, /)\nDocstring: Insert object before index.\nType:      builtin_function_or_method\n\n\n\n\na.insert(1,88) \na\n\n[1, 88, 2, 3]\n\n\n(pop)\n\na=['a',1,2,'d']\na.pop?\n\n\nSignature: a.pop(index=-1, /)\nDocstring:\nRemove and return item at index (default last).\nRaises IndexError if list is empty or index is out of range.\nType:      builtin_function_or_method\n\n\n\n\na.pop() # index=-1 이므로 마지막원소가 나타남\n\n'd'\n\n\n\na # a는 마지막 원소가 사라진 상태\n\n['a', 1, 2]\n\n\n\na.pop(0) # index=0 이므로 첫번쨰 원소가 나타남\n\n'a'\n\n\n\na # a에는 첫번째 원소가 사라진 상태\n\n[1, 2]\n\n\n(remove)\n\na=['a',2,3,'d']\na.remove?\n\n\nSignature: a.remove(value, /)\nDocstring:\nRemove first occurrence of value.\nRaises ValueError if the value is not present.\nType:      builtin_function_or_method\n\n\n\n\na.remove('d')\n\n\na\n\n['a', 2, 3]\n\n\n\na.remove('a')\n\n\na\n\n[2, 3]\n\n\n(reverse)\n\na=[1,2,3,4]\na.reverse?\n\n\nSignature: a.reverse()\nDocstring: Reverse *IN PLACE*.\nType:      builtin_function_or_method\n\n\n\n\na.reverse()\na\n\n[4, 3, 2, 1]\n\n\n(sort)\n\na=[1,3,2,4]\na.sort?\n\n\nSignature: a.sort(*, key=None, reverse=False)\nDocstring:\nSort the list in ascending order and return None.\nThe sort is in-place (i.e. the list itself is modified) and stable (i.e. the\norder of two equal elements is maintained).\nIf a key function is given, apply it once to each list item and sort them,\nascending or descending, according to their function values.\nThe reverse flag can be set to sort in descending order.\nType:      builtin_function_or_method\n\n\n\n\na.sort()\na\n\n[1, 2, 3, 4]\n\n\n(다른예제들)\n\na=list('guebin')\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na.sort()\na\n\n['b', 'e', 'g', 'i', 'n', 'u']\n\n\n\na.sort(reverse=True)\na\n\n['u', 'n', 'i', 'g', 'e', 'b']"
  },
  {
    "objectID": "posts/04wk-2.html#j.-중첩리스트",
    "href": "posts/04wk-2.html#j.-중첩리스트",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "J. 중첩리스트",
    "text": "J. 중첩리스트\n- 리스트는 리스트를 원소로 받을 수 있으므로 아래와 같이 중첩된 리스트를 만들 수 있다.\n\nA = [[1,2,3],\n     [4,5,6],\n     [7,8,9]]\nA\n\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n- A는 1차원인 벡터가 아니라 2차원인 매트릭스로 이해할 수 있다. 구체적으로는 아래와 같은 매트릭스로 이해할 수 있다\n\\[\\bf{A}=\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{bmatrix}\\]\n- A에서 (2,1)의 원소를 뽑고싶다 = 4를 뽑고싶다\n\nA[1,0] # R에서는 이게 가능했죠\n\nTypeError: list indices must be integers or slices, not tuple\n\n\n\n실패\n\n\nA[1][0]\n\n4\n\n\n\n성공\n\n- 성공의 이유를 분석해보자.\n\nA\n\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n\nA[1]\n\n[4, 5, 6]\n\n\n\nA[1][0]\n\n4\n\n\n- 매트릭스는 아니지만 매트릭스 같음!\n\n1차원 배열을 다차원 배열로 확장할 수 있는 기본 아이디어를 제공함"
  },
  {
    "objectID": "posts/04wk-2.html#k.-리스트-컴프리헨션-연습",
    "href": "posts/04wk-2.html#k.-리스트-컴프리헨션-연습",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "K. 리스트 컴프리헨션 연습",
    "text": "K. 리스트 컴프리헨션 연습\n- 예제1: 리스트 컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['SSSS','PPPP','AAAA','MMMM']\n\n['SSSS', 'PPPP', 'AAAA', 'MMMM']\n\n\n(풀이)\n\n[s*4 for s in 'SPAM']\n\n['SSSS', 'PPPP', 'AAAA', 'MMMM']\n\n\n- 예제2: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['X1','X2','X3','Y1','Y2','Y3']\n\n['X1', 'X2', 'X3', 'Y1', 'Y2', 'Y3']\n\n\n(풀이1)\n\nimport itertools\n\n\n[i+j for i,j in itertools.product('XY','123')]\n\n['X1', 'X2', 'X3', 'Y1', 'Y2', 'Y3']\n\n\n(풀이2)\n\n[i+j for i in 'XY' for j in '123']\n\n['X1', 'X2', 'X3', 'Y1', 'Y2', 'Y3']\n\n\n- 예제: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n(풀이1)\n\n[i+j for i,j in itertools.product(['stat','math'], '123')]\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n(풀이2)\n\n[i+j for i in ['stat','math'] for j in '123']\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n(다른풀이) 비어있는 리스트를 만들고 for문을 쓰면 좀 복잡해진다.\n\nlst = [] \nfor x in ['stat','math']: \n    for y in '123': \n        lst.append(x+y)\nlst\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n\nlst = [] \nfor x in ['stat','math']: \n    for y in '123': \n        lst = lst + [x+y]\nlst\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n- 예제: 리스트컴프리헨션과 문자열 'jbnu'를 이용하여 아래와 같은 리스트를 만들어라.\n\n['j','b','n','u']\n\n['j', 'b', 'n', 'u']\n\n\n(풀이)\n\n[s for s in 'jbnu']\n\n['j', 'b', 'n', 'u']\n\n\n(다른풀이) 아래와 같이 풀면 된다는것은 알고 있음\n\nlist('jbnu')\n\n['j', 'b', 'n', 'u']\n\n\n- 예제: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12']\n\n['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12']\n\n\n(풀이)\n\n['X'+str(i) for i in range(1,13)]\n\n['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12']"
  },
  {
    "objectID": "posts/04wk-2.html#l.-리스트-컴프리헨션과-for문의-미묘한-차이",
    "href": "posts/04wk-2.html#l.-리스트-컴프리헨션과-for문의-미묘한-차이",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "L. 리스트 컴프리헨션과 for문의 미묘한 차이",
    "text": "L. 리스트 컴프리헨션과 for문의 미묘한 차이\n(경우1)\n\nx=777 \nlst = [] \nfor x in 'jbnu': \n    lst = lst + [x]\nlst    \n\n['j', 'b', 'n', 'u']\n\n\n\nx\n\n'u'\n\n\n(경우2)\n\nx=777\nlst = [x for x in 'jbnu'] \nlst \n\n['j', 'b', 'n', 'u']\n\n\n\nx\n\n777\n\n\n\n진짜 미묘하게 다르죠?"
  },
  {
    "objectID": "posts/04wk-2.html#m.-연습문제들",
    "href": "posts/04wk-2.html#m.-연습문제들",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "M. 연습문제들",
    "text": "M. 연습문제들\n# 문제. 길이가 0인 리스트를 만들어라. (비어있는 리스트를 만들어라)\n(풀이1)\n\na = list()\na\n\n[]\n\n\n(풀이2)\n\na = []\na\n\n[]\n\n\n# 문제. 다음의 실행값 중 가장 큰 숫자가 나오는 보기를 골라라. (에러가 나는 코드는 정답에서 제외함)\n(a) len(3.14) \n(b) len([3.14]) \n(c) len('3.14') \n(풀이)\n\nlen(3.14)\n\nTypeError: object of type 'float' has no len()\n\n\n\nlen([3.14])\n\n1\n\n\n\nlen('3.14')\n\n4\n\n\n답은 (c)\n# 문제. 리스트자료형의 +와 * 연산을 이용하여 아래와 같은 list를 생성하라.\n\n[1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]\n\n[1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]\n\n\nhint: 아래의 코드를 관찰해보세요\n\n[1]*1+[2]*2 \n\n[1, 2, 2]\n\n\n(풀이)\n\nlst = []\nfor i in range(1,6):\n    lst = lst + [i]*i\nlst\n\n[1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]\n\n\n# 문제. 다음과 같은 리스트를 고려하자.\n\nx = [80,60,80,90,55,85,95,100,35,70,75,65,95]\nx\n\n[80, 60, 80, 90, 55, 85, 95, 100, 35, 70, 75, 65, 95]\n\n\n이를 수식으로 표현하면 아래와 같다.\n\\({\\bf x} = [x_1,\\dots,x_{13}]=[80,60,80,90,55,85,95,100,35,70,75,65,95]\\)\n리스트의 원소중 “\\(x_i&gt;80\\)” 의 조건을 만족하는 원소는 모두 몇개인가?\n(풀이)\n\nsum(np.array(x)&gt;80)\n\n5\n\n\n\nsum([xi&gt;80 for xi in x])\n\n5\n\n\n# 문제. 다음과 같은 리스트를 고려하자.\n\n['A','B','C','D','A','A','B','A','F','C','C','C','A']\n\n['A', 'B', 'C', 'D', 'A', 'A', 'B', 'A', 'F', 'C', 'C', 'C', 'A']\n\n\n이 리스트에서 ‘A’ 혹은 ’B’의 숫자는 모두 몇개인가?\n(풀이1)\n\nlst = ['A','B','C','D','A','A','B','A','F','C','C','C','A']\nlst.count('A') + lst.count('B')\n\n7\n\n\n(풀이2)\n\nsum([l&lt;'C' for l in lst])\n\n7\n\n\n# 문제. 아래와 같은 문자열이 있다고 하자.\n\ntest_arr = 'ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@mylaptop.local'\n\n이 문자열에서 대문자의 수를 count하라. (2022년 파이썬입문 중간고사 1-(5) 참고)\n(풀이)\n\nsum([s.isupper() for s in test_arr])\n\n155\n\n\n# 문제. 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 생성하라. (2022년 파이썬입문 중간고사 1-(7) 참고)\n['a',\n 'aa',\n 'aaa',\n 'aaaa',\n 'aaaaa',\n 'aaaaaa',\n 'aaaaaaa',\n 'aaaaaaaa',\n 'aaaaaaaaa',\n 'aaaaaaaaaa'] &lt;- a가 10개있음\n(풀이)\n\n['a'*i for i in range(1,11)]\n\n['a',\n 'aa',\n 'aaa',\n 'aaaa',\n 'aaaaa',\n 'aaaaaa',\n 'aaaaaaa',\n 'aaaaaaaa',\n 'aaaaaaaaa',\n 'aaaaaaaaaa']\n\n\n# 문제. 아래와 같은 리스트를 관찰하라.\n\nlst = ['2022/09/21','2022/10/30','2022/12/25','2023/01/01','2023/01/31','2023/03/20']\n\n이러한 리스트를 아래와 같은 리스트로 변환하는 코드를 작성하라.\n\n['2022-09-21', '2022-10-30', '2022-12-25', '2023-01-01', '2023-01-31', '2023-03-20']\n\n['2022-09-21',\n '2022-10-30',\n '2022-12-25',\n '2023-01-01',\n '2023-01-31',\n '2023-03-20']\n\n\nhint: string의 .replace()기능과 리스트 컴프리헨션의 응용\n(풀이)\n\n[l.replace('/','-') for l in lst]\n\n['2022-09-21',\n '2022-10-30',\n '2022-12-25',\n '2023-01-01',\n '2023-01-31',\n '2023-03-20']\n\n\n# 문제. 아래와 같은 문자열을 고려하라.\n\n'2021. 01. 05.'\n\n'2021. 01. 05.'\n\n\n띄어쓰기를 제거하는 코드를 구현하라. 즉 출력결과가 아래와 같도록 만드는 코드를 구현하라.\n\n'2021.01.05'\n\n'2021.01.05'\n\n\n(풀이)\n\n'2021. 01. 05.'.replace(' ','')\n\n'2021.01.05.'\n\n\n# 문제. 아래와 같이 하나의 특수문자로 이루어진 리스트를 고려하자.\n\nblock = ['■'] \n\n이를 이용하여 아래와 같은 결과를 출력하라.\n\n'■-■-■-■-■-■-■-■-■-■' # 여기에서 '■'는 모두 10개 있음\n\n'■-■-■-■-■-■-■-■-■-■'\n\n\n(풀이)\n\n'-'.join(block*10)\n\n'■-■-■-■-■-■-■-■-■-■'"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  }
]