[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "파이썬 프로그래밍 (2024)",
    "section": "",
    "text": "질문하는 방법\n\n이메일: guebin@jbnu.ac.kr\n직접방문: 자연과학대학 본관 205호\nZoom: 이메일로 미리 시간을 정할 것\n카카오톡: http://pf.kakao.com/_txeIFG/chat\n\n강의노트\n\n\n\n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nApr 19, 2024\n\n\n07wk-2: numpy (2)\n\n\n최규빈 \n\n\n\n\nApr 17, 2024\n\n\n07wk-1: 퀴즈4\n\n\n최규빈 \n\n\n\n\nApr 12, 2024\n\n\n06wk-2: numpy (1)\n\n\n최규빈 \n\n\n\n\nApr 5, 2024\n\n\n05wk-2: 파이썬의 자료형 (2)\n\n\n최규빈 \n\n\n\n\nMar 29, 2024\n\n\n04wk-2: 파이썬의 자료형 (1)\n\n\n최규빈 \n\n\n\n\nMar 27, 2024\n\n\n04wk-1: 퀴즈3\n\n\n최규빈 \n\n\n\n\nMar 22, 2024\n\n\n03wk-2: 리스트는 쓰레기인가?\n\n\n최규빈 \n\n\n\n\nMar 20, 2024\n\n\n03wk-1: 퀴즈2\n\n\n최규빈 \n\n\n\n\nMar 15, 2024\n\n\n02wk-2: 파이썬은 좋은 계산기다 (2)\n\n\n최규빈 \n\n\n\n\nMar 13, 2024\n\n\n02wk-1: 퀴즈1\n\n\n최규빈 \n\n\n\n\nMar 8, 2024\n\n\n01wk-2: 파이썬은 좋은 계산기다 (1)\n\n\n최규빈 \n\n\n\n\nMar 6, 2024\n\n\n01wk-1: 강의소개\n\n\n최규빈 \n\n\n\n\nDec 1, 2023\n\n\nA0: Quiz 1 (예상문제)\n\n\n최규빈 \n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/04wk-2.html#a.-사용자가-직접형태변환",
    "href": "posts/04wk-2.html#a.-사용자가-직접형태변환",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "A. 사용자가 직접형태변환",
    "text": "A. 사용자가 직접형태변환\n- 형태변환: float \\(\\to\\) int\n(예시1)\n\na=3.0\ntype(a)\n\nfloat\n\n\n\na=int(a)\n\n\ntype(a)\n\nint\n\n\n(예시2) 이경우는 정보의 손실이 발생\n\na=3.14 \nint(a)\n\n3\n\n\n- 형태변환: int \\(\\to\\) float\n\na=3\ntype(a)\n\nint\n\n\n\na=float(a)\ntype(a)\n\nfloat\n\n\n- 형태변환: bool \\(\\to\\) int/float, int/float \\(\\to\\) bool\n(예시1)\n\na=True\ntype(a)\n\nbool\n\n\n\nint(a)\n\n1\n\n\n\nfloat(a)\n\n1.0\n\n\n(예시2)\n\na=1 \nbool(a)\n\nTrue\n\n\n\na=0\nbool(a)\n\nFalse\n\n\n(예시3)\n\na=1.0\nbool(a)\n\nTrue\n\n\n\na=0.0\nbool(a)\n\nFalse\n\n\n- 이상한 형태변환도 가능하다. (이런것도 바꿔주나 싶은것도 바꿔줌)\n\nbool(-3.14)\n\nTrue\n\n\n\n저는 이런 코드를 의도적으로 사용하지 않아요..\n\n\nint(3.14)\n\n3\n\n\n- 형태변환이 항상가능한것도 아님\n\nfloat(3+0j) # 사실상 3+0j=3 이므로 float으로 형변환하면 3.0이 되어야 할 것 같은데 변환불가능하다. \n\nTypeError: float() argument must be a string or a real number, not 'complex'"
  },
  {
    "objectID": "posts/04wk-2.html#b.-암묵적형변환",
    "href": "posts/04wk-2.html#b.-암묵적형변환",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "B. 암묵적형변환",
    "text": "B. 암묵적형변환\n- 암묵적형변환 (implicit)\n(예비학습) implicit의 의미\n\n추운날씨 -&gt; 보일러좀 틀자! (explicit) / 오늘 날씨 좀 추운 것 같지 않아? (implicit)\n짜장면 먹을래? -&gt; 싫어! (explicit) / 난 어제 짜장면 먹었는데.. (implicit)\n\n(예제)\n\nTrue * 1 # 1을 곱할건데 너 계속 True로 있을꺼야? \n\n1\n\n\n\n1 * 1.0 # 1.0을 곱할건데 너 계속 int로 있을꺼야? \n\n1.0\n\n\n\nTrue+True # +연산을 할건데 계속 True로 있을꺼야? \n\n2"
  },
  {
    "objectID": "posts/04wk-2.html#a.-선언",
    "href": "posts/04wk-2.html#a.-선언",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "A. 선언",
    "text": "A. 선언\n- 예시1\n\na='guebin'\n\n\na\n\n'guebin'\n\n\n- 예시2\n\na=\"guebin\"\n\n\na\n\n'guebin'\n\n\n- 예시3\n\na=\"asdf'a'sdf\"\na\n\n\"asdf'a'sdf\"\n\n\n- 예시4\n\na='asdf\"a\"sdf'\na\n\n'asdf\"a\"sdf'"
  },
  {
    "objectID": "posts/04wk-2.html#b.-연산",
    "href": "posts/04wk-2.html#b.-연산",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "B. 연산",
    "text": "B. 연산\n- 더하기(+)연산\n\na='X'\nb='2'\n\n\nc=a+b\nc\n\n'X2'\n\n\n- 빼기(-)연산\n\na='X2'\nb='2'\na-b\n\nTypeError: unsupported operand type(s) for -: 'str' and 'str'\n\n\n\n이런건 없다.\n\n- 곱하기(*)연산\n\na='X'\n\n\na+a+a\n\n'XXX'\n\n\n\na*3 # a*3 = a+a+a = 'X'+'X+'X'\n\n'XXX'\n\n\n아래도 가능하다.\n\n3*a\n\n'XXX'\n\n\n그리고 아래도 가능하다.\n\na='X'\nb=3 \na*b\n\n'XXX'\n\n\n대신에 의미상 맞지 않는 것은 수행되지 않고 에러가 난다.\n\na='X'\nb='Y'\na+b\n\n'XY'\n\n\n\na*b\n\nTypeError: can't multiply sequence by non-int of type 'str'\n\n\n- 나눗셈(/)연산\n\n2*'X'\n\n'XX'\n\n\n\na='XX'\n\n\na/2\n\nTypeError: unsupported operand type(s) for /: 'str' and 'int'\n\n\n\n이런건 없다.."
  },
  {
    "objectID": "posts/04wk-2.html#c.-인덱싱",
    "href": "posts/04wk-2.html#c.-인덱싱",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "C. 인덱싱",
    "text": "C. 인덱싱\n- str은 하나의 벡터 문자가 여러개 있는 형태라고 생각하면 된다.\n\na='guebin'\n\n\na\n\n'guebin'\n\n\n\n6개의 칸에 글씨가 하나씩 들어가 있음.\n\n- 대괄호 []안에 숫자를 넣는 방식으로 벡터의 원소를 호출할 수 있다. (주의: 인덱스가 0부터 시작함)\n\na[0] #첫번째원소\n\n'g'\n\n\n\na[1] #두번째원소 \n\n'u'\n\n\n마지막원소는 -1로 호출할 수도 있다.\n\na[-1]\n\n'n'\n\n\n마지막에서 2번째 원소는 -2로 호출가능하다.\n\na[-2]\n\n'i'\n\n\n- 요약하면 아래와 같은 방식으로 호출가능함.\n\n\n\ng\nu\ne\nb\ni\nn\n\n\n\n\n0\n1\n2\n3\n4\n5\n\n\n0\n-5\n-4\n-3\n-2\n-1\n\n\n\n\na[4]\n\n'i'\n\n\n\na[-2]\n\n'i'\n\n\n\na[-4]\n\n'e'\n\n\n- :을 이용하여 여러개의 원소를 호출할 수 있음.\n\na='guebin'\n\n\na[0:3] # a[0],a[1],a[2],a[3]이 아니라 a[0],a[1],a[2]까지만 뽑힌다. 즉 마지막의 3은 호출되지 않는다. \n\n'gue'\n\n\n\na[1:3] # a[1], a[2] 만 호출 // start=1,  stop=3 \n\n'ue'\n\n\nindex=1부터 시작해서 마지막원소까지 호출하려면?\n\na='guebin'\n\n\na[5] # guebin의 마지막원소 'n'이 출려 \n\n'n'\n\n\n\na[1:5] # 5는 포함되지 않으므로 틀림\n\n'uebi'\n\n\n\na[1:6] # 정답\n\n'uebin'\n\n\n안 헷갈리는 방법은 없을까? 생략한다.\n\na[1:]\n\n'uebin'\n\n\n- 생략의 응용1\n\na='k-pop' \na\n\n'k-pop'\n\n\n\na[2:]\n\n'pop'\n\n\n- 생략의 응용2\n\na='k-pop'\na\n\n'k-pop'\n\n\n\n0,1 -&gt; 0,1,2\n\n\na[0:2] # a[0],a[1]\n\n'k-'\n\n\n\na[:2] # a[0],a[1] \n\n'k-'\n\n\n\na[:2] 는 a의 원소중 처음 2개를 뽑는다는 의미\n\n- 생략의 응용3\n\na='k-pop'\na\n\n'k-pop'\n\n\n\na[0:5] # a[0],...,a[4]\n\n'k-pop'\n\n\n\na[:]\n\n'k-pop'"
  },
  {
    "objectID": "posts/04wk-2.html#d.-str-특수기능",
    "href": "posts/04wk-2.html#d.-str-특수기능",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "D. str 특수기능",
    "text": "D. str 특수기능\n- 파이썬의 변수는 단순히 정보를 담는 그릇이 아니다. 유용한 기능을 제공하는 경우가 있다.\n\na='ABCD' # a라는 변수는 'ABCD'라는 정보를 담는 그릇의 역할만 하지 않고, 특화된 어떠한 기능도 제공한다. \na\n\n'ABCD'\n\n\n\na.lower() # a.lower()를 쓰면 a의 모든 문자를 소문자로 바꾸는 기능을 제공, lower(a)라고 읽자!\n\n'abcd'\n\n\n여기에서 lower()는 문자열에 특화된 기능임. 따라서 당연히 아래는 불가능\n\na=3.14\na.lower() # lower(a)\n\nAttributeError: 'float' object has no attribute 'lower'\n\n\n- 자료형에 특화된 기능(=함수)을 확인하는 방법? a.+ tab 으로 목록 확인 가능\n\na='guebin'\n\n\na.upper?\n\n\nSignature: a.upper()\nDocstring: Return a copy of the string converted to uppercase.\nType:      builtin_function_or_method\n\n\n\n\na.upper() # upper(a) \n\n'GUEBIN'\n\n\n\na.capitalize() # capitalize(a) \n\n'Guebin'\n\n\n- 유용한 특수기능 \\((\\star\\star\\star)\\)\n\n'-'.join(['1','2','3'])\n\n'1-2-3'\n\n\n\n'1-2-3'.split('-')\n\n['1', '2', '3']\n\n\n\n'1-2-3'.replace('-','*')\n\n'1*2*3'"
  },
  {
    "objectID": "posts/04wk-2.html#e.-len",
    "href": "posts/04wk-2.html#e.-len",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "E. len",
    "text": "E. len\n- len함수 소개: 원소의 갯수를 알려주는 함수.\n\na='ABCD' \nlen(a)\n\n4\n\n\n- 참고: len은 0차원 변수형에서는 동작하지 않고 1차원 변수형에서만 동작한다.\n(0차원) len 함수가 동작하지 않음.\n\na=3.14\n\n\nlen(a)\n\nTypeError: object of type 'float' has no len()\n\n\n\nb=True\n\n\nlen(b)\n\nTypeError: object of type 'bool' has no len()\n\n\n(1차원) len 함수가 잘 동작함.\n\na='3.14'\nlen(a)\n\n4\n\n\n\nb=[1,2,3]\n\n\nlen(b)\n\n3"
  },
  {
    "objectID": "posts/04wk-2.html#f.-fstring",
    "href": "posts/04wk-2.html#f.-fstring",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "F. fstring",
    "text": "F. fstring\n- 예제1\n\na=1\nb=2\nprint(f'a+b = {a+b}')\n\na+b = 3\n\n\n- 예제2\n\na=2\nb=3.141592\nprint(f'a*b = {a*b:.2f}')\n\na*b = 6.28\n\n\n- 예제3\n\na=3.141592\nprint(f'2a = {2*a:.2f}\\t3a = {3*a:.2f}')\n\n2a = 6.28   3a = 9.42\n\n\n- 예제4\n\nlst = ['장하니','최다호','주성재','이슬기']\n\n\n[f'{l}학생 안녕하세요, 통계학과 최규빈 교수입니다. 다름이 아니라 전공진로설계관련 상담일자를 잡고자 메일을 보냈습니다.' for l in lst]\n\n['장하니학생 안녕하세요, 통계학과 최규빈 교수입니다. 다름이 아니라 전공진로설계관련 상담일자를 잡고자 메일을 보냈습니다.',\n '최다호학생 안녕하세요, 통계학과 최규빈 교수입니다. 다름이 아니라 전공진로설계관련 상담일자를 잡고자 메일을 보냈습니다.',\n '주성재학생 안녕하세요, 통계학과 최규빈 교수입니다. 다름이 아니라 전공진로설계관련 상담일자를 잡고자 메일을 보냈습니다.',\n '이슬기학생 안녕하세요, 통계학과 최규빈 교수입니다. 다름이 아니라 전공진로설계관련 상담일자를 잡고자 메일을 보냈습니다.']"
  },
  {
    "objectID": "posts/04wk-2.html#g.-string과-for문",
    "href": "posts/04wk-2.html#g.-string과-for문",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "G. string과 for문",
    "text": "G. string과 for문\n- 예제1\n\nfor s in 'jbnu':\n    print(2*s)\n\njj\nbb\nnn\nuu\n\n\n- 예제2\n\n[s*4 for s in 'jbnu']\n\n['jjjj', 'bbbb', 'nnnn', 'uuuu']"
  },
  {
    "objectID": "posts/04wk-2.html#h.-in-연산자",
    "href": "posts/04wk-2.html#h.-in-연산자",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "H. in 연산자",
    "text": "H. in 연산자\n\ns = 'jbnu'\n\n\n'b' in s\n\nTrue\n\n\n\n'c' in s\n\nFalse\n\n\n\n'jb' in s\n\nTrue\n\n\n\n'jn' in s\n\nFalse"
  },
  {
    "objectID": "posts/04wk-2.html#i.-연습문제들",
    "href": "posts/04wk-2.html#i.-연습문제들",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "I. 연습문제들",
    "text": "I. 연습문제들\n전북대학교 – 아래와 같은 문자열이 있다고 하자.\n\na='Jeonbuk National University' \n\n# 문제. 적당한 인덱싱을 통하여 출력결과가 아래와 같도록 하라.\n\n# 적당한 인덱싱\n\n'University'\n\n\nhint: University는 10글자이다.\n(풀이)\n\na[-10:]\n\n'University'\n\n\n# 문제. 출력결과가 아래와 같도록 하는 코드를 작성하라. (lower 함수를 이용할 것)\n\n# 적당한 코드 \n\n'jeonbuk national university'\n\n\n(풀이)\n\na.lower()\n\n'jeonbuk national university'\n\n\n# 문제. 아래의 코드를 관찰하고 isupper()의 기능이 무엇인지 스스로 정리해보라.\n\n'A'.isupper()\n\nTrue\n\n\n\n'AA'.isupper()\n\nTrue\n\n\n\n'Aa'.isupper()\n\nFalse\n\n\n\n'aa'.isupper()\n\nFalse\n\n\n\n'aA'.isupper()\n\nFalse\n\n\n유추한 기능이 맞는지 ChatGPT를 통하여 확인하라.\nDitto – 다음은 인터넷에서 긁어온 어떠한 텍스트이다.\n\ntext = \"국내뿐 아니라 해외 인기도 심상치 않다. 2023년 1월 18일 'Ditto'가 빌보드 핫 100에 96위로 진입했다. 이는 K-pop 역사상 데뷔후 최단 빌보드 Hot 100 차트 입성 기록이다. 다른 뮤지션들이 보통 데뷔 후 수년간 쌓아온 팬덤을 기반으로 빌보드에 입성한데 비해, 뉴진스의 기록은 이례적인 것으로 평가받고 있다. 또한 'OMG'가 빌보드 핫 100에 91위로 진입한 동시에 'Ditto'는 85위로 순위가 상승, 핫 100 주간차트에 두 곡을 올려놓았다. K-Pop 역사상 이 차트에 두 곡 이상을 진입시킨 아티스트는 방탄소년단과 블랙핑크가 유일하다. 'Ditto'는 1월 셋째주 기준, 빌보드뿐만 아니라 영국 오피셜 싱글 차트 '톱 100'에 2주 연속 진입하기도 했다.\"\n\n# 문제. text는 총 몇개의 문장으로 이루어져 있는가?\nhint: 이 텍스트의 문장은 모두 .로 끝난다.\n(풀이)\n\nlen(text.split('. '))\n\n7\n\n\n# 문제. 각 문장은 몇개의 단어로 이루어져 있는가?\nhint: 각 단어는 공백으로 구분된다.\n(풀이)\n\nlst = text.split('. ')\n[len(l.split(' ')) for l in lst]\n\n[6, 9, 11, 18, 18, 12, 16]\n\n\n# 문제. 100이라는 단어가 포함된 문장은 모두 몇 개 인가?\nhint: 아래의 코드를 관찰\n\n'a' in 'abcd'\n\nTrue\n\n\n(풀이)\n\nsum(['100' in l for l in lst])\n\n4"
  },
  {
    "objectID": "posts/04wk-2.html#a.-선언-1",
    "href": "posts/04wk-2.html#a.-선언-1",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "A. 선언",
    "text": "A. 선언\n- 리스트의 선언\n\na= [1,2,3,22] \n\n- 비어있는 리스트의 선언\n\na= []\na\n\n[]\n\n\n\na= list()\na\n\n[]"
  },
  {
    "objectID": "posts/04wk-2.html#b.-연산-1",
    "href": "posts/04wk-2.html#b.-연산-1",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "B. 연산",
    "text": "B. 연산\n- 더하기연산\n\n[1,2,3] + [-3,4,5]\n\n[1, 2, 3, -3, 4, 5]\n\n\n\n우리의 예상과 다른 결과가 나옴 \\(\\to\\) 파이썬은 R처럼 자체적으로 좋은 계산기능을 내장하고 있지 않음.\n\n- 브로드캐스팅과 같이 R에서는 당연히 가능했던 기능을 사용할 수 없음.\n\n[1,2,3,4,5] + 1 \n\nTypeError: can only concatenate list (not \"int\") to list\n\n\n- 뺄셈은 정의되지 않음\n\na= [1,2,1,2]\na-[1,2]\n\nTypeError: unsupported operand type(s) for -: 'list' and 'list'\n\n\n- 곱하기는 정의가능\n\n[1,2]*3\n\n[1, 2, 1, 2, 1, 2]\n\n\n- 나눗셈은 정의되지 않음\n\n[1,2,1,2,1,2] /3\n\nTypeError: unsupported operand type(s) for /: 'list' and 'int'\n\n\n- 더하기와 곱하기는 원소의 추가와 반복추가를 의미하지만 그렇다고 해서 뺄셈과 나눗셈이 원소의 삭제를 의미하는것은 아님\n- 더하기와 곱하기가 원소의 추가와 반복추가를 의미하여 편리할때도 있긴하지만, 우리는 산술적인 +, * 를 원하는 경우도 있다. 이럴 경우는 어떻게 할 수 있을까?\n(예제)\n\na=[1,2]\nb=[3,4]\n\na+b = [4,6] 이 되도록 하려면?\n(풀이1)\n\n[a[0]+b[0],a[1]+b[1]]\n\n[4, 6]\n\n\n풀이가 가능한 이유? a,b는 리스트이지만 a[0], a[1], b[0], b[1] 은 각각 인트형임. 인트형은 + 연산이 가능했음.\n(풀이2)\nnumpy 패키지 (파이썬의 여러 수치연산들을 담당하는 라이브러리)\n\n이러한 벡터연산은 누구나 필요로 하는 연산임.\n내가 아니더라도 누군가가 프로그램화 해놓았을 것임.\n그 누군가가 자신이 만든 코드를 잘 정리하여 무료로 배포했을 수도 있음. (패키지를 배포한다고 표현)\n그 패키지를 우리는 가져와서 설치한뒤 사용하기만 하면된다.\n\n설치된 패키지를 사용하는 방법\n\nimport numpy 한뒤에 numpy.??로 기능을 사용\nimport numpy as np 한뒤에 np.??로 기능을 사용\n\n\nimport numpy \n\n\na=[1,2]\nb=[3,4]\n\n\naa = numpy.array(a)\nbb = numpy.array(b)\n\n\naa+bb\n\narray([4, 6])\n\n\n여러가지 연산 가능 (마치 R처럼 쓸 수 있음)\n\n2*aa\n\narray([2, 4])\n\n\n\n2*aa+1\n\narray([3, 5])\n\n\n\n2*aa+1+bb\n\narray([6, 9])\n\n\n(풀이3)\n\nimport numpy as np ## 설치가 되어있는 numpy라는 패키지를 쓰겠음. 그런데 numpy말고 np라는 이름으로 쓰겠음\n\n\nnp.array(a)+np.array(b)\n\narray([4, 6])"
  },
  {
    "objectID": "posts/04wk-2.html#c.-인덱싱-1",
    "href": "posts/04wk-2.html#c.-인덱싱-1",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "C. 인덱싱",
    "text": "C. 인덱싱\n- str형과 동일한 방식\n\na=[11,22,33,44,55] # 0 -4 -3 -2 -1\n\n\na[-2:] # 끝의 2개의 원소를 뽑음 \n\n[44, 55]"
  },
  {
    "objectID": "posts/04wk-2.html#d.-콘테이너형-객체로서의-리스트",
    "href": "posts/04wk-2.html#d.-콘테이너형-객체로서의-리스트",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "D. 콘테이너형 객체로서의 리스트",
    "text": "D. 콘테이너형 객체로서의 리스트\n- 리스트의 원소는 int, float 따위만 가능한 것이 아니다. (리스트는 컨테이너형 객체이므로)\n\nlst = [1,3.14,True,'a',[1,2], \n       (1,2),{'name':'iu','age':27},{1,2,3}]\nlst\n\n[1, 3.14, True, 'a', [1, 2], (1, 2), {'name': 'iu', 'age': 27}, {1, 2, 3}]\n\n\n\n[type(l) for l in lst]\n\n[int, float, bool, str, list, tuple, dict, set]\n\n\n- str은 컨테이너형이 아니다.\n\n'abcd'[2]\n\n'c'\n\n\n\nstr의 모든 원소는 문자임"
  },
  {
    "objectID": "posts/04wk-2.html#e.-가변객체",
    "href": "posts/04wk-2.html#e.-가변객체",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "E. 가변객체",
    "text": "E. 가변객체\n- 리스트는 원소를 수정할 수 있다. (리스트는 가변객체이므로)\n\na=[11,22,33]\na\n\n[11, 22, 33]\n\n\n\na[0] = -77\n\n\na\n\n[-77, 22, 33]\n\n\n- 원소수정은 당연한 기능같은데 이것이 불가능한 경우도 있다.\n(가능한경우)\n\na=['g','u','e','b','i','n']\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na[0] = 'G'\n\n\na\n\n['G', 'u', 'e', 'b', 'i', 'n']\n\n\n(불가능한경우)\n\na='guebin'\na\n\n'guebin'\n\n\n\na[0]\n\n'g'\n\n\n\na[0]='G'\n\nTypeError: 'str' object does not support item assignment"
  },
  {
    "objectID": "posts/04wk-2.html#f.-리스트의-원소-삭제",
    "href": "posts/04wk-2.html#f.-리스트의-원소-삭제",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "F. 리스트의 원소 삭제",
    "text": "F. 리스트의 원소 삭제\n(예제1) del을 이용한 원소삭제\n아래와 같이 문자로 된 리스트를 선언하자.\n\na=['g','u','e','b','i','n']\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n사실 더 쉽게 선언할 수 있음\n\nlist('guebin')\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n첫번째 원소를 삭제하고 싶다면?\n\ndel a[0]\na\n\n['u', 'e', 'b', 'i', 'n']\n\n\n이 상태에서 다시 첫번째 원소를 삭제한다면?\n\ndel a[0]\na\n\n['e', 'b', 'i', 'n']\n\n\n(예제2) pop을 이용한 원소삭제\n\na=list('guebin')\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na.pop(0)\n\n'g'\n\n\n\na.pop(0)\n\n'u'\n\n\n\na\n\n['e', 'b', 'i', 'n']\n\n\n(예제3) remove를 이용한 원소삭제\n\na=list('guebin')\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na.remove('b')\na\n\n['g', 'u', 'e', 'i', 'n']"
  },
  {
    "objectID": "posts/04wk-2.html#g.-리스트-원소-추가",
    "href": "posts/04wk-2.html#g.-리스트-원소-추가",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "G. 리스트 원소 추가",
    "text": "G. 리스트 원소 추가\n(예제) 비어있는 리스트를 만들고 원소 0,1,2를 차례로 추가하여 보자.\n(풀이1) + 연산이용\n\na=[]\na\n\n[]\n\n\n\na= a+[0]\na\n\n[0]\n\n\n\na= a+[1] # a = [0]+[1]\na\n\n[0, 1]\n\n\n\na= a+[2] # a = [0,1] + [2]\na\n\n[0, 1, 2]\n\n\n(풀이2) += 이용\n\na=[]\na+=[0]\na+=[1] \na+=[2] \na\n\n[0, 1, 2]\n\n\n\n반복되는 문자를 제거하고 연산의 순서를 바꾼다.\n\n(풀이3) 리스트 특수기능 .append()를 이용\n\na=[] \n\n\na.append(0)\na.append(1)\na.append(2)\na\n\n[0, 1, 2]\n\n\n- 아래는 불가능하다.\n\na.append(0).append(1).append(2)\n\nAttributeError: 'NoneType' object has no attribute 'append'\n\n\n\na.append(0,1,2)\n\nTypeError: append() takes exactly one argument (3 given)"
  },
  {
    "objectID": "posts/04wk-2.html#h.-a4와-a.append4의-차이점은",
    "href": "posts/04wk-2.html#h.-a4와-a.append4의-차이점은",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "H. a+[4]와 a.append(4)의 차이점은?",
    "text": "H. a+[4]와 a.append(4)의 차이점은?\n(관찰1)\n\na=[1,2,3]\na+[4] ## 리스트 a와 리스트 [4]의 연산결과를 알려줘 \n\n[1, 2, 3, 4]\n\n\n\na ## a는 그대로임. 변화없음 \n\n[1, 2, 3]\n\n\n(관찰2)\n\na=[1,2,3]\na.append(4)\n\n\na ## a자체가 변화함 \n\n[1, 2, 3, 4]\n\n\n비슷해보이지만 굉장히 미묘한 차이가 있음\na.append(4): a에 4를 append하라 \\(\\to\\) a가 변함\na+[4]: a와 [4]를 연산하라"
  },
  {
    "objectID": "posts/04wk-2.html#i.-리스트-특수기능",
    "href": "posts/04wk-2.html#i.-리스트-특수기능",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "I. 리스트 특수기능",
    "text": "I. 리스트 특수기능\n(append)\n\na=[1,2,3,4]\na.append?\n\n\nSignature: a.append(object, /)\nDocstring: Append object to the end of the list.\nType:      builtin_function_or_method\n\n\n\n\na.append(5)\na\n\n[1, 2, 3, 4, 5]\n\n\n(clear)\n\na=[1,2,3,4]\na.clear?\n\n\nSignature: a.clear()\nDocstring: Remove all items from list.\nType:      builtin_function_or_method\n\n\n\n\n\na.clear()\na\n\n[]\n\n\n(copy)\n\na=[1,2,3,4]\na.copy?\n\n\nSignature: a.copy()\nDocstring: Return a shallow copy of the list.\nType:      builtin_function_or_method\n\n\n\n\n\nb=a.copy()\nb\n\n[1, 2, 3, 4]\n\n\n(count)\n\na=['a','a','b','b','b','c']\na.count?\n\n\nSignature: a.count(value, /)\nDocstring: Return number of occurrences of value.\nType:      builtin_function_or_method\n\n\n\n\na.count('a')\n\n2\n\n\n\na.count('b')\n\n3\n\n\n\na.count('c')\n\n1\n\n\n(extend)\n\na=[1,2,3,4]\nb=[-1,-2,-3,-4]\n\n\na.extend(b)\na\n\n[1, 2, 3, 4, -1, -2, -3, -4]\n\n\n\na=[1,2,3,4]\nb=[-1,-2,-3,-4]\n\n\na.append(b)\n\n\na\n\n[1, 2, 3, 4, [-1, -2, -3, -4]]\n\n\n(index)\n\na=[11,22,'a',True, 22,'a']\na.index?\n\n\nSignature: a.index(value, start=0, stop=9223372036854775807, /)\nDocstring:\nReturn first index of value.\nRaises ValueError if the value is not present.\nType:      builtin_function_or_method\n\n\n\n\na.index(11)\n\n0\n\n\n\na.index(22)\n\n1\n\n\n\na.index('a')\n\n2\n\n\n\na.index(True)\n\n3\n\n\n(insert)\n\na=[1,2,3]\na.insert?\n\n\nSignature: a.insert(index, object, /)\nDocstring: Insert object before index.\nType:      builtin_function_or_method\n\n\n\n\na.insert(1,88) \na\n\n[1, 88, 2, 3]\n\n\n(pop)\n\na=['a',1,2,'d']\na.pop?\n\n\nSignature: a.pop(index=-1, /)\nDocstring:\nRemove and return item at index (default last).\nRaises IndexError if list is empty or index is out of range.\nType:      builtin_function_or_method\n\n\n\n\na.pop() # index=-1 이므로 마지막원소가 나타남\n\n'd'\n\n\n\na # a는 마지막 원소가 사라진 상태\n\n['a', 1, 2]\n\n\n\na.pop(0) # index=0 이므로 첫번쨰 원소가 나타남\n\n'a'\n\n\n\na # a에는 첫번째 원소가 사라진 상태\n\n[1, 2]\n\n\n(remove)\n\na=['a',2,3,'d']\na.remove?\n\n\nSignature: a.remove(value, /)\nDocstring:\nRemove first occurrence of value.\nRaises ValueError if the value is not present.\nType:      builtin_function_or_method\n\n\n\n\na.remove('d')\n\n\na\n\n['a', 2, 3]\n\n\n\na.remove('a')\n\n\na\n\n[2, 3]\n\n\n(reverse)\n\na=[1,2,3,4]\na.reverse?\n\n\nSignature: a.reverse()\nDocstring: Reverse *IN PLACE*.\nType:      builtin_function_or_method\n\n\n\n\na.reverse()\na\n\n[4, 3, 2, 1]\n\n\n(sort)\n\na=[1,3,2,4]\na.sort?\n\n\nSignature: a.sort(*, key=None, reverse=False)\nDocstring:\nSort the list in ascending order and return None.\nThe sort is in-place (i.e. the list itself is modified) and stable (i.e. the\norder of two equal elements is maintained).\nIf a key function is given, apply it once to each list item and sort them,\nascending or descending, according to their function values.\nThe reverse flag can be set to sort in descending order.\nType:      builtin_function_or_method\n\n\n\n\na.sort()\na\n\n[1, 2, 3, 4]\n\n\n(다른예제들)\n\na=list('guebin')\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na.sort()\na\n\n['b', 'e', 'g', 'i', 'n', 'u']\n\n\n\na.sort(reverse=True)\na\n\n['u', 'n', 'i', 'g', 'e', 'b']"
  },
  {
    "objectID": "posts/04wk-2.html#j.-중첩리스트",
    "href": "posts/04wk-2.html#j.-중첩리스트",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "J. 중첩리스트",
    "text": "J. 중첩리스트\n- 리스트는 리스트를 원소로 받을 수 있으므로 아래와 같이 중첩된 리스트를 만들 수 있다.\n\nA = [[1,2,3],\n     [4,5,6],\n     [7,8,9]]\nA\n\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n- A는 1차원인 벡터가 아니라 2차원인 매트릭스로 이해할 수 있다. 구체적으로는 아래와 같은 매트릭스로 이해할 수 있다\n\\[\\bf{A}=\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{bmatrix}\\]\n- A에서 (2,1)의 원소를 뽑고싶다 = 4를 뽑고싶다\n\nA[1,0] # R에서는 이게 가능했죠\n\nTypeError: list indices must be integers or slices, not tuple\n\n\n\n실패\n\n\nA[1][0]\n\n4\n\n\n\n성공\n\n- 성공의 이유를 분석해보자.\n\nA\n\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n\nA[1]\n\n[4, 5, 6]\n\n\n\nA[1][0]\n\n4\n\n\n- 매트릭스는 아니지만 매트릭스 같음!\n\n1차원 배열을 다차원 배열로 확장할 수 있는 기본 아이디어를 제공함"
  },
  {
    "objectID": "posts/04wk-2.html#k.-리스트-컴프리헨션-연습",
    "href": "posts/04wk-2.html#k.-리스트-컴프리헨션-연습",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "K. 리스트 컴프리헨션 연습",
    "text": "K. 리스트 컴프리헨션 연습\n- 예제1: 리스트 컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['SSSS','PPPP','AAAA','MMMM']\n\n['SSSS', 'PPPP', 'AAAA', 'MMMM']\n\n\n(풀이)\n\n[s*4 for s in 'SPAM']\n\n['SSSS', 'PPPP', 'AAAA', 'MMMM']\n\n\n- 예제2: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['X1','X2','X3','Y1','Y2','Y3']\n\n['X1', 'X2', 'X3', 'Y1', 'Y2', 'Y3']\n\n\n(풀이1)\n\nimport itertools\n\n\n[i+j for i,j in itertools.product('XY','123')]\n\n['X1', 'X2', 'X3', 'Y1', 'Y2', 'Y3']\n\n\n(풀이2)\n\n[i+j for i in 'XY' for j in '123']\n\n['X1', 'X2', 'X3', 'Y1', 'Y2', 'Y3']\n\n\n- 예제: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n(풀이1)\n\n[i+j for i,j in itertools.product(['stat','math'], '123')]\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n(풀이2)\n\n[i+j for i in ['stat','math'] for j in '123']\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n(다른풀이) 비어있는 리스트를 만들고 for문을 쓰면 좀 복잡해진다.\n\nlst = [] \nfor x in ['stat','math']: \n    for y in '123': \n        lst.append(x+y)\nlst\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n\nlst = [] \nfor x in ['stat','math']: \n    for y in '123': \n        lst = lst + [x+y]\nlst\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n- 예제: 리스트컴프리헨션과 문자열 'jbnu'를 이용하여 아래와 같은 리스트를 만들어라.\n\n['j','b','n','u']\n\n['j', 'b', 'n', 'u']\n\n\n(풀이)\n\n[s for s in 'jbnu']\n\n['j', 'b', 'n', 'u']\n\n\n(다른풀이) 아래와 같이 풀면 된다는것은 알고 있음\n\nlist('jbnu')\n\n['j', 'b', 'n', 'u']\n\n\n- 예제: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12']\n\n['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12']\n\n\n(풀이)\n\n['X'+str(i) for i in range(1,13)]\n\n['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12']"
  },
  {
    "objectID": "posts/04wk-2.html#l.-리스트-컴프리헨션과-for문의-미묘한-차이",
    "href": "posts/04wk-2.html#l.-리스트-컴프리헨션과-for문의-미묘한-차이",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "L. 리스트 컴프리헨션과 for문의 미묘한 차이",
    "text": "L. 리스트 컴프리헨션과 for문의 미묘한 차이\n(경우1)\n\nx=777 \nlst = [] \nfor x in 'jbnu': \n    lst = lst + [x]\nlst    \n\n['j', 'b', 'n', 'u']\n\n\n\nx\n\n'u'\n\n\n(경우2)\n\nx=777\nlst = [x for x in 'jbnu'] \nlst \n\n['j', 'b', 'n', 'u']\n\n\n\nx\n\n777\n\n\n\n진짜 미묘하게 다르죠?"
  },
  {
    "objectID": "posts/04wk-2.html#m.-연습문제들",
    "href": "posts/04wk-2.html#m.-연습문제들",
    "title": "04wk-2: 파이썬의 자료형 (1)",
    "section": "M. 연습문제들",
    "text": "M. 연습문제들\n# 문제. 길이가 0인 리스트를 만들어라. (비어있는 리스트를 만들어라)\n(풀이1)\n\na = list()\na\n\n[]\n\n\n(풀이2)\n\na = []\na\n\n[]\n\n\n# 문제. 다음의 실행값 중 가장 큰 숫자가 나오는 보기를 골라라. (에러가 나는 코드는 정답에서 제외함)\n(a) len(3.14) \n(b) len([3.14]) \n(c) len('3.14') \n(풀이)\n\nlen(3.14)\n\nTypeError: object of type 'float' has no len()\n\n\n\nlen([3.14])\n\n1\n\n\n\nlen('3.14')\n\n4\n\n\n답은 (c)\n# 문제. 리스트자료형의 +와 * 연산을 이용하여 아래와 같은 list를 생성하라.\n\n[1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]\n\n[1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]\n\n\nhint: 아래의 코드를 관찰해보세요\n\n[1]*1+[2]*2 \n\n[1, 2, 2]\n\n\n(풀이)\n\nlst = []\nfor i in range(1,6):\n    lst = lst + [i]*i\nlst\n\n[1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]\n\n\n# 문제. 다음과 같은 리스트를 고려하자.\n\nx = [80,60,80,90,55,85,95,100,35,70,75,65,95]\nx\n\n[80, 60, 80, 90, 55, 85, 95, 100, 35, 70, 75, 65, 95]\n\n\n이를 수식으로 표현하면 아래와 같다.\n\\({\\bf x} = [x_1,\\dots,x_{13}]=[80,60,80,90,55,85,95,100,35,70,75,65,95]\\)\n리스트의 원소중 “\\(x_i&gt;80\\)” 의 조건을 만족하는 원소는 모두 몇개인가?\n(풀이)\n\nsum(np.array(x)&gt;80)\n\n5\n\n\n\nsum([xi&gt;80 for xi in x])\n\n5\n\n\n# 문제. 다음과 같은 리스트를 고려하자.\n\n['A','B','C','D','A','A','B','A','F','C','C','C','A']\n\n['A', 'B', 'C', 'D', 'A', 'A', 'B', 'A', 'F', 'C', 'C', 'C', 'A']\n\n\n이 리스트에서 ‘A’ 혹은 ’B’의 숫자는 모두 몇개인가?\n(풀이1)\n\nlst = ['A','B','C','D','A','A','B','A','F','C','C','C','A']\nlst.count('A') + lst.count('B')\n\n7\n\n\n(풀이2)\n\nsum([l&lt;'C' for l in lst])\n\n7\n\n\n# 문제. 아래와 같은 문자열이 있다고 하자.\n\ntest_arr = 'ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@mylaptop.local'\n\n이 문자열에서 대문자의 수를 count하라. (2022년 파이썬입문 중간고사 1-(5) 참고)\n(풀이)\n\nsum([s.isupper() for s in test_arr])\n\n155\n\n\n# 문제. 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 생성하라. (2022년 파이썬입문 중간고사 1-(7) 참고)\n['a',\n 'aa',\n 'aaa',\n 'aaaa',\n 'aaaaa',\n 'aaaaaa',\n 'aaaaaaa',\n 'aaaaaaaa',\n 'aaaaaaaaa',\n 'aaaaaaaaaa'] &lt;- a가 10개있음\n(풀이)\n\n['a'*i for i in range(1,11)]\n\n['a',\n 'aa',\n 'aaa',\n 'aaaa',\n 'aaaaa',\n 'aaaaaa',\n 'aaaaaaa',\n 'aaaaaaaa',\n 'aaaaaaaaa',\n 'aaaaaaaaaa']\n\n\n# 문제. 아래와 같은 리스트를 관찰하라.\n\nlst = ['2022/09/21','2022/10/30','2022/12/25','2023/01/01','2023/01/31','2023/03/20']\n\n이러한 리스트를 아래와 같은 리스트로 변환하는 코드를 작성하라.\n\n['2022-09-21', '2022-10-30', '2022-12-25', '2023-01-01', '2023-01-31', '2023-03-20']\n\n['2022-09-21',\n '2022-10-30',\n '2022-12-25',\n '2023-01-01',\n '2023-01-31',\n '2023-03-20']\n\n\nhint: string의 .replace()기능과 리스트 컴프리헨션의 응용\n(풀이)\n\n[l.replace('/','-') for l in lst]\n\n['2022-09-21',\n '2022-10-30',\n '2022-12-25',\n '2023-01-01',\n '2023-01-31',\n '2023-03-20']\n\n\n# 문제. 아래와 같은 문자열을 고려하라.\n\n'2021. 01. 05.'\n\n'2021. 01. 05.'\n\n\n띄어쓰기를 제거하는 코드를 구현하라. 즉 출력결과가 아래와 같도록 만드는 코드를 구현하라.\n\n'2021.01.05'\n\n'2021.01.05'\n\n\n(풀이)\n\n'2021. 01. 05.'.replace(' ','')\n\n'2021.01.05.'\n\n\n# 문제. 아래와 같이 하나의 특수문자로 이루어진 리스트를 고려하자.\n\nblock = ['■'] \n\n이를 이용하여 아래와 같은 결과를 출력하라.\n\n'■-■-■-■-■-■-■-■-■-■' # 여기에서 '■'는 모두 10개 있음\n\n'■-■-■-■-■-■-■-■-■-■'\n\n\n(풀이)\n\n'-'.join(block*10)\n\n'■-■-■-■-■-■-■-■-■-■'"
  },
  {
    "objectID": "posts/05wk-2.html#a.-리스트-vs-튜플",
    "href": "posts/05wk-2.html#a.-리스트-vs-튜플",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "A. 리스트 vs 튜플",
    "text": "A. 리스트 vs 튜플\n- 공통점: (1) 컨테이너형타입이라는 점, 그리고 (2) 연산 및 인덱싱을 하는 방법은 리스트와 같음 - 차이점1: [] 대신에 ()를 사용한다. - 차이점2: 불변형이다. (원소의 값을 바꿀 수 없음) - 차이점3: 하나의 원소를 선언할 때는 (1,)와 같이 해야 한다. - 차이점4: 의미가 명확할때는 튜플의 ()를 생략가능하다.\n- 컨테이너형이라는 것이 무슨의미?\n\na=(4,6,'pencil', 3.2+4.6j, [3,4])\n\n\ntype(a[2])\n\nstr\n\n\n\ntype(a[3])\n\ncomplex\n\n\n- 연산의 유사성\n\n(1,2) + (3,4,5)\n\n(1, 2, 3, 4, 5)\n\n\n\n(1,2) * 2\n\n(1, 2, 1, 2)\n\n\n- 인덱싱의 유사성\n\ntpl = (11,21,31)\ntpl[1:]\n\n(21, 31)\n\n\n- 차이점2: 불변형이라는 것은 무슨의미?\n\na[2] = 'Pencil'\n\nTypeError: 'tuple' object does not support item assignment\n\n\n참고로 a를 튜플이 아니라 리스트로 선언하면 값이 잘 바뀐다.\n\na=[4,6,'pencil', 3.2+4.6j, [3,4]]\n\n\na[2]\n\n'pencil'\n\n\n\na[2]='Pencil'\n\n\na\n\n[4, 6, 'Pencil', (3.2+4.6j), [3, 4]]\n\n\n- 차이점3: 하나의 원소로 이루어진 튜플을 만들때는 쉼표를 붙여야 함.\n\n[1]+[2,3,4]\n\n[1, 2, 3, 4]\n\n\n\n(1,)+(2,3,4)\n\n(1, 2, 3, 4)\n\n\n- 차이점4: 의미가 명확할때 튜플의 괄호는 생략가능하다. (이게 중요합니다)\n\na=1,2\na\n\n(1, 2)\n\n\n의미가 명확할때 생략해야함\n\n1,2 + 3,4,5 \n\n(1, 5, 4, 5)\n\n\n\n(1,2) + (3,4,5) \n\n(1, 2, 3, 4, 5)"
  },
  {
    "objectID": "posts/05wk-2.html#b.-선언",
    "href": "posts/05wk-2.html#b.-선언",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "B. 선언",
    "text": "B. 선언\n- 소괄호를 이용\n\na=(1,2,3)\na\n\n(1, 2, 3)\n\n\n\ntype(a)\n\ntuple\n\n\n- 생략가능하다는 점이 포인트\n\na=1,2,3\na\n\n(1, 2, 3)\n\n\n\ntype(a)\n\ntuple\n\n\n- 원소가 하나인 튜플을 만들고 싶다면?\n\na=(1,)\na\n\n(1,)"
  },
  {
    "objectID": "posts/05wk-2.html#c.-연산",
    "href": "posts/05wk-2.html#c.-연산",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "C. 연산",
    "text": "C. 연산\n- 리스트와 동일\n\n(1,2)+(3,4,5)\n\n(1, 2, 3, 4, 5)\n\n\n\n(1,2)*2\n\n(1, 2, 1, 2)"
  },
  {
    "objectID": "posts/05wk-2.html#d.-인덱싱",
    "href": "posts/05wk-2.html#d.-인덱싱",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "D. 인덱싱",
    "text": "D. 인덱싱\n- 리스트와 동일\n\na=(1,2,3,-4,-5)\na\n\n(1, 2, 3, -4, -5)\n\n\n\na[-1]\n\n-5\n\n\n\na[-3:]\n\n(3, -4, -5)"
  },
  {
    "objectID": "posts/05wk-2.html#e.-슬기로운-튜플사용-star",
    "href": "posts/05wk-2.html#e.-슬기로운-튜플사용-star",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "E. 슬기로운 튜플사용 (\\(\\star\\))",
    "text": "E. 슬기로운 튜플사용 (\\(\\star\\))\n# 예제 – 여러변수를 동시에 출력하고 싶을 경우 (다중출력?)\n변수를 아래와 같이 선언하였다고 하자.\n\na=1\nb=2\nc=3\n\n선언된 값을 확인하려면?\n\na\n\n1\n\n\n\nb\n\n2\n\n\n\nc\n\n3\n\n\n튜플을 이용하면?\n\na,b,c # 괄호하나 생략하는것이 이렇게 편하다..\n\n(1, 2, 3)\n\n\n#\n# 예제2 – 다중할당1 (여러개의 변수를 동시에 선언하고 싶을 경우)\n아래와 같이 =를 5번 쓰면 5개의 변수를 선언할 수 있다.\n\nname = 'Tom'\nage = 20 \nsex = 'M'\nheight = 180\nweight = 70\n\n튜플을 이용하면 좀더 간단히 하나의 = 로도 아래와 같이 선언할 수 있다.\n\nname, age, sex, height, weight = 'Tom', 20, 'M', 180, 70  # 다중할당\n\n#\n# 예제2 – 다중할당2, 위도와 경도\n\ncoor = (37,127) # 서울 \ncoor\n\n(37, 127)\n\n\n\nlat, long = coor # 다중할당\n\n\nlat \n\n37\n\n\n\nlong \n\n127\n\n\n#\n# 잠깐만 – 다중할당은 꼭 튜플에서만 가능한가?\n그건 아니다…\n\n[x,y,z] = [1,2,3] \nx,y,z # 다중출력 \n\n(1, 2, 3)\n\n\n\n[x,y] = 'hi'\nx,y \n\n('h', 'i')\n\n\n튜플과 같이 사용하면 가독성이 극대화 (그래서 다중할당은 거의 튜플과 세트로 사용함)\n\nx,y,z = 1,2,3\nx,y,z # 다중출력 \n\n(1, 2, 3)\n\n\n\nx,y = 'hi'\nx,y \n\n('h', 'i')\n\n\n#\n# 예제 – 임시변수 사용없이 두 변수의 값을 교환\n\na=10\nb=20\n\n\na,b\n\n(10, 20)\n\n\n\na,b = b,a \n\n\na,b\n\n(20, 10)\n\n\n#\n# 예제 – for문과 튜플\n\nlst = [['guebin', 202112345, 'M'],\n       ['iu',202254321, 'F'],\n       ['hodong', 202011223, 'M']]\nlst\n\n[['guebin', 202112345, 'M'],\n ['iu', 202254321, 'F'],\n ['hodong', 202011223, 'M']]\n\n\n\nlst[0]\n\n['guebin', 202112345, 'M']\n\n\n\nfor name,studentid,sex in lst: \n    print(name,sex)\n\nguebin M\niu F\nhodong M\n\n\n#\n# 예제 – for문과 튜플, dummy variable _\n\nfor name,studentid,sex in lst: \n    print(studentid)\n\n202112345\n202254321\n202011223\n\n\n\nfor _,studentid,_ in lst: \n    print(studentid)\n\n202112345\n202254321\n202011223\n\n\n\nfor _,_,sex in lst: \n    print(sex)\n\nM\nF\nM\n\n\n\nfor name,_,sex in lst: \n    print(name,sex)\n\nguebin M\niu F\nhodong M\n\n\n\nfor name,_,_  in lst: \n    print(name)\n\nguebin\niu\nhodong\n\n\n#\n# 예제 – 튜플과 언패킹연산자 *\n아래와 같이 관심없는것 모두를 other라는 이름으로 받을 수 있음\n\nfor name,*other  in lst: \n    print(name,other)\n\nguebin [202112345, 'M']\niu [202254321, 'F']\nhodong [202011223, 'M']\n\n\n*의 동작을 더 세심히 살펴보자.\n\nhead, body, *tail = range(1,11) \nhead, body, tail\n\n(1, 2, [3, 4, 5, 6, 7, 8, 9, 10])\n\n\n\nhead1,head2, *body, tail1,tail2,tail3 = range(1,11) \nhead1,head2, body, tail1,tail2,tail3 \n\n(1, 2, [3, 4, 5, 6, 7], 8, 9, 10)\n\n\n\n*head, body, tail = range(1,11) \nhead, body, tail\n\n([1, 2, 3, 4, 5, 6, 7, 8], 9, 10)\n\n\n(관찰)\n그러고 보니까..\n[*head, body, tail] = [1,2,3,4,5,6,7,8,9,10] \n[head, body, tail] = [[1,2,3,4,5,6,7,8],9,10] \n이렇다는 거잖아?\n*를 붙이면 1차원 자료구조가 풀린다..?\n\n[1,2,[1,2,3]]\n\n[1, 2, [1, 2, 3]]\n\n\n\n[1,2,*[1,2,3]]\n\n[1, 2, 1, 2, 3]\n\n\n- 단독사용은 불가능\n\n*[1,2,3]\n\nSyntaxError: can't use starred expression here (386627056.py, line 1)"
  },
  {
    "objectID": "posts/05wk-2.html#f.-튜플을-왜-쓸까-제-생각..",
    "href": "posts/05wk-2.html#f.-튜플을-왜-쓸까-제-생각..",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "F. 튜플을 왜 쓸까? – 제 생각..",
    "text": "F. 튜플을 왜 쓸까? – 제 생각..\n- 질문: 리스트를 쓰지 않고 왜 튜플을 써야하나?\n- 답변1: (책의 설명)\n\n초보적인 설명: 실수방지\n더 정확한 설명: 빠르다, 여러사람과 작업하기 유리하다, 깊은복사/얕은복사시 원하지 않는 오류 (side effect 이라고 함) 방지\n\n- 답변2: 괄호를 생략할 수 있기 때문에, 리스트 말고 튜플을 쓰면 편함.\n\n소괄호의 생략 + 언패킹 \\(\\Rightarrow\\) 엄청난 가독성.\n컴공과 사람들 의견: 튜플 + 언패킹 \\(\\Rightarrow\\) 엄청난 가독성 \\(\\Rightarrow\\) 충격 \\(\\Rightarrow\\) “파이썬 편하더라고요..”\n\n- 근본적인 의문: 파이썬을 처음 만들때 리스트에 괄호를 생략하는 기능을 추가했으면 편했잖아?\n- 저의 설명: 리스트=신라면, 튜플=라면사리 같은 느낌으로 이해하면 된다. 불변형(튜플)은 기능제한이 있는데, 가변형(리스트)는 기능이 풍부하다. 대신에, 가변형은 느리고 무겁다.\n\n기능적으로만 보면, 신라면이 있으면 스프를 버리고 라면사리를 얻을 수 있음, 그래서 라면사리는 필요없음.\n그런데 신라면에서 스프를 버려서 라면사리를 항상 얻는다면, 비효율적임.\n우리가 원하는게 (1) 원소를 벡터형태로 모은뒤 (2) 벡터자체를 출력해보고 (3) 각 원소를 sort하고 (4) 원소를 추가 append하고 (5) 원소를 삭제 remove 하는 것 일수도 있음. 그렇지만 진짜 단순하게 (1),(2) 만 원할수도있음.\n단순히 (1)-(2)의 목적으로 리스트를 사용하는건 비효율적이니까 불변형인 튜플을 만듦. (1)-(2)를 사용함에 있어서 편리성을 극대화 하기위해 괄호도 생략하게 해줌.\n\n\ndef mycal(a,b):\n    return a+b, a-b, a*b, a/b # 여러개의 값을 리턴하는듯 보임 -&gt; 사실은 길이가 4인 튜플 1개를 리턴\n\n\nmycal(1,2)\n\n(3, -1, 2, 0.5)\n\n\n\n_,_,mul,_ = mycal(1,2)\n\n\nmul\n\n2"
  },
  {
    "objectID": "posts/05wk-2.html#g.-연습문제들",
    "href": "posts/05wk-2.html#g.-연습문제들",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "G. 연습문제들",
    "text": "G. 연습문제들\n# 문제. 길이가 1인 튜플을 만들어 자신의 학번을 저장하라. 길이가 1인 튜플을 만들어 자신의 영문이름을 저장하라. 두 튜플을 + 연산자로 합쳐아래와 같은 출력결과를 얻어라. 최종 결과는 예를들면 아래와 같아야 한다.\n\n('2021-43052', 'GuebinChoi')\n\n('2021-43052', 'GuebinChoi')\n\n\n(풀이)\n\nsid = ('2021-43052',)\nname = ('GuebinChoi',)\n\n\nsid+name\n\n('2021-43052', 'GuebinChoi')\n\n\n파이썬프로그래밍 수강생. 아래는 파이썬프로그래밍 수강생들의 학번, 이름, 출석점수, 과제점수, 중간고사점수, 기말고사점수를 저장한 중첩리스트이다.\n\nlst = [['2021-43052', 'GuebinChoi', 5, 10, 20, 25],\n       ['2019-12342', 'Heung-min Son', 10, 15, 30, 15],\n       ['2018-32234', 'hynn', 7, 20, 30, 15],\n       ['2022-42323', 'Minji', 8, 20, 20, 35],\n       ['2023-55342', 'Hanni', 7, 20, 30, 35],\n       ['2022-46624', 'Danielle', 3, 15, 30, 40],\n       ['2022-11239', 'Haerin', 10, 20, 30, 40],\n       ['2022-32114', 'Hyein', 10, 20, 20, 35]]\nlst \n\n[['2021-43052', 'GuebinChoi', 5, 10, 20, 25],\n ['2019-12342', 'Heung-min Son', 10, 15, 30, 15],\n ['2018-32234', 'hynn', 7, 20, 30, 15],\n ['2022-42323', 'Minji', 8, 20, 20, 35],\n ['2023-55342', 'Hanni', 7, 20, 30, 35],\n ['2022-46624', 'Danielle', 3, 15, 30, 40],\n ['2022-11239', 'Haerin', 10, 20, 30, 40],\n ['2022-32114', 'Hyein', 10, 20, 20, 35]]\n\n\n# 문제. 파이썬프로그래밍 수강생의 수는 모두 몇명인가?\n(풀이)\n\nlen(lst)\n\n8\n\n\n#. 전북대학교 지침에 따라 출석점수가 7보다 작은 학생은 (즉 출석점수 &lt; 7 일 경우) F학점을 부여하게 되어있다. 이 기준에 따르면 F를 받는 학생은 모두 몇명인가?\n(풀이)\n\nsum([att&lt;7 for _,_,att,*other in lst])\n\n2\n\n\n# 문제. 파이썬프로그래밍 수업의 경우 출석+레포트 &lt; 21 일 경우 F학점을 부여한다고 한다. 이 기준에 따르면 F를 받는 학생은 모두 몇명인가?\n(풀이)\n\nsum([att+rep&lt;21 for _,_,att,rep,*other in lst])\n\n2\n\n\n# 문제. 리스트의 정렬순서를 [학번, 이름, …, 기말고사점수] 가 아니라 [이름, 학번, … , 기말고사점수] 와 같이 되도록 변경하는 코드를 작성하라.\n(출력예시)\n\n[['GuebinChoi', '2021-43052', 5, 10, 20, 25],\n ['Heung-min Son', '2019-12342', 10, 15, 30, 15],\n ['hynn', '2018-32234', 7, 20, 30, 15],\n ['Minji', '2022-42323', 8, 20, 20, 35],\n ['Hanni', '2023-55342', 7, 20, 30, 35],\n ['Danielle', '2022-46624', 3, 15, 30, 40],\n ['Haerin', '2022-11239', 10, 20, 30, 40],\n ['Hyein', '2022-32114', 10, 20, 20, 35]]\n\n[['GuebinChoi', '2021-43052', 5, 10, 20, 25],\n ['Heung-min Son', '2019-12342', 10, 15, 30, 15],\n ['hynn', '2018-32234', 7, 20, 30, 15],\n ['Minji', '2022-42323', 8, 20, 20, 35],\n ['Hanni', '2023-55342', 7, 20, 30, 35],\n ['Danielle', '2022-46624', 3, 15, 30, 40],\n ['Haerin', '2022-11239', 10, 20, 30, 40],\n ['Hyein', '2022-32114', 10, 20, 20, 35]]\n\n\n(풀이)\n\n[[name,sid,*other] for sid,name,*other in lst]\n\n[['GuebinChoi', '2021-43052', 5, 10, 20, 25],\n ['Heung-min Son', '2019-12342', 10, 15, 30, 15],\n ['hynn', '2018-32234', 7, 20, 30, 15],\n ['Minji', '2022-42323', 8, 20, 20, 35],\n ['Hanni', '2023-55342', 7, 20, 30, 35],\n ['Danielle', '2022-46624', 3, 15, 30, 40],\n ['Haerin', '2022-11239', 10, 20, 30, 40],\n ['Hyein', '2022-32114', 10, 20, 20, 35]]"
  },
  {
    "objectID": "posts/05wk-2.html#a.-인덱싱고급-스트라이딩",
    "href": "posts/05wk-2.html#a.-인덱싱고급-스트라이딩",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "A. 인덱싱고급 (스트라이딩)",
    "text": "A. 인덱싱고급 (스트라이딩)\n- 스트라이딩 [start:end:step]\n\nlst = list('abcdefghijk')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']\n\n\n\nlen(lst)\n\n11\n\n\n\nlst[0:9:2]\n\n['a', 'c', 'e', 'g', 'i']\n\n\n- 생략\n\nlst[0:9]\n#lst[0:9:]\n#lst[0:9:1]\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']\n\n\n\nlst[1::3]\n\n['b', 'e', 'h', 'k']\n\n\n\nlst[:8:3]\n\n['a', 'd', 'g']\n\n\n# 예제1: 짝수/홀수 원소 추출\n아래와 같은 문자열이 있다고 하자.\n\nlst = list('abcdefghijk')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']\n\n\nindex = 0,2,4, ... 에 해당하는 원소를 출력하라.\n\nlst[::2]\n\n['a', 'c', 'e', 'g', 'i', 'k']\n\n\nindex = 1,4,7 ... 에 해당하는 원소를 출력하라.\n\nlst[1::3]\n\n['b', 'e', 'h', 'k']\n\n\n#\n# 예제2 – 세로로..\n\n(예제2를 위한 예비학습) 문자열에서 \\n을 출력하면 출력시 줄바꿈이 일어난다.\n\nprint('1행\\n2행\\n3행')\n\n1행\n2행\n3행\n\n\n예비학습 끝\n\n아래와 같은 문자열이 있다고 하자.\n\ntxt = '너같이사랑스럽고\\n또예쁘고도멋지고\\n속훤히보이는너알\\n았어그동안고마웠\\n지정말정말사랑해'\nprint(txt)\n\n너같이사랑스럽고\n또예쁘고도멋지고\n속훤히보이는너알\n았어그동안고마웠\n지정말정말사랑해\n\n\n위 문자열을 세로로 읽는 코드를 작성하라. (9칸씩 점프하면서 읽으면 된다)\n(풀이)\n\ntxt[::9]\n\n'너또속았지'\n\n\n#\n- step = -1 이면?\n\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']\n\n\n\nlst[::-1]\n\n['k', 'j', 'i', 'h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n- 스트라이딩으로 step = -1 옵션 주기 vs 리스트의 .reverse() 메소드 이용하기\n관찰1: reverse 메소드는 리스트 자체를 변화시킴\n\nlst = list('abcdefgh')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n\nlst.reverse()  \nlst\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n관찰2: [::-1]는 리스트는 변화시키지 않음\n\nlst = list('abcdefgh')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n\nlst[::-1]\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n- -step 은 쓰기 까다롭다.\n(예제) 처음과 끝을 생략하지 않고 아래와 동일한 효과를 주는 코드를 만들어 보자.\n(풀이)\n결국 lst[?:?:-1]의 꼴에서 적당히 ?의 값을 채우면 된다. –&gt; 어려워\n\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n\nlst[::-1]\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n\n\n\nNone\na\nb\nc\nd\ne\nf\ng\nh\nNone\n\n\n\n\n?\n0\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n-9\n-8\n-7\n-6\n-5\n-4\n-3\n-2\n-1\n?\n\n\n\n\nlst[-1:-9:-1]  # 지양 &lt;-- 쓰지마..\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']"
  },
  {
    "objectID": "posts/05wk-2.html#b.-len함수",
    "href": "posts/05wk-2.html#b.-len함수",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "B. len함수",
    "text": "B. len함수\n- 0차원 자료형은 len함수가 동작하지 않음\n\na=1 \nlen(a)\n\nTypeError: object of type 'int' has no len()\n\n\n\na=True\nlen(a)\n\nTypeError: object of type 'bool' has no len()\n\n\n\na=3.14\nlen(a)\n\nTypeError: object of type 'float' has no len()\n\n\n\nnote: 이것이 어떠한 수학적인 의미를 가지거나 0차원의 본질적진리를 뜻하는 것은 아님. R에서는 1,3.14,TRUE의 길이가 1로 존재함.\n\n- 1차원 자료형은 len함수가 동작\n\na='guebin'\nlen(a)\n\n6\n\n\n\na=[1,2,3,4,5,6]\nlen(a)\n\n6\n\n\n\na=1,2,3,4,5,6 \nlen(a)\n\n6\n\n\n\na=range(10)\nlen(a)\n\n10\n\n\n- 길이가 1인 1차원 자료형과 0차원 자료형은 다른것임\n\na='g'\nlen(a)\n\n1\n\n\n\na=[1]\nlen(a)\n\n1\n\n\n\na=(1,)\nlen(a)\n\n1\n\n\n\na=range(1)\nlen(a)\n\n1\n\n\n- 길이가 0인 1차원 자료형도 존재함\n\na=''\nlen(a)\n\n0\n\n\n\na=[]\nlen(a)\n\n0\n\n\n\na=()\nlen(a)\n\n0\n\n\n\na=range(0)\nlen(a)\n\n0"
  },
  {
    "objectID": "posts/05wk-2.html#a.-intro-str-list-tuple-정리",
    "href": "posts/05wk-2.html#a.-intro-str-list-tuple-정리",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "A. intro: str, list, tuple 정리",
    "text": "A. intro: str, list, tuple 정리\n- str, list, tuple은 모두 시퀀스형이라는 공통점이 있다. \\(\\to\\) 원소의 위치번호로 인덱싱이 가능\n\nlst = [1,2,3,4]\n\n\nlst[0] # 위치번호=0\n\n1\n\n\n\nlst[-1] # 위치번호=-1\n\n4\n\n\n- str, list, tuple은 차이점도 존재함. 잠깐 정리해보자.\n시퀀스형의 카테고리\n\n컨테니어형: list, tuple\n균일형: str\n가변형: list\n불변형: tuple, str\n\n표로 정리하면\n\n\n\n\n컨테니어형\n균일형\n\n\n\n\n가변형\nlist\n.\n\n\n불변형\ntuple\nstr\n\n\n\n- 시퀀스형이 아닌 1차원 자료형도 있을까? 원소의 위치번호로 인덱싱이 불가능한 자료형\n- 왜 이런게 필요할까?\n\n벡터에서 원소를 뽑는것은 정보의 모임에서 정보를 검색하는 것과 같다.\n정보를 순서대로 나열한뒤에 그 순서를 이용하여 검색하는 방법은 유용하다.\n하지만 경우에 따라서는 키워드를 기억해서 그 키워드를 바탕으로 정보에 접근하는 방법이 유용할 수 있다.\n\n카카오톡 대화내용검색\n(상황1) 오늘아침에 와이프가 뭔가를 카톡으로 부탁했었음. 그런데 그 뭔가가 기억안남.\n(상황2) 방학전에 동료교수과 개강이후 저녁약속을 카톡으로 잡았었음. 그런데 그게 언제인지 기억안남.\n- 순서대로 정리된 자료를 검색할때는 시퀀스형이 유리하다. 그런데 키워드로 검색하고 싶을 경우는 딕셔너리 타입이 유리하다."
  },
  {
    "objectID": "posts/05wk-2.html#b.-선언-1",
    "href": "posts/05wk-2.html#b.-선언-1",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "B. 선언",
    "text": "B. 선언\n- 방법1: 가장 일반적\n\ndct = {'guebin':49, 'hanni':80}\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n- 방법2: dict() 이용\n\ndct = dict(guebin=49, hanni=80)\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n- 방법3: 중첩된 리스트를 만든 뒤에 형태변환\n\n_lst = [['guebin',49],['hanni',80]]\n_lst \n\n[['guebin', 49], ['hanni', 80]]\n\n\n\ndict(_lst)\n\n{'guebin': 49, 'hanni': 80}\n\n\n- 방법4: 중첩된 튜플을 만든 뒤에 형태변환\n\n_tpl = ('guebin',49), ('hanni',80)\n_tpl\n\n(('guebin', 49), ('hanni', 80))\n\n\n\ndict(_tpl)\n\n{'guebin': 49, 'hanni': 80}"
  },
  {
    "objectID": "posts/05wk-2.html#c.-원소추출",
    "href": "posts/05wk-2.html#c.-원소추출",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "C. 원소추출",
    "text": "C. 원소추출\n- 원소의 위치로 추출할 수 없고, key로 추출해야 한다.\n\ndct = {'guebin':49, 'hanni':80}\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\nguebin의 점수를 추출하고 싶다면?\n\ndct['guebin']\n\n49\n\n\n- 만약에 dict가 아니라 list로 정보를 저장했다면?\n(예제) 아래와 같은 리스트에서 guebin의 점수를 추출하고 싶다면?\n\nlst=[['guebin',49],['hanni',80]]\nlst\n\n[['guebin', 49], ['hanni', 80]]\n\n\n(풀이1)\n\nlst[0][1] # guebin의 점수를 출력하란 의미\n\n49\n\n\n(풀이2) – 진짜 최악\n\n[lst[i][1] for i in range(len(lst)) if lst[i][0] == 'guebin']\n\n[49]\n\n\n(풀이3) – 덜 최악\n\n[score for name,score in lst if name == 'guebin']\n\n[49]\n\n\n- ’guebin’의 점수를 추출하는 코드 비교\n\ndct['guebin'] # 코드1: 단순하고, 가독성있음\n\n49\n\n\n\nlst[0][1] # 코드2: 단순하지만, 가독성이 있는건 아님, 확장성이 없음\n\n49\n\n\n\n[lst[i][1] for i in range(len(lst)) if lst[i][0] =='guebin'] # 코드3: 단순하지도 않고, 가독성도 없음.\n\n[49]\n\n\n\n[score for name,score in lst if name=='guebin' ] # 코드4: 단순하지 않지만, 가독성은 있음\n\n[49]"
  },
  {
    "objectID": "posts/05wk-2.html#d.-원소추가-변경-삭제",
    "href": "posts/05wk-2.html#d.-원소추가-변경-삭제",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "D. 원소추가, 변경, 삭제",
    "text": "D. 원소추가, 변경, 삭제\n\ndct={'guebin':49, 'hanni':80}\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n- 원소에 접근: guebin의 점수 출력\n\ndct['guebin']\n\n49\n\n\n- 추가: hynn학생의 점수를 추가\n\ndct['hynn'] = 99\n\n\ndct\n\n{'guebin': 49, 'hanni': 80, 'hynn': 99}\n\n\n- 변경: hanni의 점수를 변경\n\ndct['hanni'] = 100 \n\n\ndct\n\n{'guebin': 49, 'hanni': 100, 'hynn': 99}\n\n\n- 삭제\n(방법1)\n\ndct={'guebin':49, 'hanni':80, 'hynn':99}\ndel dct['guebin']  \ndct\n\n{'hanni': 80, 'hynn': 99}\n\n\n(방법2)\n\ndct={'guebin':49, 'hanni':80, 'hynn':99} \ndct.pop('guebin')\n\n49\n\n\n\ndct\n\n{'hanni': 80, 'hynn': 99}\n\n\n- 참고로 리스트였다면 이러한 삭제작업역시 비효율적이었을 것임\n\nlst = [['guebin',49],['hanni',80],['hynn',99]] \nlst\n\n[['guebin', 49], ['hanni', 80], ['hynn', 99]]\n\n\nguebin의 점수를 삭제하려면?\n\n[[name,score] for name,score in lst if name != 'guebin']\n\n[['hanni', 80], ['hynn', 99]]"
  },
  {
    "objectID": "posts/05wk-2.html#e.-연산",
    "href": "posts/05wk-2.html#e.-연산",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "E. 연산",
    "text": "E. 연산\n- 하나있어요..\n\ndct = {'guebin':49, 'hanni':80} \ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n\n'guebin' in dct\n\nTrue\n\n\n\n'hanni' in dct\n\nTrue\n\n\n\n'hynn' in dct\n\nFalse\n\n\n- in은 사실 다른자료형도 가능했음\n(관찰1)\n\n'a' in 'guebin' \n\nFalse\n\n\n\n'b' in 'guebin' \n\nTrue\n\n\n\n'c' in 'guebin' \n\nFalse\n\n\n(관찰2)\n\ntpl = 1,2,3 \ntpl\n\n(1, 2, 3)\n\n\n\n1 in tpl\n\nTrue\n\n\n\n4 in tpl\n\nFalse\n\n\n(관찰3)\n\nlst = [['guebin',49],['hanni',80],['hynn',99]] \nlst\n\n[['guebin', 49], ['hanni', 80], ['hynn', 99]]\n\n\n\n['guebin',49] in lst\n\nTrue\n\n\n- in연산자가 dict형에 사용되면 key를 기준으로 True, False를 판단한다."
  },
  {
    "objectID": "posts/05wk-2.html#f.-딕셔너리-특수기능",
    "href": "posts/05wk-2.html#f.-딕셔너리-특수기능",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "F. 딕셔너리 특수기능",
    "text": "F. 딕셔너리 특수기능\n(pop)\n\ndct = {'guebin':49, 'hanni':80} \ndct.pop('hanni')\ndct\n\n{'guebin': 49}\n\n\n(get)\n\ndct = {'guebin':49, 'hanni':80} \ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n\ndct.get('guebin') \n\n49\n\n\n아래와 같은 기능\n\ndct['guebin']\n\n49\n\n\n미묘한 차이점이 존재함\n\ndct['hynn'] # hynn이 없어서 키에러 출력, 그런 key는 없다.. \n\nKeyError: 'hynn'\n\n\n\ndct.get('hynn') # hynn이 없으면 아무것도 출력안함 \n\n(keys,values,items)\n\nfor k,v in dct.items():\n    print(k,v)\n\nguebin 49\nhanni 80\n\n\n- .keys()는 딕셔너리의 키를 리턴한다.\n\ndct = {'guebin':49, 'hanni':80} \ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n\n_keys=dct.keys()\n_keys\n\ndict_keys(['guebin', 'hanni'])\n\n\n\ntype(_keys) # 리턴된 자료형은 이상한것임\n\ndict_keys\n\n\n\nlist(_keys) # 아무튼 그 이상한 자료형도 리스트화 가능 \n\n['guebin', 'hanni']\n\n\n- .values()는 딕셔너리의 값들을 리턴한다.\n\n_values = dct.values()\n_values \n\ndict_values([49, 80])\n\n\n\ntype(_values)\n\ndict_values\n\n\n\nlist(_values)\n\n[49, 80]\n\n\n- .items()는 딕셔너리의 (키,값)을 리턴한다.\n\n_items = dct.items()\n_items \n\ndict_items([('guebin', 49), ('hanni', 80)])\n\n\n\ntype(_items)\n\ndict_items\n\n\n\nlist(_items)\n\n[('guebin', 49), ('hanni', 80)]"
  },
  {
    "objectID": "posts/05wk-2.html#g.-for문과-dict-star",
    "href": "posts/05wk-2.html#g.-for문과-dict-star",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "G. for문과 dict (\\(\\star\\))",
    "text": "G. for문과 dict (\\(\\star\\))\n\ndct = {'guebin': 49, 'hanni': 80}\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n(예시1)\n\nfor k in dct.keys():\n    print(k)\n\nguebin\nhanni\n\n\n\nfor k in dct:\n    print(k)\n\nguebin\nhanni\n\n\n\n딕셔너리 그자체도 for문에 넣을 수 있다. 그때는 딕셔너리의 key가 반복된다.\n결과를 보면 dct 대신에 dct.keys()와 list(dct)를 넣었을때와 결과가 같다.\n\n\nNote: list(dct) 하면 key만 리턴된다.\n\n(예시2)\n\nfor v in dct.values():\n    print(v)\n\n49\n80\n\n\n(예시3)\n\nfor i in dct.items():\n    print(i)\n\n('guebin', 49)\n('hanni', 80)\n\n\n(예시4)\n\nfor k,v in dct.items():\n    print(k,v)\n\nguebin 49\nhanni 80\n\n\n(예시5) – {}의 중간고사 점수는 {}점 입니다.\n\nfor name,score in dct.items():\n    print(f'{name}의 중간고사 점수는 {score}점 입니다.')\n\nguebin의 중간고사 점수는 49점 입니다.\nhanni의 중간고사 점수는 80점 입니다."
  },
  {
    "objectID": "posts/05wk-2.html#h.-dict에서-key혹은-value만-뽑아내기",
    "href": "posts/05wk-2.html#h.-dict에서-key혹은-value만-뽑아내기",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "H. dict에서 key혹은 value만 뽑아내기",
    "text": "H. dict에서 key혹은 value만 뽑아내기\n- 예제: 아래의 dict에서 key만 뽑아내고 싶다.\n\ndct = {'guebin':49, 'hanni':80} \n\n(풀이1)\n\nlist(dct)\n\n['guebin', 'hanni']\n\n\n(풀이2)\n\nlist(dct.keys())\n\n['guebin', 'hanni']\n\n\n(풀이3)\n\n[k for k in dct]\n\n['guebin', 'hanni']\n\n\n(풀이4)\n\n[k for k,v in dct.items()]\n\n['guebin', 'hanni']\n\n\n- 예제: 아래의 dict에서 value만 뽑아내고 싶다.\n\ndct = {'guebin':49, 'hanni':80} \n\n(풀이1)\n\nlist(dct.values())\n\n[49, 80]\n\n\n(풀이2)\n\n[dct[k] for k in dct]\n\n[49, 80]\n\n\n(풀이3)\n\n[v for v in dct.values()]\n\n[49, 80]\n\n\n(풀이4)\n\n[v for k,v in dct.items()]\n\n[49, 80]"
  },
  {
    "objectID": "posts/05wk-2.html#a.-바꿔치기",
    "href": "posts/05wk-2.html#a.-바꿔치기",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "A. 바꿔치기",
    "text": "A. 바꿔치기\n# 예제1 – 아래와 같은 리스트를 고려하자.\n\nlst = ['딸기','사과','바나나','딸기','사과','오토바이','자동차','버스','기차','오토바이','자동차']\n\n다음의 맵핑규칙에 따라서 위의 리스트의 원소를 바꾸어라.\n\n\n\n변환전\n변환후\n\n\n\n\n딸기\n과일\n\n\n사과\n과일\n\n\n바나나\n과일\n\n\n오토바이\n탈것\n\n\n자동차\n탈것\n\n\n버스\n탈것\n\n\n기차\n탈것\n\n\n\n(풀이1) – elif를 한번 써본정도의 의미. 추천하는 풀이 X\n\nlst2 = []\nfor l in lst:\n    if l=='딸기':\n        lst2.append('과일')\n    elif l=='사과':\n        lst2.append('과일')\n    elif l=='바나나':\n        lst2.append('과일')\n    elif l=='오토바이':\n        lst2.append('탈것')\n    elif l=='자동차':\n        lst2.append('탈것')\n    elif l=='버스':\n        lst2.append('탈것')\n    else:\n        lst2.append('탈것')        \n\n\nlst,lst2\n\n(['딸기', '사과', '바나나', '딸기', '사과', '오토바이', '자동차', '버스', '기차', '오토바이', '자동차'],\n ['과일', '과일', '과일', '과일', '과일', '탈것', '탈것', '탈것', '탈것', '탈것', '탈것'])\n\n\n(풀이2) – 코드는 쉽고 편함. dct를 만들기 힘듦.\n\ndct = {'딸기':'과일','사과':'과일','바나나':'과일','오토바이':'탈것','자동차':'탈것','버스':'탈것','기차':'탈것'}\ndct\n\n{'딸기': '과일',\n '사과': '과일',\n '바나나': '과일',\n '오토바이': '탈것',\n '자동차': '탈것',\n '버스': '탈것',\n '기차': '탈것'}\n\n\n\n[dct[l] for l in lst]\n\n['과일', '과일', '과일', '과일', '과일', '탈것', '탈것', '탈것', '탈것', '탈것', '탈것']\n\n\n(풀이3) – 코드가 매우 어려움. dct를 만들기 쉬움.\n\ndct = {'과일':['딸기','사과','바나나'], '탈것':['오토바이','자동차','버스','기차']}\ndct\n\n{'과일': ['딸기', '사과', '바나나'], '탈것': ['오토바이', '자동차', '버스', '기차']}\n\n\n\nlst\n\n['딸기', '사과', '바나나', '딸기', '사과', '오토바이', '자동차', '버스', '기차', '오토바이', '자동차']\n\n\n\n[k for l in lst for k in dct if l in dct[k]]\n\n['과일', '과일', '과일', '과일', '과일', '탈것', '탈것', '탈것', '탈것', '탈것', '탈것']\n\n\n#\n# 예제2 – 아래와 같은 리스트가 있다고 하자.\n\nlst = list('abcd'*2+'bbb')\nlst\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'b', 'b', 'b']\n\n\n아래의 규칙에 의하여 lst의 각 원소의 값을 바꾸고 싶다고 하자. 이를 구현하는 코드를 작성하라.\n\n\n\n변환전\n변환후\n\n\n\n\n‘a’\n[1,0,0,0]\n\n\n‘b’\n[0,1,0,0]\n\n\n‘c’\n[0,0,1,0]\n\n\n‘d’\n[0,0,0,1]\n\n\n\n(풀이)\n\ndct = {'a':[1,0,0,0], 'b':[0,1,0,0], 'c':[0,0,1,0], 'd':[0,0,0,1]}\ndct\n\n{'a': [1, 0, 0, 0], 'b': [0, 1, 0, 0], 'c': [0, 0, 1, 0], 'd': [0, 0, 0, 1]}\n\n\n\n[dct[l] for l in lst]\n\n[[1, 0, 0, 0],\n [0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 1],\n [1, 0, 0, 0],\n [0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 1],\n [0, 1, 0, 0],\n [0, 1, 0, 0],\n [0, 1, 0, 0]]\n\n\n# 예제3 – 예제2을 역변환하라. 즉 아래의 리스트를\n\nlst2= [[1, 0, 0, 0],\n       [0, 1, 0, 0],\n       [0, 0, 1, 0],\n       [0, 0, 0, 1],\n       [1, 0, 0, 0],\n       [0, 1, 0, 0],\n       [0, 0, 1, 0],\n       [0, 0, 0, 1],\n       [0, 1, 0, 0],\n       [0, 1, 0, 0],\n       [0, 1, 0, 0]]\n\n아래와 같이 바꾸라.\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'b', 'b', 'b']\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'b', 'b', 'b']\n\n\n(풀이) – 실패\n\ndct = {[1,0,0,0]:'a', [0,1,0,0]:'b', [0,0,1,0]:'c', [0,0,0,1]:'d'}\ndct\n\nTypeError: unhashable type: 'list'\n\n\ndct의 key에 대응하는것은 불변형만 가능\n(풀이1)\n\ndct = {(1,0,0,0):'a', (0,1,0,0):'b', (0,0,1,0):'c', (0,0,0,1):'d'}\ndct\n\n{(1, 0, 0, 0): 'a', (0, 1, 0, 0): 'b', (0, 0, 1, 0): 'c', (0, 0, 0, 1): 'd'}\n\n\n\n[dct[tuple(l)] for l in lst2]\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'b', 'b', 'b']\n\n\n(풀이2)\n\ndct = {'a':[1,0,0,0], 'b':[0,1,0,0], 'c':[0,0,1,0], 'd':[0,0,0,1]} # 예제2의 dct\n\n\n[k for l in lst2 for k in dct if dct[k]==l]\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'b', 'b', 'b']"
  },
  {
    "objectID": "posts/05wk-2.html#b.-연습문제",
    "href": "posts/05wk-2.html#b.-연습문제",
    "title": "05wk-2: 파이썬의 자료형 (2)",
    "section": "B. 연습문제",
    "text": "B. 연습문제\n# 문제. 아래와 같은 맵핑을 고려하자.\n\n\n\n문자\n숫자\n\n\n\n\na\n0\n\n\nb\n1\n\n\n\n이를 딕셔너리로 표현하면 아래와 같다.\n\ndct = {'a':0, 'b':1} \n\n위 규칙에 따라서 아래의 리스트의 원소를 문자로 각각 변환하라.\n\nlst = [1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1]\n\n# 출력은 아래와 같아야 한다. \n['b', 'a', 'b', 'a', 'b', 'a', 'b', 'b', 'b', 'b', 'a', 'a', 'b', 'a', 'b']\n(풀이)\n\n[k for l in lst for k in dct if l == dct[k]]\n\n['b', 'a', 'b', 'a', 'b', 'a', 'b', 'b', 'b', 'b', 'a', 'a', 'b', 'a', 'b']\n\n\n# 문제. 아래와 같은 맵핑을 고려하자.\n\n\n\n월\n의미\n\n\n\n\n1,2\n겨울방학\n\n\n3,4,5,6\n1학기\n\n\n7,8\n여름방학\n\n\n9,10,11,12\n2학기\n\n\n\n이러한 규칙에 맞게 아래의 리스트를 적절한 문자열로 변환하라.\n\nmonth = [1,2,2,3,4,5,6,7,8,9,9,10,11,12] \n\n## 출력은 아래와 같아야 한다. \n['겨울방학', '겨울방학', '겨울방학', '1학기', '1학기', '1학기', '1학기', '여름방학', '여름방학', '2학기', '2학기', '2학기', '2학기', '2학기']\n(풀이1) – 좀 더 추천함\n\ndct = {'겨울방학':range(1,3), '1학기':range(3,7), '여름방학':range(7,9), '2학기':range(9,13)}\n\n\n[k for m in month for k in dct if m in dct[k]]\n\n['겨울방학',\n '겨울방학',\n '겨울방학',\n '1학기',\n '1학기',\n '1학기',\n '1학기',\n '여름방학',\n '여름방학',\n '2학기',\n '2학기',\n '2학기',\n '2학기',\n '2학기']\n\n\n(풀이2) – 추천안함\n\ndct = {1:'겨울방학',2:'겨울방학',3:'1학기',4:'1학기',5:'1학기',6:'1학기',7:'여름방학',8:'여름방학',9:'2학기',10:'2학기',11:'2학기',12:'2학기'}\n\n\n[dct[m] for m in month]\n\n['겨울방학',\n '겨울방학',\n '겨울방학',\n '1학기',\n '1학기',\n '1학기',\n '1학기',\n '여름방학',\n '여름방학',\n '2학기',\n '2학기',\n '2학기',\n '2학기',\n '2학기']\n\n\n## – 합성변환\n아래와 같은 맵핑을 고려하자.\n(규칙1)\n\n\n\n문자\n숫자\n\n\n\n\n바나나\n0\n\n\n사과\n1\n\n\n오토바이\n2\n\n\n자동차\n3\n\n\n자전거\n4\n\n\n\n(규칙2)\n\n\n\n아이템\n카테고리\n\n\n\n\n바나나\n과일\n\n\n사과\n과일\n\n\n오토바이\n탈것\n\n\n자동차\n탈것\n\n\n자전거\n탈것\n\n\n\n각각의 규칙을 나타내는 딕셔너리는 아래와 같이 선언되어있다고 하자.\n\ndct1 = {'바나나':0, '사과':1, '오토바이':2, '자동차':3, '자전거':4} \ndct2 = {'과일':['바나나','사과'], '탈것':['오토바이','자동차','자전거']} \n\n# 문제. 규칙1를 이용하여 아래와 같은 리스트를 변환하는 함수를 구현하고 그 함수를 f라 선언하라.\n# 입력 \n[0,1,0,1,4]\n\n# 출력 \n['바나나', '사과', '바나나', '사과', '자전거']\n(사용예시)\n\nf([0,1,0,1,4])\n\n['바나나', '사과', '바나나', '사과', '자전거']\n\n\n(풀이)\n\nf = lambda lst: [k for l in lst for k in dct1 if l == dct1[k]]\n\n\nf([0,1,0,1,4])\n\n['바나나', '사과', '바나나', '사과', '자전거']\n\n\n# 문제. 규칙2를 이용하여 아래와 같이 리스트를 변환하는 함수를 구현하고 그 함수를 g라고 선언하라.\n# 입력 \n['바나나','바나나','바나나','자동차']\n\n# 출력 \n['과일','과일','과일','탈것']\n(사용예시)\n\ng(['바나나','바나나','바나나','자동차'])\n\n['과일', '과일', '과일', '탈것']\n\n\n(풀이)\n\ng = lambda lst: [k for l in lst for k in dct2 if l in dct2[k]]\n\n\ng(['바나나','바나나','바나나','자동차'])\n\n['과일', '과일', '과일', '탈것']\n\n\n# 문제. 규칙1-2를 이용하여 아래와 같은 숫자로 이루어진 입력을 ‘과일’, ‘탈것’ 중 하나로 바꾸는 코드를 구현하라.\n# 입력 \n[0,1,0,1,3,4,2,2,3,4,1,0]\n\n# 출력 \n['과일', '과일', '과일', '과일', '탈것', '탈것', '탈것', '탈것', '탈것', '탈것', '과일', '과일']\nhint \\(g(f(x))\\) 를 이용하라.\n(풀이)\n\ng(f([0,1,0,1,3,4,2,2,3,4,1,0]))\n\n['과일', '과일', '과일', '과일', '탈것', '탈것', '탈것', '탈것', '탈것', '탈것', '과일', '과일']"
  },
  {
    "objectID": "posts/01wk-1.html",
    "href": "posts/01wk-1.html",
    "title": "01wk-1: 강의소개",
    "section": "",
    "text": "1. 전북대 + 충남대\n- 전북대는 전북대학생끼리 성적평가.\n- 충남대는 충남대학생끼리 성적평가.\n- 충남대 학생의 경우 교양과목임을 감안하여 채점할 예정임.\n\n\n2. 플립러닝\n- 수업: 매주 금요일 오후까지 강의홈페이지에 업로드 될 예정.\n\n수업은 영상업로드 방식 (각자 수강)\n영상시청에 대한 별도의 출석체크는 없음.\n\n- 퀴즈: 매주 수요일 수업시간에 퀴즈를 볼 예정임.\n\n시험은 오픈북이며 구글검색, 강의노트 참고등을 허용함.\nChatGPT는 허용하지 않음.\n\n\n\n3. 성적처리 방식\n- 출석 10%, 퀴즈 50%, 중간 20%, 기말 20%\n\n출석은 매주 수요일 퀴즈시간에 체크할 예정임. (따라서 퀴즈를 보면 출석점수는 자동으로 인정)\n사실상 퀴즈의 점수비중이 60%"
  },
  {
    "objectID": "posts/02wk-2.html#a.-int-float-bool",
    "href": "posts/02wk-2.html#a.-int-float-bool",
    "title": "02wk-2: 파이썬은 좋은 계산기다 (2)",
    "section": "A. int, float, bool",
    "text": "A. int, float, bool\n- int형\n\na=100\n\n\ntype(a)\n\nint\n\n\n- float형\n\na=1.2*3\na\n\n3.5999999999999996\n\n\n\ntype(a)\n\nfloat\n\n\n\na?\n\n\nType:        float\nString form: 3.5999999999999996\nDocstring:   Convert a string or number to a floating point number, if possible.\n\n\n\n- bool형\n\na=True ## 숫자1으로 생각할 수 있음 \nb=False ## 숫자0으로 생각할 수 있음\n\n\ntype(a)\n\nbool\n\n\n\ntype(b)\n\nbool\n\n\n\na?\n\n\nType:        bool\nString form: True\nDocstring:  \nbool(x) -&gt; bool\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.\n\n\n\n\nb?\n\n\nType:        bool\nString form: False\nDocstring:  \nbool(x) -&gt; bool\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.\n\n\n\n- bool형의 연산\n\na=True ## 1\nb=False ## 0 \n\n\na+b\n\n1\n\n\n\na*b \n\n0\n\n\n- 형태변환: float \\(\\to\\) int\n(예시1)\n\na=3.0\ntype(a)\n\nfloat\n\n\n\na=int(a)\n\n\ntype(a)\n\nint\n\n\n(예시2) 이경우는 정보의 손실이 발생\n\na=3.14 \nint(a)\n\n3\n\n\n- 형태변환: int \\(\\to\\) float\n\na=3\ntype(a)\n\nint\n\n\n\na=float(a)\ntype(a)\n\nfloat\n\n\n- 형태변환: bool \\(\\to\\) int/float, int/float \\(\\to\\) bool\n(예시1)\n\na=True\ntype(a)\n\nbool\n\n\n\nint(a)\n\n1\n\n\n\nfloat(a)\n\n1.0\n\n\n(예시2)\n\na=1 \nbool(a)\n\nTrue\n\n\n\na=0\nbool(a)\n\nFalse\n\n\n(예시3)\n\na=1.0\nbool(a)\n\nTrue\n\n\n\na=0.0\nbool(a)\n\nFalse"
  },
  {
    "objectID": "posts/02wk-2.html#b.-1차원-자료의-형태변환",
    "href": "posts/02wk-2.html#b.-1차원-자료의-형태변환",
    "title": "02wk-2: 파이썬은 좋은 계산기다 (2)",
    "section": "B. 1차원 자료의 형태변환",
    "text": "B. 1차원 자료의 형태변환\n- list \\(\\to\\) np.array\n\n[1,2,3]\n\n[1, 2, 3]\n\n\n\nnp.array([1,2,3])\n\narray([1, 2, 3])\n\n\n- np.array \\(\\to\\) list\n\nnp.linspace(1,10,10)\n\narray([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.])\n\n\n\nlist(np.linspace(1,10,10))\n\n[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]\n\n\n- range \\(\\to\\) list, np.array\n\nrange(10) # 이게 뭐야??\n\nrange(0, 10)\n\n\n\nlist(range(10)) # 리스트화 \n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nnp.array(range(10)) # 넘파이배열화\n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\n보충학습: range의 다양한 활용을 익혀보자.\n\nlist(range(10))\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nlist(range(0,10))\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nlist(range(3,10))\n\n[3, 4, 5, 6, 7, 8, 9]\n\n\n\nlist(range(3,10,2))\n\n[3, 5, 7, 9]\n\n\n- map 결과물 \\(\\to\\) list\n\nf = lambda x: x**2\nlist(map(f,[1,2,3])) # [f(1),f(2),f(3)]\n\n[1, 4, 9]\n\n\n- map 결과물 \\(\\to\\) np.array로는 불가능\n\nf = lambda x: x**2\nnp.array(map(f,[1,2,3]))\n\narray(&lt;map object at 0x7f3a09e887f0&gt;, dtype=object)\n\n\n\n# 아래는 가능 \nf = lambda x: x**2\nnp.array(list(map(f,[1,2,3])))\n\narray([1, 4, 9])"
  },
  {
    "objectID": "posts/02wk-2.html#a.-np.random.rand",
    "href": "posts/02wk-2.html#a.-np.random.rand",
    "title": "02wk-2: 파이썬은 좋은 계산기다 (2)",
    "section": "A. np.random.rand()",
    "text": "A. np.random.rand()\n- 0~1 사이에서 10개의 난수생성\n\nnp.random.rand(10)\n\narray([0.43345371, 0.48324862, 0.48046707, 0.41056049, 0.56188841,\n       0.58762904, 0.6645858 , 0.60568829, 0.83033841, 0.4660302 ])\n\n\n- 0~2 사이에서 10개의 난수생성\n\nnp.random.rand(10)*2\n\narray([0.44894259, 1.8416822 , 0.50164259, 1.01601855, 0.21073439,\n       1.8049244 , 0.86548008, 0.38544391, 0.13816874, 1.22858088])\n\n\n- 1~3 사이에서 10개의 난수생성\n\nnp.random.rand(10)*2 + 1\n\narray([1.58013021, 1.96358901, 2.62137695, 1.74617053, 2.38021729,\n       1.00043864, 1.42801985, 1.65666288, 2.80405753, 1.23691426])"
  },
  {
    "objectID": "posts/02wk-2.html#b.-np.random.randn",
    "href": "posts/02wk-2.html#b.-np.random.randn",
    "title": "02wk-2: 파이썬은 좋은 계산기다 (2)",
    "section": "B. np.random.randn()",
    "text": "B. np.random.randn()\n- N(0,1)에서 10개의 난수생성\n\nnp.random.randn(10) # 표준정규분포에서 10개의 샘플 추출 \n\narray([-0.88043002, -0.75000612, -0.46393189,  0.73721724, -0.66208613,\n        0.84740615, -0.31835775,  0.60157946,  0.62744116,  2.06223706])\n\n\n- N(1,1)에서 10개 난수생성\n\nnp.random.randn(10) + 1\n\narray([ 1.50801901,  0.06945884,  2.52305677,  0.25080242, -0.25058225,\n        1.81696343, -0.47341629,  0.51879014,  2.55038708,  0.58788704])\n\n\n- N(0,4) 에서 10개 난수생성\n\nnp.random.randn(10)*2\n\narray([-2.26593271, -1.62304968, -1.71372316,  2.93723947,  0.63497107,\n        2.96605112,  0.71536533,  2.64037886,  0.10782247, -2.97822434])\n\n\n- N(3,4) 에서 10개 난수생성\n\nnp.random.randn(10)*2+3 \n\narray([ 3.71923104,  1.77496469,  4.04116354,  4.27443252,  2.59130929,\n        5.48551961, -1.09164073,  3.08090641,  0.88721243,  3.34579357])"
  },
  {
    "objectID": "posts/02wk-2.html#c.-np.random.randint",
    "href": "posts/02wk-2.html#c.-np.random.randint",
    "title": "02wk-2: 파이썬은 좋은 계산기다 (2)",
    "section": "C. np.random.randint()",
    "text": "C. np.random.randint()\n- [0,7) 에서 10개의 정수생성\n\nnp.random.randint(0,7,size=10) # [0,7)의 범위에서 10개의 정수 생성 \n\narray([0, 1, 5, 0, 2, 3, 1, 3, 0, 5])\n\n\n- [10,20) 에서 10개의 정수생성\n\nnp.random.randint(10,20,size=10) # [0,7)의 범위에서 10개의 정수 생성 \n\narray([11, 10, 10, 19, 13, 11, 11, 11, 15, 19])"
  },
  {
    "objectID": "posts/02wk-2.html#d.-np.random.choice",
    "href": "posts/02wk-2.html#d.-np.random.choice",
    "title": "02wk-2: 파이썬은 좋은 계산기다 (2)",
    "section": "D. np.random.choice()",
    "text": "D. np.random.choice()\n- [11,22,33] 에서 중복허용하여 20개 추출\n\nnp.random.choice([11,22,33],20) \n\narray([33, 33, 11, 33, 11, 11, 33, 22, 11, 33, 33, 33, 22, 33, 11, 11, 22,\n       22, 33, 22])\n\n\n- [11,22,33] 에서 중복허용하여 3개 추출\n\nnp.random.seed(4)\nnp.random.choice([11,22,33],3) \n\narray([33, 33, 22])\n\n\n\nnp.random.seed(5)\nnp.random.choice([11,22,33],3) \n\narray([33, 22, 33])\n\n\n- [11,22,33] 에서 중복허용하지 않고 3개 추출\n\nnp.random.choice([11,22,33],3,replace=False) \n\narray([22, 33, 11])"
  },
  {
    "objectID": "posts/04wk-1.html",
    "href": "posts/04wk-1.html",
    "title": "04wk-1: 퀴즈3",
    "section": "",
    "text": "Caution\n\n\n\n\n전북대 학생들을 시험당일 학생증을 지참할 것. (출석체크 및 본인확인) 학생증 외에 신분증 여권등도 가능.\n부정행위 (카카오톡 채팅을 통한 코드공유, 생성형모델 사용, 대리시험 등) 적발시 F 처리함.\n퀴즈 중 지각할 경우 지각사실을 기록함. 하지만 별 다른 감점은 하지 않음.\n.ipynb 파일 형태로 제출된 답안지만 채점하며 그 외의 형식 (.hwp, .py 등)은 채점하지 않음. 즉 0점 처리함.\n\n\n\n\nimport itertools\n\n\n1. – 10점\n4개의 문자 \\(x,x,y,y\\) 를 모두 일렬로 나열하는 경우의 수를 파이썬을 이용하여 구하여라.\n\nitertools.permutations()을 이용할 것.\n\nhint: 답은 \\(\\frac{4!}{2!2!}=6\\) 이다.\n(풀이)\n\nlen(set([''.join(i) for i in itertools.permutations('xxyy')]))\n# len(set([i for i in itertools.permutations('xxyy')])) &lt;-- 이렇게 해도 결과는 같음\n\n6\n\n\n\n\n2. – 10점\n리스트 컴프리헨션을 이용하여 \\(a_n=\\frac{1}{n(n+1)}\\)을 만족하는 수열을 선언하라. (\\(a_1,a_2,\\dots,a_5\\) 까지만 선언하면 정답으로 인정)\n## 정답은 아래와 같음\n[0.5, 0.16666666666666666, 0.08333333333333333, 0.05, \n 0.03333333333333333]\n(풀이)\n\n[1/(n*(n+1)) for n in range(1,6)]\n\n[0.5, 0.16666666666666666, 0.08333333333333333, 0.05, 0.03333333333333333]\n\n\n\n\n3. – 40점\n\n(1)~(4) 까지 각 10점씩임.\n\n(1) for 문을 사용하여 아래와 같은 수열을 정의하라. (\\(a_1,\\dots,a_{100}\\) 까지 선언할 것)\n\n\\(a_1=a_2=1\\)\n\\(a_{n} = a_{n-1} + a_{n-2}\\) where \\(n\\geq 2\\)\n\n## 정답은 아래와 같음\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987,\n 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393,\n 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887,\n 9227465, 14930352, 24157817, 39088169, 63245986, 102334155,\n 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903,\n 2971215073, 4807526976, 7778742049, 12586269025, 20365011074,\n 32951280099, 53316291173, 86267571272, 139583862445, 225851433717,\n 365435296162, 591286729879, 956722026041, 1548008755920,\n 2504730781961, 4052739537881, 6557470319842, 10610209857723,\n 17167680177565, 27777890035288, 44945570212853, 72723460248141,\n 117669030460994, 190392490709135, 308061521170129, 498454011879264,\n 806515533049393, 1304969544928657, 2111485077978050,\n 3416454622906707, 5527939700884757, 8944394323791464,\n 14472334024676221, 23416728348467685, 37889062373143906,\n 61305790721611591, 99194853094755497, 160500643816367088,\n 259695496911122585, 420196140727489673, 679891637638612258,\n 1100087778366101931, 1779979416004714189, 2880067194370816120,\n 4660046610375530309, 7540113804746346429, 12200160415121876738,\n 19740274219868223167, 31940434634990099905, 51680708854858323072,\n 83621143489848422977, 135301852344706746049, 218922995834555169026,\n 354224848179261915075]\n(풀이)\n\nan = [1,1]\nfor n in range(3,101): # range(2,100) 혹은 range(98) 을 써도 결과는 같음\n    an.append(an[-1]+an[-2])\n#an\n\n(2) 3-(1)의 결과로 나온 숫자들의 자리수를 카운트하는 파이썬코드를 리스트 컴프리헨션을 이용하여 구현하라.\nhint 3-(1)를 풀지못하였더라도 아래의 리스트를 입력하면 이 문제를 풀 수 있음.\n\nlst = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987,\n 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393,\n 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887,\n 9227465, 14930352, 24157817, 39088169, 63245986, 102334155,\n 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903,\n 2971215073, 4807526976, 7778742049, 12586269025, 20365011074,\n 32951280099, 53316291173, 86267571272, 139583862445, 225851433717,\n 365435296162, 591286729879, 956722026041, 1548008755920,\n 2504730781961, 4052739537881, 6557470319842, 10610209857723,\n 17167680177565, 27777890035288, 44945570212853, 72723460248141,\n 117669030460994, 190392490709135, 308061521170129, 498454011879264,\n 806515533049393, 1304969544928657, 2111485077978050,\n 3416454622906707, 5527939700884757, 8944394323791464,\n 14472334024676221, 23416728348467685, 37889062373143906,\n 61305790721611591, 99194853094755497, 160500643816367088,\n 259695496911122585, 420196140727489673, 679891637638612258,\n 1100087778366101931, 1779979416004714189, 2880067194370816120,\n 4660046610375530309, 7540113804746346429, 12200160415121876738,\n 19740274219868223167, 31940434634990099905, 51680708854858323072,\n 83621143489848422977, 135301852344706746049, 218922995834555169026,\n 354224848179261915075]\n\nhint 아래의 코드를 이용할 것\n\nlen(str(2584)), len(str(354224848179261915075))\n\n(4, 21)\n\n\n## 답은 아래와 같다. \n[ 1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  4,\n  4,  4,  4,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  7,  7,  7,  7,\n  7,  8,  8,  8,  8,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 11, 11,\n  11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 14,\n  15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18, 18,\n  18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21 ]\n(풀이)\n\n# [len(str(i)) for i in an]\n\n(3) 3-(1)의 결과로 나온 숫자들의 유일한 숫자의 수를 카운트하는 파이썬코드를 리스트 컴프리헨션을 이용하여 구현하라. (여기에서 17711 은 유일한 숫자가 “1,7” 2개이며, 10946은 유일한 숫자가 “1,0,9,4,6” 5개 이다.\nhint 아래의 코드를 활용할 것\n\nlen(set(str(9227465)))\n\n6\n\n\n## 답은 아래와 같다. \n[ 1,  1,  1,  1,  1,  1,  2,  2,  2,  1,  2,  2,  2,  2,  3,  3,  4,\n  4,  3,  3,  5,  2,  5,  4,  4,  4,  5,  4,  5,  5,  6,  7,  6,  5,\n  6,  7,  6,  6,  7,  6,  6,  6,  4,  6,  6,  6,  7,  8,  6,  7,  8,\n  7,  7,  6,  8,  7,  7,  7,  8,  8, 10,  9, 10,  9,  6,  7,  9,  8,\n  7,  8,  9,  9,  8, 10,  8,  9,  8,  8,  7,  8,  9,  8,  8,  8,  7,\n  9,  8,  7,  7,  9,  8, 10,  9,  9,  7,  9,  8, 10,  9, 10 ]\n\n문제의 뜻이 이해안되면 질문할 것\n\n(풀이)\n\n# [len(set(str(i))) for i in an]\n\n(4) 3-(1)의 결과로 나온 숫자들 중 짝수에 해당하는 숫자가 몇개인지 카운트하는 코드를 작성하라. 코드 작성시 if가 포함된 리스트컴프리헨션을 이용하라. (numpy 이용시 부분점수 없이 0점)\n(풀이)\n\nlen([i for i in an if i %2 ==0])\n\n33\n\n\n\n\n4. – 40점\n10원짜리 동전 13개, 100원짜리 동전 17개, 500원짜리 동전 4개가 있다고 하자. 이러한 동전들로 표현할 수 있는 돈의 액수는 모두 몇 가지인가? 파이썬의 itertools 모듈을 이용하여 count하라.\n– 예시 –\n10원짜리 동전 1개, 100원짜리 동전 5개, 500원짜리 동전 1개가 있다면 표현할 수 있는 돈은 아래와 같다.\n\n\n\n경우\n10원\n100원\n500원\n총액\n\n\n\n\n경우1\n0\n0\n0\n0원\n\n\n경우2\n0\n0\n1\n500원\n\n\n경우3\n0\n1\n0\n100원\n\n\n경우4\n0\n1\n1\n600원\n\n\n경우5\n0\n2\n0\n200원\n\n\n경우6\n0\n2\n1\n700원\n\n\n경우7\n0\n3\n0\n300원\n\n\n경우8\n0\n3\n1\n800원\n\n\n경우9\n0\n4\n0\n400원\n\n\n경우10\n0\n4\n1\n900원\n\n\n경우11\n0\n5\n0\n500원\n\n\n경우12\n0\n5\n1\n1000원\n\n\n경우13\n1\n0\n0\n10원\n\n\n경우14\n1\n0\n1\n510원\n\n\n경우15\n1\n1\n0\n110원\n\n\n경우16\n1\n1\n1\n610원\n\n\n경우17\n1\n2\n0\n210원\n\n\n경우18\n1\n2\n1\n710원\n\n\n경우19\n1\n3\n0\n310원\n\n\n경우20\n1\n3\n1\n810원\n\n\n경우21\n1\n4\n0\n410원\n\n\n경우22\n1\n4\n1\n910원\n\n\n경우23\n1\n5\n0\n510원\n\n\n경우24\n1\n5\n1\n1010원\n\n\n\n여기에서 경우2와 경우11은 중복이고, 경우14와 경우23은 중복이므로 총 22개의 경우가 나온다.\n\n문제의 뜻이 이해안되면 질문할 것\n\n(풀이)\n\nlst10 = list(range(14))\nlst100 = list(range(18))\nlst500 = list(range(5)) \n\n\nlen(set([i*10+j*100+k*500 for i,j,k in itertools.product(lst10,lst100,lst500)]))\n\n384"
  },
  {
    "objectID": "posts/03wk-1.html",
    "href": "posts/03wk-1.html",
    "title": "03wk-1: 퀴즈2",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\n\n\n\n\n\nCaution\n\n\n\n\n전북대 학생들을 시험당일 학생증을 지참할 것. (출석체크 및 본인확인) 학생증 외에 신분증 여권등도 가능.\n부정행위 (카카오톡 채팅을 통한 코드공유, 생성형모델 사용, 대리시험 등) 적발시 F 처리함.\n퀴즈 중 지각할 경우 지각사실을 기록함. 하지만 별다른 감점은 하지 않음.\n.ipynb 파일 형태로 제출된 답안지만 채점하며 그 외의 형식 (.hwp, .py 등)은 채점하지 않음. 즉 0점 처리함.\n\n\n\n\n문제 1. – 10점\n\\(f(x)=x^3\\) 위의 임의의 점을 입력하면 접선을 리턴하는 함수를 구현하라. 이러한 함수를 이용하여 아래와 같은 그래프를 그려라. (범례는 표현하지 않아도 감점없음)\n\n#\n\n\n\n\n\n\n\n\n\n\\(x\\)의 범위는 \\((-5,5)\\) 이다.\n두 그래프는 \\(x=3\\) 에서 접한다.\n\n(풀이)\n\ndef make_func(x0):\n    f = lambda x: x**3\n    def func(x):\n        h = 0.0001\n        a = (f(x0+h)-f(x0))/h \n        return a*(x-x0) + f(x0)\n    return func\nx = np.linspace(-5,5,101)\ntan_line = make_func(3)\nplt.plot(x,x**3,'--')\nplt.plot(x,tan_line(x),'--')\n\n\n\n\n\n\n\n\n\n\n문제 2. – 10점1\n함수 \\(f(x)=(x+1)(x^2+3)\\)에 대하여 \\(f'(1)\\)의 값을 구하라.\n(풀이)\n\nf = lambda x: (x+1)*(x**2+3)\nh = 0.000001\n(f(1+h)-f(1))/h\n\n8.000004001473826\n\n\n\n1 2024년 수능 17번2 2024년 수능 4번 응용\n문제 3. – 10점2\n\\(0 \\leq x \\leq 4\\)의 범위에서 함수\n\\[f(x) =\\begin{cases} 3x-1 \\quad (x&lt;2) \\\\ x^2+1 \\quad (x\\geq 2) \\end{cases}\\]\n의 그래프를 그려라.\n(풀이)\n\nf = lambda x: 3*x-1 if x&lt;2 else x**2+1\nx = np.linspace(0,4,101)\nplt.plot(x,list(map(f,x)))\n\n\n\n\n\n\n\n\n\n\n문제 4. – 10점3\n\\(\\frac{3}{2}\\pi &lt; \\theta &lt; 2\\pi\\) 인 \\(\\theta\\) 에 대하여 \\(\\cos\\theta = \\frac{\\sqrt{6}}{3}\\) 일 때 \\(\\tan(\\theta)\\)의 값을 구하라.\n(풀이)\n\ntheta = np.linspace(3/2*np.pi,2*np.pi,100)\nnp.argmin(np.abs(np.cos(theta) - np.sqrt(6)/3))\n\n60\n\n\n\nnp.tan(theta[60])\n\n-0.7120967763793676\n\n\n\n3 2024년 9평 3번4 2024년 9평 25번\n문제 5. – 10점4\n함수 \\(f(x)=x+\\ln x\\)에 대하여 \\(\\int_1^{e} (1+\\frac{1}{x})f(x)dx\\)의 값은?\n(풀이)\n\nf = lambda x: x+np.log(x)\nx = np.linspace(1,np.exp(1),100)\nnp.mean((1+1/x)*f(x)) * (np.exp(1)-1)\n\n6.409521328970472\n\n\n\n\n문제 6. – 20점\n\n(2)번만 맞추어도 정답으로 인정\n\n(1) \\(f'(x)=x\\) 일 경우 \\(f(x)\\)의 그래프 개형을 그려라.\n(2) \\(f'(x)=|\\sin(x)|\\cos(x)\\) 일때 \\(f(x)\\)의 그래프 개형을 그려라.5\n5 2024년 수능 30번 변형\n\\(-3&lt;x&lt;3\\) 에서의 개형을 그릴것\n\n\n# 시각화예시\n\n\n\n\n\n\n\n\n(풀이)\n\nx = np.linspace(-3,3,101)\nff = np.abs(np.sin(x))*np.cos(x)\nf = np.cumsum(ff) * 0.06 \n\n\nplt.plot(x,ff)\nplt.plot(x,f)\n\n\n\n\n\n\n\n\n\n\n문제 7. – 30점\n첫째항이 1이고 공차가 \\(0&lt;d&lt;1\\) 인 등차수열에서, \\(\\sum_{n=1}^{75}a_n=1046.25\\) 를 만족하는 \\(d\\)를 찾아라.\n힌트1: 첫째항이 1이고 공차가 \\(d&gt;0\\)인 등차수열의 일반항은 \\(a_n = 1 +(n-1)d\\)와 같이 표현할 수 있다.\n힌트2: \\(d\\)는 아래중 하나의 값을 가진다.\n\nnp.linspace(0,1,101)[1:-1]\n\narray([0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1 , 0.11,\n       0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.2 , 0.21, 0.22,\n       0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3 , 0.31, 0.32, 0.33,\n       0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4 , 0.41, 0.42, 0.43, 0.44,\n       0.45, 0.46, 0.47, 0.48, 0.49, 0.5 , 0.51, 0.52, 0.53, 0.54, 0.55,\n       0.56, 0.57, 0.58, 0.59, 0.6 , 0.61, 0.62, 0.63, 0.64, 0.65, 0.66,\n       0.67, 0.68, 0.69, 0.7 , 0.71, 0.72, 0.73, 0.74, 0.75, 0.76, 0.77,\n       0.78, 0.79, 0.8 , 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87, 0.88,\n       0.89, 0.9 , 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99])\n\n\n(풀이)\n\ndef func(d):\n    n = np.arange(1,76)\n    an = 1+(n-1)*d\n    return np.abs(np.sum(an)-1046.25)\n\n\nd_arr = np.linspace(0,1,101)[1:-1]\nd_arr[np.argmin(list(map(func,d_arr)))]\n\n0.35000000000000003\n\n\n\n\n\n\n\n\nNote\n\n\n\n정답을 구하지 못하여도 논리전개가 올바르면 만점처리함. 노가다로 답을 구한 경우 정답으로 인정하지 않음."
  },
  {
    "objectID": "posts/06wk-2.html#a.-선언",
    "href": "posts/06wk-2.html#a.-선언",
    "title": "06wk-2: numpy (1)",
    "section": "A. 선언",
    "text": "A. 선언\n\na=np.array([1,2,3]) # list를 만들고 ndarray화 시킴 \nl=[1,2,3]"
  },
  {
    "objectID": "posts/06wk-2.html#b.-기본연산-브로드캐스팅",
    "href": "posts/06wk-2.html#b.-기본연산-브로드캐스팅",
    "title": "06wk-2: numpy (1)",
    "section": "B. 기본연산 브로드캐스팅",
    "text": "B. 기본연산 브로드캐스팅\n\na+1 ## [1,2,3] + 1 = [2,3,4]\n\narray([2, 3, 4])\n\n\n\nl+1\n\nTypeError: can only concatenate list (not \"int\") to list\n\n\n\na*2\n\narray([2, 4, 6])\n\n\n\nl*2\n\n[1, 2, 3, 1, 2, 3]\n\n\n\na/2\n\narray([0.5, 1. , 1.5])\n\n\n\nl/2\n\nTypeError: unsupported operand type(s) for /: 'list' and 'int'\n\n\n\na**2\n\narray([1, 4, 9])\n\n\n\nl**2\n\nTypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'\n\n\n\na%2 # %2 = 2로 나눈 나머지를 리턴 a=[1,2,3] \n\narray([1, 0, 1])\n\n\n\nl%2\n\nTypeError: unsupported operand type(s) for %: 'list' and 'int'"
  },
  {
    "objectID": "posts/06wk-2.html#c.-기타수학연산지원",
    "href": "posts/06wk-2.html#c.-기타수학연산지원",
    "title": "06wk-2: numpy (1)",
    "section": "C. 기타수학연산지원",
    "text": "C. 기타수학연산지원\n\nnp.sqrt(a), np.sqrt(l)\n\n(array([1.        , 1.41421356, 1.73205081]),\n array([1.        , 1.41421356, 1.73205081]))\n\n\n\nnp.log(a), np.log(l)\n\n(array([0.        , 0.69314718, 1.09861229]),\n array([0.        , 0.69314718, 1.09861229]))\n\n\n\nnp.exp(a), np.exp(l)\n\n(array([ 2.71828183,  7.3890561 , 20.08553692]),\n array([ 2.71828183,  7.3890561 , 20.08553692]))\n\n\n\nnp.sin(a), np.sin(l)\n\n(array([0.84147098, 0.90929743, 0.14112001]),\n array([0.84147098, 0.90929743, 0.14112001]))"
  },
  {
    "objectID": "posts/06wk-2.html#d.-인덱싱-1차원",
    "href": "posts/06wk-2.html#d.-인덱싱-1차원",
    "title": "06wk-2: numpy (1)",
    "section": "D. 인덱싱 1차원",
    "text": "D. 인덱싱 1차원\n- 선언\n\nl=[11,22,33,44,55,66] \na=np.array(l) \n\n- 인덱스로 접근\n\nl[0],l[1],l[2],l[3],l[-2],l[-1]\n\n(11, 22, 33, 44, 55, 66)\n\n\n\na[0],a[1],a[2],a[3],a[-2],a[-1]\n\n(11, 22, 33, 44, 55, 66)\n\n\n- : 이용 (슬라이싱)\n\nl[2:4] # index 2에서 시작, index 4는 포함하지 않음 \n\n[33, 44]\n\n\n\na[2:4] \n\narray([33, 44])\n\n\n- 정수배열에 의한 인덱싱\n\na\n\narray([11, 22, 33, 44, 55, 66])\n\n\n\na[[0,2,4]] # index=0, index=2, index=4 에 해당하는 원소를 뽑고 싶다 \n\narray([11, 33, 55])\n\n\n\nl[[0,2,4]] # 리스트는 불가능 \n\nTypeError: list indices must be integers or slices, not list\n\n\n- 부울값에 의한 인덱싱\n\na\n\narray([11, 22, 33, 44, 55, 66])\n\n\n\na[[True,False,True,False,True,False]] \n\narray([11, 33, 55])\n\n\n응용하면?\n\na &lt; 33 \n\narray([ True,  True, False, False, False, False])\n\n\n\na[a&lt;33]\n\narray([11, 22])\n\n\n리스트는 불가능\n\nl&lt;33 # 여기에서부터 불가능 \n\nTypeError: '&lt;' not supported between instances of 'list' and 'int'\n\n\n\nl[[True,False,True,False,True,False]] # 이것도 불가능 \n\nTypeError: list indices must be integers or slices, not list"
  },
  {
    "objectID": "posts/06wk-2.html#e.-인덱싱-2차원",
    "href": "posts/06wk-2.html#e.-인덱싱-2차원",
    "title": "06wk-2: numpy (1)",
    "section": "E. 인덱싱 2차원",
    "text": "E. 인덱싱 2차원\n- 중첩리스트와 2차원 np.array 선언\n\nA = [[1,2,3,4],[-1,-2,-3,-4],[5,6,7,8],[-5,-6,-7,-8]]\nA2 = np.array(A)\n\n\nA2\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n\nA\n\n[[1, 2, 3, 4], [-1, -2, -3, -4], [5, 6, 7, 8], [-5, -6, -7, -8]]\n\n\n- A의 원소 인덱싱\n\nA[0][0] # (1,1)의 원소 \n\n1\n\n\n\nA[1][2] # (2,3)의 원소 \n\n-3\n\n\n\nA[-1][0] # (4,1)의 원소 \n\n-5\n\n\n- A2의 원소 인덱싱\n\nA2[0][0] # (1,1)의 원소 \n\n1\n\n\n\nA2[1][2] # (2,3)의 원소 \n\n-3\n\n\n\nA2[-1][0] # (4,1)의 원소 \n\n-5\n\n\n- A2에서만 되는 기술 (넘파이에서 제시하는 신기술, R에서는 기본적으로 쓰던것, 이중list는 불가능)\n\nA2[0,0] # (1,1)의 원소 \n\n1\n\n\n\nA2[1,2] # (2,3)의 원소 \n\n-3\n\n\n\nA2[-1,0] # (4,1)의 원소 \n\n-5\n\n\n- 정수배열에 의한 인덱싱 & 슬라이싱!\n\nA2\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n\nA2[0,0:2] # 1행1열, 1행2열 \n\narray([1, 2])\n\n\n\nA2[0,:] # 1행 \n\narray([1, 2, 3, 4])\n\n\n\nA2[0] # 1행\n\narray([1, 2, 3, 4])\n\n\n\nA2[[0,2],:] # 1행, 3행 \n\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n\n\n\nA2[[0,2]] # 1행, 3행 \n\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n\n\n\nA2[:,0] # 1열 \n\narray([ 1, -1,  5, -5])\n\n\n\nA2[:,[0]] # 1열 \n\narray([[ 1],\n       [-1],\n       [ 5],\n       [-5]])\n\n\n\nA2[:,[0,2]] # 1열, 3열\n\narray([[ 1,  3],\n       [-1, -3],\n       [ 5,  7],\n       [-5, -7]])\n\n\n\nA2[0:2,[0,2]] # 1행~2행 //  1열,3열 \n\narray([[ 1,  3],\n       [-1, -3]])"
  },
  {
    "objectID": "posts/06wk-2.html#f.-1차원-배열의-선언",
    "href": "posts/06wk-2.html#f.-1차원-배열의-선언",
    "title": "06wk-2: numpy (1)",
    "section": "F. 1차원 배열의 선언",
    "text": "F. 1차원 배열의 선언\n- 리스트나 튜플을 선언하고 형변환\n\nnp.array((1,2,3)) # 튜플-&gt;넘파이어레이 \n\narray([1, 2, 3])\n\n\n\nnp.array([1,2,3]) # 리스트 -&gt;넘파이어레이 \n\narray([1, 2, 3])\n\n\n- range()를 이용해서 선언하고 형변환\n\nnp.array(range(10)) # range(10) -&gt; 넘파이어레이 \n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\n- np.zeros, np.ones\n\nnp.zeros(3) \n\narray([0., 0., 0.])\n\n\n\nnp.ones(4)\n\narray([1., 1., 1., 1.])\n\n\n- np.linspace\n\nnp.linspace(0,1,12) # 0에서 시작하고 1에서 끝남 (양끝점 모두 포함)\n\narray([0.        , 0.09090909, 0.18181818, 0.27272727, 0.36363636,\n       0.45454545, 0.54545455, 0.63636364, 0.72727273, 0.81818182,\n       0.90909091, 1.        ])\n\n\n\nlen(np.linspace(0,1,12)) # 길이는 12\n\n12\n\n\n- np.arange\n\nnp.arange(5) # np.array(range(5))\n\narray([0, 1, 2, 3, 4])\n\n\n\nnp.arange(1,6) # np.array(range(1,6))\n\narray([1, 2, 3, 4, 5])"
  },
  {
    "objectID": "posts/06wk-2.html#g.-reshape",
    "href": "posts/06wk-2.html#g.-reshape",
    "title": "06wk-2: numpy (1)",
    "section": "G. reshape",
    "text": "G. reshape\n- reshape: ndarray의 특수한 기능\n\na=np.array([11,22,33,44,55,66])\na ## 길이가 6인 벡터 \n\narray([11, 22, 33, 44, 55, 66])\n\n\n\na.reshape(2,3) ## (2,3) matrix 라고 생각해도 무방 \n\narray([[11, 22, 33],\n       [44, 55, 66]])\n\n\nnote: reshape은 a자체를 변화시키는것은 아님\n\na # a는 그대로 있음 \n\narray([11, 22, 33, 44, 55, 66])\n\n\n\nb= a.reshape(2,3) # a를 reshape한 결과를 b에 저장 \nb\n\narray([[11, 22, 33],\n       [44, 55, 66]])\n\n\n\na # a는 여전히 그대로 있음\n\narray([11, 22, 33, 44, 55, 66])\n\n\n- 다시 b를 a처럼 바꾸고 싶다\n\nb\n\narray([[11, 22, 33],\n       [44, 55, 66]])\n\n\n\nb.reshape(6) # b는 (2,3) matrix , 그런데 이것을 길이가 6인 벡터로 만들고 싶다. \n\narray([11, 22, 33, 44, 55, 66])\n\n\n- reshape with -1\n\na=np.arange(24) # np.array(range(24))\na\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])\n\n\n\na.reshape(2,-1)\n\narray([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]])\n\n\n\na.reshape(3,-1)\n\narray([[ 0,  1,  2,  3,  4,  5,  6,  7],\n       [ 8,  9, 10, 11, 12, 13, 14, 15],\n       [16, 17, 18, 19, 20, 21, 22, 23]])\n\n\n\na.reshape(4,-1)\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17],\n       [18, 19, 20, 21, 22, 23]])\n\n\n\na.reshape(5,-1)\n\nValueError: cannot reshape array of size 24 into shape (5,newaxis)\n\n\n\na.reshape(6,-1)\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15],\n       [16, 17, 18, 19],\n       [20, 21, 22, 23]])\n\n\n\na.reshape(7,-1)\n\nValueError: cannot reshape array of size 24 into shape (7,newaxis)\n\n\n\na.reshape(8,-1)\n\narray([[ 0,  1,  2],\n       [ 3,  4,  5],\n       [ 6,  7,  8],\n       [ 9, 10, 11],\n       [12, 13, 14],\n       [15, 16, 17],\n       [18, 19, 20],\n       [21, 22, 23]])\n\n\n\na.reshape(12,-1)\n\narray([[ 0,  1],\n       [ 2,  3],\n       [ 4,  5],\n       [ 6,  7],\n       [ 8,  9],\n       [10, 11],\n       [12, 13],\n       [14, 15],\n       [16, 17],\n       [18, 19],\n       [20, 21],\n       [22, 23]])\n\n\n\nb= a.reshape(12,-1)\nb\n\narray([[ 0,  1],\n       [ 2,  3],\n       [ 4,  5],\n       [ 6,  7],\n       [ 8,  9],\n       [10, 11],\n       [12, 13],\n       [14, 15],\n       [16, 17],\n       [18, 19],\n       [20, 21],\n       [22, 23]])\n\n\n\nb.reshape(-1) # b를 다시 길이가 24인 벡터로!\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])"
  },
  {
    "objectID": "posts/06wk-2.html#h.-2차원-배열의-선언",
    "href": "posts/06wk-2.html#h.-2차원-배열의-선언",
    "title": "06wk-2: numpy (1)",
    "section": "H. 2차원 배열의 선언",
    "text": "H. 2차원 배열의 선언\n\nnp.zeros((3,3))\n\narray([[0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.]])\n\n\n\nnp.ones((3,3))\n\narray([[1., 1., 1.],\n       [1., 1., 1.],\n       [1., 1., 1.]])\n\n\n\nnp.eye(3)\n\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n\n\n\nnp.diag([1,2,3,-1])\n\narray([[ 1,  0,  0,  0],\n       [ 0,  2,  0,  0],\n       [ 0,  0,  3,  0],\n       [ 0,  0,  0, -1]])"
  },
  {
    "objectID": "posts/06wk-2.html#i.-랜덤으로-배열-생성",
    "href": "posts/06wk-2.html#i.-랜덤으로-배열-생성",
    "title": "06wk-2: numpy (1)",
    "section": "I. 랜덤으로 배열 생성",
    "text": "I. 랜덤으로 배열 생성\n\nnp.random.randn(10) # 표쥰정규분포에서 10개를 뽑음 \n\narray([-0.33138513,  1.42650878,  1.22837316,  0.08113144, -1.0972836 ,\n        1.66641222,  0.18244459,  0.45246865, -1.22156378,  0.18756565])\n\n\n\nnp.random.rand(10) # 0~1사이에서 10개를 뽑음\n\narray([0.67642264, 0.06040223, 0.48991224, 0.32202819, 0.22195857,\n       0.31407011, 0.82567895, 0.14494499, 0.74293485, 0.37775136])\n\n\n\nnp.random.randn(4).reshape(2,2) # 표준정규분포에서 4개를 뽑고 (2,2) ndarray로 형태변환 \n\narray([[-1.1514733 , -0.82454175],\n       [-0.07976586,  0.0863252 ]])\n\n\n\nnp.random.rand(4).reshape(2,2) # 0~1 4개를 뽑고 (2,2) ndarray로 형태변환 \n\narray([[0.06084905, 0.54804885],\n       [0.64428734, 0.76590051]])"
  },
  {
    "objectID": "posts/06wk-2.html#j.-행렬관련기능",
    "href": "posts/06wk-2.html#j.-행렬관련기능",
    "title": "06wk-2: numpy (1)",
    "section": "J. 행렬관련기능",
    "text": "J. 행렬관련기능\n\nA=np.arange(4).reshape(2,2) \nA\n\narray([[0, 1],\n       [2, 3]])\n\n\n\nA.T # .T는 전치행렬을 구해줌 \n\narray([[0, 2],\n       [1, 3]])\n\n\n\nnp.linalg.inv(A) # np.linalg.inv는 역행렬을 구해주는 함수 \n\narray([[-1.5,  0.5],\n       [ 1. ,  0. ]])\n\n\n\nA @ np.linalg.inv(A) # @는 행렬곱을 수행 \n\narray([[1., 0.],\n       [0., 1.]])"
  },
  {
    "objectID": "posts/06wk-2.html#k.-2차원-배열과-연립-1차-방정식",
    "href": "posts/06wk-2.html#k.-2차원-배열과-연립-1차-방정식",
    "title": "06wk-2: numpy (1)",
    "section": "K. 2차원 배열과 연립 1차 방정식",
    "text": "K. 2차원 배열과 연립 1차 방정식\n- 아래의 연립방정식 고려\n\\(\\begin{cases} y+z+w = 3 \\\\ x+z+w = 3 \\\\ x+y+w = 3 \\\\ x+y+z = 3 \\end{cases}\\)\n- 행렬표현?\n\\(\\begin{bmatrix} 0 & 1 & 1 & 1 \\\\ 1 & 0 & 1 & 1 \\\\ 1 & 1 & 0 & 1 \\\\ 1 & 1 & 1 & 0 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ z \\\\ w \\end{bmatrix} = \\begin{bmatrix} 3 \\\\ 3 \\\\ 3 \\\\ 3 \\end{bmatrix}\\)\n- 풀이\n\nA = np.array([[0,1,1,1],[1,0,1,1],[1,1,0,1],[1,1,1,0]])\nA\n\narray([[0, 1, 1, 1],\n       [1, 0, 1, 1],\n       [1, 1, 0, 1],\n       [1, 1, 1, 0]])\n\n\n\nb= np.array([3,3,3,3]).reshape(4,1)\nb\n\narray([[3],\n       [3],\n       [3],\n       [3]])\n\n\n\nnp.linalg.inv(A) @ b \n\narray([[1.],\n       [1.],\n       [1.],\n       [1.]])\n\n\n- 다른풀이\nb를 아래와 같이 만들어도 된다.\n\nb=np.array([3,3,3,3])\nb\n\narray([3, 3, 3, 3])\n\n\n\nb.shape # b.shape은 길이가 1인 튜플로 나온다. \n\n(4,)\n\n\n\nnp.linalg.inv(A) @ b \n\narray([1., 1., 1., 1.])\n\n\n@의 유연성\n- 엄밀하게는 아래의 행렬곱이 가능하다. - (2,2) @ (2,1) =&gt; (2,1) - (1,2) @ (2,2) =&gt; (1,2)\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(2,1) \nA@b\n\narray([[ 5],\n       [11]])\n\n\n\nA.shape, b.shape, (A@b).shape\n\n((2, 2), (2, 1), (2, 1))\n\n\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(1,2) \nb@A \n\narray([[ 7, 10]])\n\n\n\nA.shape, b.shape, (b@A).shape\n\n((2, 2), (1, 2), (1, 2))\n\n\n- 당연히 아래는 성립안한다.\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(2,1) \nb@A\n\nValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 2 is different from 1)\n\n\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(1,2) \nA@b\n\nValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 1 is different from 2)\n\n\n- 아래는 어떨까? 계산가능할까? \\(\\to\\) 모두 계산가능! - (2,) @ (2,2) = (2,) - (2,2) @ (2,) = (2,)\n\nA = np.array([1,2,3,4]).reshape(2,2)\nb = np.array([1,2]) \nA@b\n\narray([ 5, 11])\n\n\n\nA.shape, b.shape, (A@b).shape \n\n((2, 2), (2,), (2,))\n\n\n\nb를 마치 (2,1)처럼 해석하여 행렬곱하고 결과는 다시 (2,) 로 만든것 같다.\n\n\nb@A\n\narray([ 7, 10])\n\n\n\nA.shape, b.shape, (b@A).shape \n\n((2, 2), (2,), (2,))\n\n\n\n이때는 \\(b\\)를 마치 (1,2)처럼 해석하여 행렬곱하고 결과는 다시 (2,)로 만든것 같다.\n\n- 아래는 어떠할까?\n\nb1 = np.array([1,2,3,4]) \nb2 = np.array([1,2,3,4]) \nb1@b2 \n\n30\n\n\n\nb1.shape, b2.shape, (b1@b2).shape \n\n((4,), (4,), ())\n\n\n\n(1,4) @ (4,1) = (1,1) 로 생각\n\n- 즉 위는 아래와 같이 해석하고 행렬곱한것과 결과가 같다.\n\nb1 = np.array([1,2,3,4]).reshape(1,4) \nb2 = np.array([1,2,3,4]).reshape(4,1) \nb1@b2 \n\narray([[30]])\n\n\n\nb1.shape, b2.shape, (b1@b2).shape \n\n((1, 4), (4, 1), (1, 1))\n\n\n- 때로는 (4,1) @ (1,4)와 같은 계산결과를 얻고 싶을 수 있는데 이때는 차원을 명시해야함\n\nb1 = np.array([1,2,3,4]).reshape(4,1) \nb2 = np.array([1,2,3,4]).reshape(1,4) \nb1@b2 \n\narray([[ 1,  2,  3,  4],\n       [ 2,  4,  6,  8],\n       [ 3,  6,  9, 12],\n       [ 4,  8, 12, 16]])"
  },
  {
    "objectID": "posts/06wk-2.html#l.-차원",
    "href": "posts/06wk-2.html#l.-차원",
    "title": "06wk-2: numpy (1)",
    "section": "L. 차원",
    "text": "L. 차원\n- 넘파이배열의 차원은 .shape 으로 확인가능\n- 아래는 모두 미묘하게 다르다.\n\na=np.array(3.14) # 스칼라, 0d array \na, a.shape\n\n(array(3.14), ())\n\n\n\na=np.array([3.14]) # 벡터, 1d array \na, a.shape\n\n(array([3.14]), (1,))\n\n\n\na=np.array([[3.14]]) # 매트릭스, 2d array \na, a.shape\n\n(array([[3.14]]), (1, 1))\n\n\n\na=np.array([[[3.14]]]) # 텐서, 3d array \na, a.shape\n\n(array([[[3.14]]]), (1, 1, 1))"
  },
  {
    "objectID": "posts/06wk-2.html#a.-np.concatenate",
    "href": "posts/06wk-2.html#a.-np.concatenate",
    "title": "06wk-2: numpy (1)",
    "section": "A. np.concatenate",
    "text": "A. np.concatenate\n- 기본예제\n\na = np.array([1,2])\nb = -a\n\n\nnp.concatenate([a,b])\n\narray([ 1,  2, -1, -2])\n\n\n\n딱히 인상적인건 아님.\n왜냐하면 리스트에서 있는 기능임\n\n- 2D인 경우\n\na = np.array([1,2,3,4]).reshape(2,2)\nb = -a\n\n\nnp.concatenate([a,b])\n\narray([[ 1,  2],\n       [ 3,  4],\n       [-1, -2],\n       [-3, -4]])\n\n\na,b를 위아래가 아니라 좌우로 붙이고 싶다면?\n\nnp.concatenate([a,b],axis=1)\n\narray([[ 1,  2, -1, -2],\n       [ 3,  4, -3, -4]])\n\n\n- 도데체 axis=0, 혹은 axis=1의 의미가 무엇인가?\n\nnp.concatenate([a,b],axis=0) # 이건 아까 np.concatenate([a,b])랑 같네?\n\narray([[ 1,  2],\n       [ 3,  4],\n       [-1, -2],\n       [-3, -4]])\n\n\n\nnp.concatenate([a,b],axis=1) # 이건 아까 np.concatenate([a,b])랑 같네?\n\narray([[ 1,  2, -1, -2],\n       [ 3,  4, -3, -4]])\n\n\n\n관찰에 의한 정리: a,b가 2차원일때 axis=0 이라고 쓰면 위아래로, axis=1이라고 하면 좌우로 합쳐진다.\naxis=0은 생략할 수 있다.\n\n- 2D일 경우에 활용\n\na = np.array([1,2,3,4]).reshape(2,2)\nb = np.array([10,20]).reshape(2,1)\nc = -b\n\n\na,b,c\n\n(array([[1, 2],\n        [3, 4]]),\n array([[10],\n        [20]]),\n array([[-10],\n        [-20]]))\n\n\n\nnp.concatenate([a,b.T],axis=0) \n\narray([[ 1,  2],\n       [ 3,  4],\n       [10, 20]])\n\n\n\nnp.concatenate([a,b.T,c.T],axis=0) \n\narray([[  1,   2],\n       [  3,   4],\n       [ 10,  20],\n       [-10, -20]])\n\n\n\nnp.concatenate([a,b],axis=1) \n\narray([[ 1,  2, 10],\n       [ 3,  4, 20]])\n\n\n\nnp.concatenate([a,b,c],axis=1) \n\narray([[  1,   2,  10, -10],\n       [  3,   4,  20, -20]])\n\n\n\nnp.concatenate([a.reshape(4,1), np.concatenate([b,c])],axis=1)\n\narray([[  1,  10],\n       [  2,  20],\n       [  3, -10],\n       [  4, -20]])\n\n\n- axis의 의미가 뭔지 궁금함. 좀 더 예제를 살펴보자.\n\na = np.arange(2*3*4).reshape(2,3,4)\nb = -a\n\n\na.shape, b.shape\n\n((2, 3, 4), (2, 3, 4))\n\n\n\nnp.concatenate([a,b],axis=0)\n\narray([[[  0,   1,   2,   3],\n        [  4,   5,   6,   7],\n        [  8,   9,  10,  11]],\n\n       [[ 12,  13,  14,  15],\n        [ 16,  17,  18,  19],\n        [ 20,  21,  22,  23]],\n\n       [[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]]])\n\n\n\nnp.concatenate([a,b],axis=1)\n\narray([[[  0,   1,   2,   3],\n        [  4,   5,   6,   7],\n        [  8,   9,  10,  11],\n        [  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[ 12,  13,  14,  15],\n        [ 16,  17,  18,  19],\n        [ 20,  21,  22,  23],\n        [-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]]])\n\n\n\nnp.concatenate([a,b],axis=2)\n\narray([[[  0,   1,   2,   3,   0,  -1,  -2,  -3],\n        [  4,   5,   6,   7,  -4,  -5,  -6,  -7],\n        [  8,   9,  10,  11,  -8,  -9, -10, -11]],\n\n       [[ 12,  13,  14,  15, -12, -13, -14, -15],\n        [ 16,  17,  18,  19, -16, -17, -18, -19],\n        [ 20,  21,  22,  23, -20, -21, -22, -23]]])\n\n\n\n이번에는 axis=2 까지 계산이 가능함\n\n\nnp.concatenate([a,b],axis=3)\n\nAxisError: axis 3 is out of bounds for array of dimension 3\n\n\n\naxis=3까지는 불가능\n\n- 뭔가 나름의 방식으로 합쳐지는것 같은데, 원리를 잘 모르겠음\n(분석) np.concatenate([a,b],axis=??)에서 ?? 의 숫자를 바꿔가면서 결과의 차원만 관찰해보자.\n\nprint(f'입력: {a.shape} concat {b.shape}')\nprint(f'출력: {np.concatenate([a,b],axis=0).shape} -- axis=0')\n\n입력: (2, 3, 4) concat (2, 3, 4)\n출력: (4, 3, 4) -- axis=0\n\n\n\nprint(f'입력: {a.shape} concat {b.shape}')\nprint(f'출력: {np.concatenate([a,b],axis=1).shape} -- axis=1')\n\n입력: (2, 3, 4) concat (2, 3, 4)\n출력: (2, 6, 4) -- axis=1\n\n\n\nprint(f'입력: {a.shape} concat {b.shape}')\nprint(f'출력: {np.concatenate([a,b],axis=2).shape} -- axis=2')\n\n입력: (2, 3, 4) concat (2, 3, 4)\n출력: (2, 3, 8) -- axis=2\n\n\n- 2D의 경우도 재해석\n\na = np.array([1,2,3,4,5,6]).reshape(3,2)\nb = -a                         \n\n좌우로 합치고 싶다면?? (3,2) concat (3,2) = (3,4) 가 되어야함 –&gt; 그러면 차원의 두번째 숫자가 바뀌어야함.\n\nnp.concatenate([a,b],axis=1)\n\narray([[ 1,  2, -1, -2],\n       [ 3,  4, -3, -4],\n       [ 5,  6, -5, -6]])\n\n\n위아래로 합치고 싶다면? (3,2) concat (3,2) = (6,2) 가 되어야함 –&gt; 그러면 차원의 첫번째 숫자가 바뀌어야함.\n\nnp.concatenate([a,b],axis=0)\n\narray([[ 1,  2],\n       [ 3,  4],\n       [ 5,  6],\n       [-1, -2],\n       [-3, -4],\n       [-5, -6]])\n\n\n- axis=-1로 넣는 경우도 있음..\n\na = np.arange(2*3*4).reshape(2,3,4)\nb = -a\n\n\na.shape, b.shape\n\n((2, 3, 4), (2, 3, 4))\n\n\n(2,3,4) concat (2,3,4) = (2,3,8) 을 만들고 싶다면?? –&gt; 세번째(axis=2)축이 바뀌어야함.\n\nnp.concatenate([a,b],axis=2).shape\n\n(2, 3, 8)\n\n\n(2,3,4) concat (2,3,4) = (2,3,8) 을 만들고 싶다면?? –&gt; 마지막(axis=-1)축이 바껴야함.\n\nnp.concatenate([a,b],axis=-1).shape\n\n(2, 3, 8)\n\n\n(2,3,4) concat (2,3,4) = (2,6,4) 을 만들고 싶다면?? –&gt; 마지막에서 두번째 (axis=-2)축이 바껴야함.\n\nnp.concatenate([a,b],axis=-2).shape\n\n(2, 6, 4)\n\n\n(2,3,4) concat (2,3,4) = (4,3,4) 을 만들고 싶다면?? –&gt; 마지막에서 세번째 (axis=-3)축이 바껴야함.\n\nnp.concatenate([a,b],axis=-3).shape\n\n(4, 3, 4)\n\n\n- 2D의 경우에도 axis=-1, axis=-2를 적용가능\n\na = np.array([1,2,3,4]).reshape(2,2)\nb = np.array([10,20]).reshape(2,1)\n\n\na,b\n\n(array([[1, 2],\n        [3, 4]]),\n array([[10],\n        [20]]))\n\n\n\nnp.concatenate([a,b],axis=-1)\n\narray([[ 1,  2, 10],\n       [ 3,  4, 20]])\n\n\n\nnp.concatenate([b.T,a],axis=-2)\n\narray([[10, 20],\n       [ 1,  2],\n       [ 3,  4]])"
  },
  {
    "objectID": "posts/06wk-2.html#b.-np.stack",
    "href": "posts/06wk-2.html#b.-np.stack",
    "title": "06wk-2: numpy (1)",
    "section": "B. np.stack",
    "text": "B. np.stack\n- 혹시 아래가 가능할까?\n\n(3,) concat (3,) = (3,2)\n\n\na = np.array([1,2,3])\nb = -a \n\n\na,b\n\n(array([1, 2, 3]), array([-1, -2, -3]))\n\n\n\nnp.concatenate([a,b],axis=1)\n\nAxisError: axis 1 is out of bounds for array of dimension 1\n\n\n\n불가능\n\n- 아래와 같은 방식은 가능\n\nnp.concatenate([a.reshape(3,1), b.reshape(3,1)],axis=1)\n\narray([[ 1, -1],\n       [ 2, -2],\n       [ 3, -3]])\n\n\n- 위의 과정을 줄여서 아래와 같이 할 수 있음.\n\nnp.stack([a,b],axis=1)\n\narray([[ 1, -1],\n       [ 2, -2],\n       [ 3, -3]])\n\n\n- 아래와 같은 결합도 가능\n\nnp.stack([a,b],axis=0)\n\narray([[ 1,  2,  3],\n       [-1, -2, -3]])\n\n\n- stack에서 axis의 역할에 대한 분석\n\na = np.arange(5*3*4).reshape(5,3,4)\nb = -a\n\n\nprint(f'입력: {a.shape} stack {b.shape}')\nprint(f'출력: {np.stack([a,b],axis=0).shape} -- axis=0')\nprint(f'출력: {np.stack([a,b],axis=1).shape} -- axis=1')\nprint(f'출력: {np.stack([a,b],axis=2).shape} -- axis=2')\nprint(f'출력: {np.stack([a,b],axis=3).shape} -- axis=3')\n#print(f'출력: {np.stack([a,b],axis=4).shape} -- axis=4')\n\n입력: (5, 3, 4) stack (5, 3, 4)\n출력: (2, 5, 3, 4) -- axis=0\n출력: (5, 2, 3, 4) -- axis=1\n출력: (5, 3, 2, 4) -- axis=2\n출력: (5, 3, 4, 2) -- axis=3\n\n\n- 다시 (3,) stack (3,) 상황을 이해하여보면\n\na = np.array([1,2,3])\nb = -a\n\na,b 모두 1차원이지만 이를 위아래로 붙여서 2차원으로 만들고 싶어. 즉 (3,) stack (3,) = (2,3) 을 만들고 싶음. -&gt; 첫번째 위치에(axis=0)에 축을 추가해야겠음.\n\nnp.stack([a,b],axis=0)\n\narray([[ 1,  2,  3],\n       [-1, -2, -3]])\n\n\na,b 모두 1차원이지만 이를 좌우로 붙여서 2차원으로 만들고 싶어. 즉 (3,) stack (3,) = (3,2) 을 만들고 싶음. -&gt; 두번째 위치에(axis=1)에 축을 추가해야겠음.\n\nnp.stack([a,b],axis=1)\n\narray([[ 1, -1],\n       [ 2, -2],\n       [ 3, -3]])\n\n\nnote: np.concatenate은 축의 총 갯수를 유지하면서 결합, np.stack은 축의 갯수를 하나 증가시키면서 결합"
  },
  {
    "objectID": "posts/06wk-2.html#c.-sum",
    "href": "posts/06wk-2.html#c.-sum",
    "title": "06wk-2: numpy (1)",
    "section": "C. sum",
    "text": "C. sum\n- 1차원\n\na = np.array([1,2,3])\na\n\narray([1, 2, 3])\n\n\n\nnp.sum(a)\n\n6\n\n\n\na.sum() \n\n6\n\n\n\na.sum(axis=0)\n\n6\n\n\n- 2차원\n\na = np.array([1,2,3,4,5,6]).reshape(3,2)\na\n\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n\n\n\na.sum() # 전체합: 1+2+3+4+5+6\n\n21\n\n\n\na.sum(axis=0) # 1열의합, 2열의합\n\narray([ 9, 12])\n\n\n\na.sum(axis=1) # 1행의합, 2행의합, 3행의합\n\narray([ 3,  7, 11])\n\n\na를 2차원 array모양으로 만들고 axis을 잘 써주면 row-wise로 합을 구하거나 column-wise로 합을 구하기 좋음.\n- 넘파이 특수기능 .sum()에서 axis의 의미를 알아보자.\n\na.shape, a.sum(axis=0).shape, a.sum(axis=1).shape\n\n((3, 2), (2,), (3,))\n\n\n- 연습\n\na = np.arange(10).reshape(5,2)\na\n\narray([[0, 1],\n       [2, 3],\n       [4, 5],\n       [6, 7],\n       [8, 9]])\n\n\n행별로 합을 구하고 싶음 -&gt; (5,2)의 차원이 (5,) 와 같이 되어야함. -&gt; 두번째축이 사라져야함\n\na.sum(axis=1)\n\narray([ 1,  5,  9, 13, 17])\n\n\n열별로 합을 구하고 싶음 -&gt; (5,2)의 차원이 (2,) 와 같이 되어야함. -&gt; 첫번째축이 사라져야함\n\na.sum(axis=0)\n\narray([20, 25])\n\n\na의 모든 원소의 합을 구하고 싶다면? -&gt; (5,2)차원이 ()와 같이 되어야함 -&gt; 첫번째축과 두번째축이 다 사라져야함\n\na.sum(axis=(0,1))\n\n45\n\n\n\na.sum() # 아 이것은 사실 a.sum(axis=(0,1)) 의 생략된 표현이었군!\n\n45"
  },
  {
    "objectID": "posts/06wk-2.html#d.-mean-std-max-min-prod",
    "href": "posts/06wk-2.html#d.-mean-std-max-min-prod",
    "title": "06wk-2: numpy (1)",
    "section": "D. mean, std, max, min, prod",
    "text": "D. mean, std, max, min, prod\n- 모두 sum과 비슷한 논리로 mean, std, max, min, prod 을 구할 수 있음\n\na = np.array([1,2,3,4,5,6,7,8]).reshape(4,2)\na\n\narray([[1, 2],\n       [3, 4],\n       [5, 6],\n       [7, 8]])\n\n\n\na.mean(axis=0), a.std(axis=0), a.max(axis=0), a.min(axis=0), a.prod(axis=0)\n\n(array([4., 5.]),\n array([2.23606798, 2.23606798]),\n array([7, 8]),\n array([1, 2]),\n array([105, 384]))\n\n\n\na.mean(axis=1), a.std(axis=1), a.max(axis=1), a.min(axis=1), a.prod(axis=1)\n\n(array([1.5, 3.5, 5.5, 7.5]),\n array([0.5, 0.5, 0.5, 0.5]),\n array([2, 4, 6, 8]),\n array([1, 3, 5, 7]),\n array([ 2, 12, 30, 56]))"
  },
  {
    "objectID": "posts/06wk-2.html#e.-argmax-argmin",
    "href": "posts/06wk-2.html#e.-argmax-argmin",
    "title": "06wk-2: numpy (1)",
    "section": "E. argmax, argmin",
    "text": "E. argmax, argmin\n- 1차원\n\na = np.array([22,-2,3,10,4])\na\n\narray([22, -2,  3, 10,  4])\n\n\n\na.argmax(),a.argmin()\n\n(0, 1)\n\n\n- 2차원\n\nnp.random.seed(43052)\na = np.random.rand(10).reshape(5,2)\na\n\narray([[0.81768226, 0.04953212],\n       [0.83868626, 0.61977707],\n       [0.12254052, 0.11712779],\n       [0.8795562 , 0.97941543],\n       [0.90986893, 0.96667407]])\n\n\n\na.argmax(axis=0),a.argmin(axis=0)\n\n(array([4, 3]), array([2, 0]))\n\n\n\na.argmax(axis=1),a.argmin(axis=1)\n\n(array([0, 0, 0, 1, 1]), array([1, 1, 1, 0, 0]))"
  },
  {
    "objectID": "posts/06wk-2.html#f.-cumsum-cumprod",
    "href": "posts/06wk-2.html#f.-cumsum-cumprod",
    "title": "06wk-2: numpy (1)",
    "section": "F. cumsum, cumprod",
    "text": "F. cumsum, cumprod\n- 1차원\n\na = np.array([1,2,3,4])\na\n\narray([1, 2, 3, 4])\n\n\n\nnp.cumsum(a), a.cumsum()\n\n(array([ 1,  3,  6, 10]), array([ 1,  3,  6, 10]))\n\n\n\nnp.cumprod(a), a.cumprod()\n\n(array([ 1,  2,  6, 24]), array([ 1,  2,  6, 24]))\n\n\n- 2차원\n\na = np.array([1,2,3,4,5,6,7,8,9,10,11,12]).reshape(4,3)\na\n\narray([[ 1,  2,  3],\n       [ 4,  5,  6],\n       [ 7,  8,  9],\n       [10, 11, 12]])\n\n\n\na.cumsum(axis=0),a.cumsum(axis=1),a.cumprod(axis=0),a.cumprod(axis=1)\n\n(array([[ 1,  2,  3],\n        [ 5,  7,  9],\n        [12, 15, 18],\n        [22, 26, 30]]),\n array([[ 1,  3,  6],\n        [ 4,  9, 15],\n        [ 7, 15, 24],\n        [10, 21, 33]]),\n array([[   1,    2,    3],\n        [   4,   10,   18],\n        [  28,   80,  162],\n        [ 280,  880, 1944]]),\n array([[   1,    2,    6],\n        [   4,   20,  120],\n        [   7,   56,  504],\n        [  10,  110, 1320]]))"
  },
  {
    "objectID": "posts/06wk-2.html#g.-diff",
    "href": "posts/06wk-2.html#g.-diff",
    "title": "06wk-2: numpy (1)",
    "section": "G. diff",
    "text": "G. diff\n- 1차원 차분\n\na = np.array([1,2,4,7,15])\na\n\narray([ 1,  2,  4,  7, 15])\n\n\n\nnp.diff(a)\n\narray([1, 2, 3, 8])\n\n\n\nnp.diff(a,prepend=100)\n\narray([-99,   1,   2,   3,   8])\n\n\n\nnp.diff(a,prepend=a[0])\n\narray([0, 1, 2, 3, 8])\n\n\n\nnp.diff(a,append=100)\n\narray([ 1,  2,  3,  8, 85])\n\n\n\nnp.diff(a,append=a[-1])\n\narray([1, 2, 3, 8, 0])\n\n\n- 2차원 array의 미분\n\na = np.arange(24).reshape(4,6)\na\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17],\n       [18, 19, 20, 21, 22, 23]])\n\n\n\nnp.diff(a,axis=0) # 열별로 연산이 적용\n\narray([[6, 6, 6, 6, 6, 6],\n       [6, 6, 6, 6, 6, 6],\n       [6, 6, 6, 6, 6, 6]])\n\n\n\nnp.diff(a,axis=1) # 행별로 연산이 적용\n\narray([[1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1]])"
  },
  {
    "objectID": "posts/01wk-2.html#a.-함수를-선언하는-두-가지-방법",
    "href": "posts/01wk-2.html#a.-함수를-선언하는-두-가지-방법",
    "title": "01wk-2: 파이썬은 좋은 계산기다 (1)",
    "section": "A. 함수를 선언하는 두 가지 방법",
    "text": "A. 함수를 선언하는 두 가지 방법\n- 방법1: def를 이용하는 방법\n\ndef f(x):\n    return x+1\n\n\nf(3)\n\n4\n\n\n- 방법2: lambda를 사용하는 방법\n\nf = lambda x: x+1\n\n\nf(3)\n\n4"
  },
  {
    "objectID": "posts/01wk-2.html#b.-list와-np.array의-차이점",
    "href": "posts/01wk-2.html#b.-list와-np.array의-차이점",
    "title": "01wk-2: 파이썬은 좋은 계산기다 (1)",
    "section": "B. list와 np.array의 차이점",
    "text": "B. list와 np.array의 차이점\n- 리스트는 수학친화적이지 않다.\n\nlst1 = [1,2,3]\nlst2 = [-1, -2, -3]\n\n\nlst1+lst2\n\n[1, 2, 3, -1, -2, -3]\n\n\n- 넘파이는 수학친화적이다.\n\narr1 = np.array([1,2,3])\narr2 = np.array([-1, -2, -3])\n\n\narr1+arr2\n\narray([0, 0, 0])"
  },
  {
    "objectID": "posts/01wk-2.html#c.-인덱스로-벡터의-원소를-뽑는-방법",
    "href": "posts/01wk-2.html#c.-인덱스로-벡터의-원소를-뽑는-방법",
    "title": "01wk-2: 파이썬은 좋은 계산기다 (1)",
    "section": "C. 인덱스로 벡터의 원소를 뽑는 방법",
    "text": "C. 인덱스로 벡터의 원소를 뽑는 방법\n\nx = [11,22,33,-22,-33,-44]\n\n- 첫번째 원소를 뽑고 싶다면?\n\nx[0]\n\n11\n\n\n- 두번째 원소를 뽑고 싶다면?\n\nx[1]\n\n22\n\n\n- 마지막 원소를 뽑고 싶다면?\n\nx[5]\n\n-44\n\n\n\nx[-1]\n\n-44\n\n\n- 마지막에서 두번째 원소를 뽑고 싶다면?\n\nx[4]\n\n-33\n\n\n\nx[-2]\n\n-33\n\n\n- index = 0,1,2 에 해당하는 원소만 추출\n\nx[0:3] # 마지막 인덱스 3은 포함되지 않음 \n\n[11, 22, 33]\n\n\n- index = 2,3,4 에 해당하는 원소만 추출\n\nx[2:5] # 2,3,4에 해당하는 인덱스만 추출\n\n[33, -22, -33]\n\n\n- x[0:3]와 같이 처음 시작점이 0인 경우 생략가능\n\nx[:3] \n\n[11, 22, 33]\n\n\n- x[k:]와 같은 코드는 index=k에서 끝까지 뽑는다는 의미이다.\n\nx[3:6] #3,4,5\n\n[-22, -33, -44]\n\n\n\nx[3:]\n\n[-22, -33, -44]"
  },
  {
    "objectID": "posts/01wk-2.html#d.-np.cumsum-np.cumprod",
    "href": "posts/01wk-2.html#d.-np.cumsum-np.cumprod",
    "title": "01wk-2: 파이썬은 좋은 계산기다 (1)",
    "section": "D. np.cumsum(), np.cumprod()",
    "text": "D. np.cumsum(), np.cumprod()\n- 누적합\n\narr = np.array([1,-1,1,-1,1,-1])\narr\n\narray([ 1, -1,  1, -1,  1, -1])\n\n\n\nnp.cumsum(arr)\n\narray([1, 0, 1, 0, 1, 0])\n\n\n- 누적곱\n\narr = np.array([1,2,3,4])\narr\n\narray([1, 2, 3, 4])\n\n\n\nnp.cumprod(arr)\n\narray([ 1,  2,  6, 24])"
  },
  {
    "objectID": "posts/01wk-2.html#e.-plt.plot",
    "href": "posts/01wk-2.html#e.-plt.plot",
    "title": "01wk-2: 파이썬은 좋은 계산기다 (1)",
    "section": "E. plt.plot()",
    "text": "E. plt.plot()\n- 예시1: \\(x\\)없이 그리기 (라인)\n\ny=[2,3,5,2]\nplt.plot(y)\n\n\n\n\n\n\n\n\n- 예시2: \\(x\\)없이 그리기 (점)\n\ny=[2,3,5,2]\nplt.plot(y,'o')\n\n\n\n\n\n\n\n\n- 예시3: \\((x,y)\\)를 전달하여 그리기(점)\n\nx=[20,21,22,23]\ny=[2,3,5,2]\nplt.plot(x,y,'o')\n\n\n\n\n\n\n\n\n- 예시4: 겹쳐서 그리기\n\nx=[20,21,22,23]\ny1=[2,3,5,-2]\ny2=[2.5 ,3.5 ,5.5 , -2.5]\nplt.plot(x,y1,'--o')\nplt.plot(x,y2,'--o')\n\n\n\n\n\n\n\n\n- 예시5: 겹쳐서 그리기 + 라벨\n\nx=[20,21,22,23]\ny1=[2,3,5,-2]\ny2=[2.5 ,3.5 ,5.5 , -2.5]\nplt.plot(x,y1,'--o',label=\"y1\")\nplt.plot(x,y2,'--o',label=\"y2\")\nplt.legend()\n\n\n\n\n\n\n\n\n- 예시5: 겹쳐서 그리기 + latex 라벨\n\nx=[20,21,22,23]\ny1=[2,3,5,-2]\ny2=[2.5 ,3.5 ,5.5 , -2.5]\nplt.plot(x,y1,'--o',label=r\"$y_1$\")\nplt.plot(x,y2,'--o',label=r\"$y_2$\")\nplt.legend()\n\n\n\n\n\n\n\n\n\nlatex수식은 이 수업에서 필수사항은 아님\nlatex수식을 사용할 수 없어도 시험점수를 획득할때 아무런 불이익이 없음."
  },
  {
    "objectID": "posts/01wk-2.html#f.-np.argmax-np.argmin",
    "href": "posts/01wk-2.html#f.-np.argmax-np.argmin",
    "title": "01wk-2: 파이썬은 좋은 계산기다 (1)",
    "section": "F. np.argmax, np.argmin",
    "text": "F. np.argmax, np.argmin\n- 예시1\n\narr = np.array([1,2,3,2,1,0])\narr\n\narray([1, 2, 3, 2, 1, 0])\n\n\n\nnp.argmax(arr),np.argmin(arr)\n\n(2, 5)\n\n\n# 예제 – 두 함수의 교점\n\\(-1 \\leq x \\leq 3\\) 에서\n\n\\(f(x)=(x-1)^2\\) 와\n\\(g(x)=-2x+5\\)\n\n의 교점의 좌표를 구하여라.\n(풀이)\n\nx = np.linspace(-1,3,101)\nf = (x-1)**2\ng = -2*x+5 \nplt.plot(x,f,label=r\"$f(x)=(x-1)^2$\")\nplt.plot(x,g,label=r\"$g(x)=-2x+5$\")\nplt.legend()\n\n\n\n\n\n\n\n\n\nx[np.argmin(abs(f-g))]\n\n2.0\n\n\n\n2,(2-1)**2\n\n(2, 1)\n\n\n\n이것이 교점의 좌표"
  },
  {
    "objectID": "posts/QuizSample.html",
    "href": "posts/QuizSample.html",
    "title": "A0: Quiz 1 (예상문제)",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt \n\n\n\n\n\n\n\nNote\n\n\n\n\n이 문항은 예시일 뿐이며, 본 문항들이 그대로 시험에 출제되지는 않음.\n일부문항은 숫자를 바꿔서 출제되거나 그대로 출제될 수 있음.\n일부문항은 모범답안이 제시되어 있음. (참고용으로..)\n예상문제를 풀기 어려운 경우 질문가능함 (힌트를 주거나 풀이를 알려줄 수 있음, 혹은 학생이 풀이한 답안을 검토하고 피드백 줄 수 있음)\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\n\n모든 문항은 부분점수 없음. (예를들어 문제1-(1)의 경우 p까지는 생성하였지만 그래프를 그리지 못한 경우 0점처리함)\n일부문항은 부분문제를 모두 맞출경우만 정답으로 인정함. 예를들면 문제2와 같은 경우.\n.ipynb 파일 형태로 제출된 답안지만 채점하며 그 외의 형식 (.hwp등)은 채점하지 않음. 즉 0점 처리함. 제출방법 모르면 물어볼것!\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n전북대 학생들을 시험당일 학생증을 지참할 것. (출석체크 및 본인확인) 학생증 외에 신분증 여권등도 가능.\n부정행위 (카카오톡 채팅을 통한 코드공유, 생성형모델 사용, 대리시험 등) 적발시 F 처리함.\n퀴즈 중 지각할 경우 지각사실을 기록함. 하지만 별다른 감점은 하지 않음.\n\n\n\n\n문제 1.\n(1) \\(0&lt;p&lt;1\\) 인 범위에서 \\(p(1-p)\\)의 그래프를 그려라. – 5점\n(풀이)\n\np = np.linspace(1/100,1,100)[:-1]\np\n\narray([0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1 , 0.11,\n       0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.2 , 0.21, 0.22,\n       0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3 , 0.31, 0.32, 0.33,\n       0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4 , 0.41, 0.42, 0.43, 0.44,\n       0.45, 0.46, 0.47, 0.48, 0.49, 0.5 , 0.51, 0.52, 0.53, 0.54, 0.55,\n       0.56, 0.57, 0.58, 0.59, 0.6 , 0.61, 0.62, 0.63, 0.64, 0.65, 0.66,\n       0.67, 0.68, 0.69, 0.7 , 0.71, 0.72, 0.73, 0.74, 0.75, 0.76, 0.77,\n       0.78, 0.79, 0.8 , 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87, 0.88,\n       0.89, 0.9 , 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99])\n\n\n\nplt.plot(p,p*(1-p))\n\n\n\n\n\n\n\n\n(2) \\(0&lt;p&lt;1\\) 의 범위에서 \\(p(1-p)\\)를 최대로 만드는 \\(p\\) 값을 파이썬을 이용하여 계산하라. – 5점\n\n# 힌트: 손으로 풀어보면 답은 0.5라는건 알겠죠? \n\n(3) 아래와 같이 50개의 숫자를 나열한 배열 \\({\\bf x}=[x_1,x_2,\\dots,x_n]\\)을 상상하자. – 10점\n\nx = np.array([0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1,\n              0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,\n              0, 0, 0, 0, 1, 0])\nx\n\narray([0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1,\n       0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,\n       0, 0, 0, 0, 1, 0])\n\n\n위와 같은 \\(x_i\\)에 대하여 아래와 같은 함수 \\(l(p)\\)를 정의하고 \\(0&lt;p&lt;1\\)에서의 \\(l(p)\\)의 그래프를 그려라.\n\\[l(p)=\\sum_{i=1}^nx_i \\log p +\\left(n-\\sum_{i=1}^{n}x_i \\right)\\log(1-p)\\]\nhint\n\n\\(n=50\\) 으로 설정해야겠죠?\n\\(\\sum_{i=1}^{50}x_i=s\\)를 미리 계산하고 \\(s\\)를 이용하여 함수 \\(l(p)=s\\log p + (50-s)\\log(1-p)\\) 를 정의하세요.\n\n\n# 시각화예시\n\n/tmp/ipykernel_74601/1320384517.py:2: RuntimeWarning: divide by zero encountered in log\n  return np.log(p)*np.sum(x) + (50-np.sum(x))*np.log(1-p)\n\n\n\n\n\n\n\n\n\n(4) 파이썬을 이용하여 아래를 근사계산하라. – 5점\n\\[\\lim_{h \\to 0}\\frac{l(0.32+h)-l(0.32)}{h}\\]\n\n# 힌트: 답은 0이에요\n\n(5) \\(0&lt;p&lt;1\\)의 범위에서 \\(l(p)\\)를 최대로 만드는 \\(p\\)의 값을 구하라. 즉 \\(\\underset{p}{\\operatorname{argmax}} l(p)\\)를 구하라. – 5점\n\n# 힌트: 답은 0.32\n\n\n\n\n\n\n\nWarning\n\n\n\n1-(5)에서 문제 오류가 있어 수정했습니다.\n\n수정전: “\\(0&lt;p&lt;1\\)” 의 범위에서 \\(l(p)\\)를 최대값을 구하라.”\n수정후: “\\(0&lt;p&lt;1\\)” 의 범위에서 \\(l(p)\\)를 최대로 만드는 \\(p\\)의 값을 구하라. 즉 \\(\\underset{p}{\\operatorname{argmax}} l(p)\\)를 구하라.”\n\n\n\n\n\n문제 2.\n\n모두 맞출 경우만 정답으로 인정\n\n(1) 아래의 list에서 마지막 원소를 뽑는 코드를 작성하라.\n\nlst = [11,22,33,44,55] \nlst \n\n[11, 22, 33, 44, 55]\n\n\n(풀이)\n\nlst[-1]\n\n55\n\n\n(2) 아래의 list에서 마지막 2개의 원소를 제외하고 뽑는 코드를 작성하라.\n\nlst = [11,22,33,44,55]\nlst\n\n[11, 22, 33, 44, 55]\n\n\n(풀이)\n\nlst[:-2]\n\n[11, 22, 33]\n\n\n(3) lambda를 이용하여 \\(f(x)=x^2+1\\)에 대응하는 함수를 선언하라.\n(4) 아래의 코드를 실행하여 x를 생성하라.\n\nnp.random.seed(43052)\nx = np.random.rand(50)\nx\n\narray([0.81768226, 0.04953212, 0.83868626, 0.61977707, 0.12254052,\n       0.11712779, 0.8795562 , 0.97941543, 0.90986893, 0.96667407,\n       0.59164493, 0.84014933, 0.89714578, 0.76530684, 0.40073371,\n       0.38061141, 0.4305124 , 0.40991094, 0.00972398, 0.59732079,\n       0.8852783 , 0.31328711, 0.6141936 , 0.36838019, 0.08044368,\n       0.47142422, 0.43324944, 0.22441988, 0.01174913, 0.91587271,\n       0.88325068, 0.32707103, 0.45758847, 0.55495369, 0.55845013,\n       0.75018778, 0.29947949, 0.85888413, 0.60465549, 0.00651133,\n       0.80605888, 0.06988897, 0.76763953, 0.72438164, 0.06247252,\n       0.97571034, 0.76681327, 0.12138996, 0.14946193, 0.08540348])\n\n\n생성된 값의 최대값을 출력하는 파이썬 코드를 작성하라.\n\n# 힌트: 답은 0.9794154308159254\n\n(5) 아래의 코드를 실행하여 x를 생성하라.\n\nnp.random.seed(43052)\nx = np.random.rand(50)\nx\n\narray([0.81768226, 0.04953212, 0.83868626, 0.61977707, 0.12254052,\n       0.11712779, 0.8795562 , 0.97941543, 0.90986893, 0.96667407,\n       0.59164493, 0.84014933, 0.89714578, 0.76530684, 0.40073371,\n       0.38061141, 0.4305124 , 0.40991094, 0.00972398, 0.59732079,\n       0.8852783 , 0.31328711, 0.6141936 , 0.36838019, 0.08044368,\n       0.47142422, 0.43324944, 0.22441988, 0.01174913, 0.91587271,\n       0.88325068, 0.32707103, 0.45758847, 0.55495369, 0.55845013,\n       0.75018778, 0.29947949, 0.85888413, 0.60465549, 0.00651133,\n       0.80605888, 0.06988897, 0.76763953, 0.72438164, 0.06247252,\n       0.97571034, 0.76681327, 0.12138996, 0.14946193, 0.08540348])\n\n\n생성된 값중 0.6와 가장 가까운 값을 출력하는 파이썬 코드를 작성하라.\n\n# 힌트: 답은 0.5973207921703583\n\n\n\n문제 3.\n(1) \\(\\frac{\\pi}{2}&lt;x&lt;\\frac{3}{2}\\pi\\) 에서 \\(f(x)=\\sin(\\frac{3}{2}x)\\) 와 \\(g(x)=\\cos(2x)\\sin(5x)\\) 의 교점의 수를 구하여라.\n(풀이)\n\nx = np.linspace(np.pi/2,3/2*np.pi,100)[:-1]\nx\n\narray([1.57079633, 1.60252959, 1.63426285, 1.6659961 , 1.69772936,\n       1.72946262, 1.76119588, 1.79292914, 1.8246624 , 1.85639566,\n       1.88812892, 1.91986218, 1.95159544, 1.9833287 , 2.01506195,\n       2.04679521, 2.07852847, 2.11026173, 2.14199499, 2.17372825,\n       2.20546151, 2.23719477, 2.26892803, 2.30066129, 2.33239455,\n       2.3641278 , 2.39586106, 2.42759432, 2.45932758, 2.49106084,\n       2.5227941 , 2.55452736, 2.58626062, 2.61799388, 2.64972714,\n       2.6814604 , 2.71319366, 2.74492691, 2.77666017, 2.80839343,\n       2.84012669, 2.87185995, 2.90359321, 2.93532647, 2.96705973,\n       2.99879299, 3.03052625, 3.06225951, 3.09399276, 3.12572602,\n       3.15745928, 3.18919254, 3.2209258 , 3.25265906, 3.28439232,\n       3.31612558, 3.34785884, 3.3795921 , 3.41132536, 3.44305862,\n       3.47479187, 3.50652513, 3.53825839, 3.56999165, 3.60172491,\n       3.63345817, 3.66519143, 3.69692469, 3.72865795, 3.76039121,\n       3.79212447, 3.82385772, 3.85559098, 3.88732424, 3.9190575 ,\n       3.95079076, 3.98252402, 4.01425728, 4.04599054, 4.0777238 ,\n       4.10945706, 4.14119032, 4.17292358, 4.20465683, 4.23639009,\n       4.26812335, 4.29985661, 4.33158987, 4.36332313, 4.39505639,\n       4.42678965, 4.45852291, 4.49025617, 4.52198943, 4.55372268,\n       4.58545594, 4.6171892 , 4.64892246, 4.68065572])\n\n\n\nplt.plot(x,np.sin(1.5*x))\nplt.plot(x,np.cos(2*x)*np.sin(5*x))\n\n\n\n\n\n\n\n\n\n# 답 3개\n\n(2) \\(a_n=\\frac{1}{n(n+1)}\\) 일때 \\(S_1,\\dots,S_{20}\\)을 구하여라."
  },
  {
    "objectID": "posts/07wk-2.html#a.-np.random.rand",
    "href": "posts/07wk-2.html#a.-np.random.rand",
    "title": "07wk-2: numpy (2)",
    "section": "A. np.random.rand()",
    "text": "A. np.random.rand()\n- 0~1사이에서 10개의 난수 생성\n\nnp.random.rand(10)\n\narray([0.01174913, 0.91587271, 0.88325068, 0.32707103, 0.45758847,\n       0.55495369, 0.55845013, 0.75018778, 0.29947949, 0.85888413])\n\n\n- 0~2사이에서 10개의 난수 생성\n\nnp.random.rand(10)*2 \n\narray([1.20931097, 0.01302267, 1.61211776, 0.13977794, 1.53527907,\n       1.44876328, 0.12494504, 1.95142067, 1.53362653, 0.24277993])\n\n\n- 1~2사이에서 10개의 난수 생성\n\nnp.random.rand(10)+1\n\narray([1.14946193, 1.08540348, 1.41658001, 1.91196224, 1.56491703,\n       1.85295256, 1.45750574, 1.26272651, 1.97333158, 1.838797  ])\n\n\n- 1~3사이에서 10개의 난수 생성\n\nnp.random.rand(10)*2+1 # 1~3\n\narray([1.61667643, 2.80011097, 1.31152492, 1.85084398, 1.73866127,\n       1.46425599, 2.51877008, 1.71378585, 1.57511749, 2.24413128])"
  },
  {
    "objectID": "posts/07wk-2.html#b.-np.random.randn",
    "href": "posts/07wk-2.html#b.-np.random.randn",
    "title": "07wk-2: numpy (2)",
    "section": "B. np.random.randn()",
    "text": "B. np.random.randn()\n- N(0,1)에서 10개 추출\n\nnp.random.randn(10) # 표준정규분포에서 10개의 샘플 추출 \n\narray([-0.16847185,  1.29054265,  0.36478515, -0.09947444, -0.82877225,\n       -0.65347034,  0.07046089, -2.46535548,  1.3927757 , -0.05533013])\n\n\n- N(1,1)에서 10개 추출\n\nnp.random.randn(10)+1 \n\narray([ 0.15876552,  0.62279321,  2.33180976,  1.17026483,  0.48580015,\n       -0.27040806,  2.74260265,  0.6414686 ,  0.8154233 ,  1.62244756])\n\n\n- N(0,4)에서 10개 추출 (평균이 0이고 분산이 4인 분포)\n\nnp.random.randn(10)*2\n\narray([ 0.90095895, -0.79682218, -2.13391486, -0.36689153, -2.84838756,\n       -1.37338419,  1.47154709,  4.37582762, -2.29684053, -0.55865428])\n\n\n- N(3,4)에서 10개 추출\n\nnp.random.randn(10)*2+3 \n\narray([ 1.99277107, -0.32804188, -1.44153951,  3.8343609 ,  1.82989546,\n        3.33888294,  2.97837722, -0.6657107 ,  3.51753206,  1.78019191])"
  },
  {
    "objectID": "posts/07wk-2.html#c.-np.random.randint",
    "href": "posts/07wk-2.html#c.-np.random.randint",
    "title": "07wk-2: numpy (2)",
    "section": "C. np.random.randint()",
    "text": "C. np.random.randint()\n- [0,7)의 범위에서 하나의 정수를 랜덤으로 생성\n\nnp.random.randint(7) # [0,7)의 범위에서 하나의 정수 생성 \n\n3\n\n\n- [0,7)의 범위에서 20개의 정수를 랜덤으로 생성\n\nnp.random.randint(7,size=(20,)) # [0,7)의 범위에서 20개의 정수 생성 \n\narray([2, 6, 2, 5, 0, 1, 0, 1, 1, 1, 6, 3, 6, 3, 0, 6, 2, 5, 4, 6])\n\n\n- [0,7)의 범위에서 (2,2) shape 으로 정수를 랜덤으로 생성\n\nnp.random.randint(7,size=(2,2)) # [0,7)의 범위에서 (2,2) shape의 정수 생성 \n\narray([[2, 0],\n       [5, 4]])\n\n\n- 위와 같은 코드를 아래와 같이 구현가능\n\nnp.random.randint(low=7,size=(5,5)) # [0,7)의 범위에서 (5,5) shape의 정수 생성 \n\narray([[4, 6, 1, 1, 3],\n       [0, 2, 4, 2, 4],\n       [4, 3, 1, 4, 0],\n       [2, 4, 5, 1, 3],\n       [1, 3, 3, 6, 5]])\n\n\n- [10,20) 의 범위에서 (5,5) shape 정수를 랜덤으로 생성\n\nnp.random.randint(low=10,high=20,size=(5,5)) # [10,20)의 범위에서 (5,5)shape의 정수생성 \n\narray([[17, 16, 10, 14, 11],\n       [12, 17, 13, 19, 10],\n       [16, 10, 14, 17, 12],\n       [16, 18, 18, 18, 19],\n       [14, 14, 12, 10, 16]])\n\n\n- 의문: np.random.randint(low=7,size=(5,5)) 가 좀 이상하다. 사실 np.random.randint(high=7,size=(5,5))가 되어야 맞지 않는가?\n-&gt; 저도 그렇게 생각하긴 하는데요, 구현이 이렇게 되어있습니다. 도움말 확인!\nReturn random integers from the \"discrete uniform\" distribution of the specified dtype in the \"half-open\" interval [`low`, `high`). If `high` is None (the default), then results are from [0, `low`)."
  },
  {
    "objectID": "posts/07wk-2.html#d.-np.random.choice",
    "href": "posts/07wk-2.html#d.-np.random.choice",
    "title": "07wk-2: numpy (2)",
    "section": "D. np.random.choice()",
    "text": "D. np.random.choice()\n- ver1\n\nnp.random.choice(5,20) # [0,5)에서 20개를 뽑음, 중복허용 \n\narray([1, 0, 1, 2, 2, 2, 2, 3, 0, 3, 3, 4, 2, 4, 4, 1, 0, 0, 3, 2])\n\n\n\n이것은 np.random.randint(5,size=(20,)) 와 같은 코드임\n\n- ver2\n\nnp.random.choice([0,1,2,3],20) # [0,1,2,3]에서 20개를 뽑음, 중복허용\n\narray([2, 0, 1, 2, 1, 2, 1, 2, 3, 0, 1, 0, 2, 1, 0, 3, 1, 0, 2, 1])\n\n\n\nnp.random.choice([\"apple\",\"orange\",\"banana\"],20)\n\narray(['orange', 'banana', 'apple', 'apple', 'orange', 'orange', 'banana',\n       'orange', 'orange', 'orange', 'orange', 'apple', 'apple', 'banana',\n       'apple', 'banana', 'banana', 'orange', 'orange', 'orange'],\n      dtype='&lt;U6')\n\n\n\nnp.random.choice([\"apple\",\"orange\",\"banana\"],2,replace=False) # 중복허용 X \n\narray(['orange', 'banana'], dtype='&lt;U6')"
  },
  {
    "objectID": "posts/07wk-2.html#e.-통계분포",
    "href": "posts/07wk-2.html#e.-통계분포",
    "title": "07wk-2: numpy (2)",
    "section": "E. 통계분포",
    "text": "E. 통계분포\n\nnp.random.binomial(n=10,p=0.2,size=(5,)) # X1, ..., X5 ~ B(10,0.2) \n\narray([4, 2, 2, 0, 3])\n\n\n\nnp.random.normal(loc=10,scale=2,size=(5,)) # X1, ..., X5 ~ N(10,4) \n\narray([ 9.01849598, 10.300486  ,  9.43740222,  9.26415294, 10.74645402])\n\n\n\nnp.radom.randn(5)*2 + 10와 같은코드\n\n\nnp.random.uniform(low=2,high=4,size=(5,)) # X1, ..., X5 ~ U(2,4) \n\narray([2.22499611, 3.94154104, 2.56319561, 3.93942319, 2.33948715])\n\n\n\nnp.random.rand(5)*2+2와 같은 코드\n\n\nnp.random.poisson(lam=5,size=(5,)) # X1,...,X5 ~ Poi(5) \n\narray([3, 6, 7, 5, 6])"
  },
  {
    "objectID": "posts/07wk-2.html#a.-np.where-np.argwhere",
    "href": "posts/07wk-2.html#a.-np.where-np.argwhere",
    "title": "07wk-2: numpy (2)",
    "section": "A. np.where, np.argwhere",
    "text": "A. np.where, np.argwhere\n- 1차원\n\na=np.array([0,0,0,1,0])\na\n\narray([0, 0, 0, 1, 0])\n\n\n\nnp.where(a==1) # 조건 a==1을 만족하는 인덱스를 출력하라!\n\n(array([3]),)\n\n\n\nnp.argwhere(a==1)\n\narray([[3]])\n\n\n- 2차원\n\nnp.random.seed(43052)\na=np.random.randn(12).reshape(3,4)\na\n\narray([[ 0.38342049,  1.0841745 ,  1.14277825,  0.30789368],\n       [ 0.23778744,  0.35595116, -1.66307542, -1.38277318],\n       [-1.92684484, -1.4862163 ,  0.00692519, -0.03488725]])\n\n\n\nnp.where(a&lt;0) # 조건을 만족하는 인덱스가 (1,2), (1,3), (2,0), (2,1), (2,3) 이라는 의미\n\n(array([1, 1, 2, 2, 2]), array([2, 3, 0, 1, 3]))\n\n\n\nnp.argwhere(a&lt;0) # 조건을 만족하는 인덱스가 (1,2), (1,3), (2,0), (2,1), (2,3) 이라는 의미\n\narray([[1, 2],\n       [1, 3],\n       [2, 0],\n       [2, 1],\n       [2, 3]])\n\n\n\na[np.where(a&lt;0)] # 조건을 만족하는 인덱스가 모두 출력 =&gt; 1차원 array로 출력 \n\narray([-1.66307542, -1.38277318, -1.92684484, -1.4862163 , -0.03488725])\n\n\n\na[np.argwhere(a&lt;0)] # 출력불가능\n\nIndexError: index 3 is out of bounds for axis 0 with size 3\n\n\n\na[np.argwhere(a&lt;0)[0][0],np.argwhere(a&lt;0)[0][1]] # 어거지로 출력할수는 있음 \n\n-1.6630754187023522\n\n\n- np.where의 특수기능\n\nnp.random.seed(43052) \na=np.random.randn(12).reshape(3,4) \na\n\narray([[ 0.38342049,  1.0841745 ,  1.14277825,  0.30789368],\n       [ 0.23778744,  0.35595116, -1.66307542, -1.38277318],\n       [-1.92684484, -1.4862163 ,  0.00692519, -0.03488725]])\n\n\n\nnp.where(a&lt;0,0,a) # a&lt;0을 체크 =&gt; 조건에 맞으면 0 =&gt; 조건에 안맞으면 a \n\narray([[0.38342049, 1.0841745 , 1.14277825, 0.30789368],\n       [0.23778744, 0.35595116, 0.        , 0.        ],\n       [0.        , 0.        , 0.00692519, 0.        ]])\n\n\n\nnp.where(a&lt;0,0,1) # a&lt;0을 체크 =&gt; 조건에 맞으면 0 =&gt; 조건에 안맞으면 1\n\narray([[1, 1, 1, 1],\n       [1, 1, 0, 0],\n       [0, 0, 1, 0]])\n\n\n- 요약 - np.where: 인덱스의 좌표를 읽는 가독성은 떨어짐. 그런데 조건에 맞는 원소를 출력하거나 처리하는 (특수기능) 목적으로는 좋은 함수\n- np.argwhere: 인덱스의 좌표를 읽는 가독성은 좋은 편임. 그런데 조건에 맞는 원소를 출력하거나 처리하는 기능은 떨어짐"
  },
  {
    "objectID": "posts/07wk-2.html#b.-인덱싱고급",
    "href": "posts/07wk-2.html#b.-인덱싱고급",
    "title": "07wk-2: numpy (2)",
    "section": "B. 인덱싱고급",
    "text": "B. 인덱싱고급\n- 원래 a는 2d array\n\na=np.arange(12).reshape(3,4)\na\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n- 경우1: 인덱싱 결과가 1d array로 나올수 있음\n\na[0,:] # 인덱싱의 결과 축의 갯수가 바뀐다! 2d array -&gt; 1d array\n\narray([0, 1, 2, 3])\n\n\n- 경우2: 물론 인덱싱 결과가 2d array로 나올 수도 있음\n\na[[0,1],:] # 이것은 축의 숫자가 유지된다. 2d array -&gt; 2d array \n\narray([[0, 1, 2, 3],\n       [4, 5, 6, 7]])\n\n\n- 경우1의 상황에서도 축의 갯수를 유지하면서 인덱싱하려면?\n\na[[0],:] # 이번에는 인덱싱의 결과 축의 갯수가 유지된다! 2d array -&gt; 2d array\n\narray([[0, 1, 2, 3]])\n\n\n\na[:,[0]] #\n\narray([[0],\n       [4],\n       [8]])\n\n\n- 미묘한 차이를 이해할것\n\na[0,:], a[[0],:]\n\n(array([0, 1, 2, 3]), array([[0, 1, 2, 3]]))\n\n\n\na[:,0], a[:,[0]]\n\n(array([0, 4, 8]),\n array([[0],\n        [4],\n        [8]]))"
  },
  {
    "objectID": "posts/07wk-2.html#c.-np.ix_",
    "href": "posts/07wk-2.html#c.-np.ix_",
    "title": "07wk-2: numpy (2)",
    "section": "C. np.ix_",
    "text": "C. np.ix_\n- 아래의 인덱싱을 비교하자.\n\na=np.arange(12).reshape(3,4)\na\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n\na[0:2,0:2]\n\narray([[0, 1],\n       [4, 5]])\n\n\n\na[[0,1],0:2]\n\narray([[0, 1],\n       [4, 5]])\n\n\n\na[0:2,[0,1]]\n\narray([[0, 1],\n       [4, 5]])\n\n\n- 언뜻 생각하면 위의 결과와 a[[0,1],[0,1]]는 결과가 동일할 것 같다.\n\na[[0,1],[0,1]]\n\narray([0, 5])\n\n\n\n실제로는 [a[0,0],a[1,1]]이 array로 나옴\n\n- 사실 np.where에서 이미 관찰하였음\n\na\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n\nnp.where(a % 5 ==0)\n\n(array([0, 1, 2]), array([0, 1, 2]))\n\n\n\na[np.where(a % 5 ==0)]\n\narray([ 0,  5, 10])\n\n\n\na[[0, 1, 2],[0, 1, 2]]\n\narray([ 0,  5, 10])\n\n\n- a[[0,1],[0,1]]이 a[0:2,0:2]를 의미하게 하려면 아래와 같이 하면 된다.\n\na[np.ix_([0,1],[0,1])]\n\narray([[0, 1],\n       [4, 5]])"
  },
  {
    "objectID": "posts/07wk-2.html#d.-note-1-메소드-도움말-확인하기",
    "href": "posts/07wk-2.html#d.-note-1-메소드-도움말-확인하기",
    "title": "07wk-2: numpy (2)",
    "section": "D. note 1: 메소드 도움말 확인하기",
    "text": "D. note 1: 메소드 도움말 확인하기\n- numpy서 sum을 수행하는 2가지 방식\n\nnp.sum(a)\na.sum()\n\n\na=np.array([1,2,3,4,5])\na\n\narray([1, 2, 3, 4, 5])\n\n\n\na.sum()\n\n15\n\n\n\nsum(a)\n\n15\n\n\n- 넘파이에서 a.sum()에 대한 도움말은 보통 np.sum()에 자세히 나와있음. \\(\\to\\) np.sum()의 도움말을 확인하고 np.sum(a)와 a.sum()이 동일함을 이용하여 a.sum()의 사용법을 미루어 유추해야함.\n\na.sum?\n\n\nDocstring:\na.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True)\nReturn the sum of the array elements over the given axis.\nRefer to `numpy.sum` for full documentation.\nSee Also\n--------\nnumpy.sum : equivalent function\nType:      builtin_function_or_method\n\n\n\n\n\nnp.sum?\n\n\nSignature:\nnp.sum(\n    a,\n    axis=None,\n    dtype=None,\n    out=None,\n    keepdims=&lt;no value&gt;,\n    initial=&lt;no value&gt;,\n    where=&lt;no value&gt;,\n)\nDocstring:\nSum of array elements over a given axis.\nParameters\n----------\na : array_like\n    Elements to sum.\naxis : None or int or tuple of ints, optional\n    Axis or axes along which a sum is performed.  The default,\n    axis=None, will sum all of the elements of the input array.  If\n    axis is negative it counts from the last to the first axis.\n    .. versionadded:: 1.7.0\n    If axis is a tuple of ints, a sum is performed on all of the axes\n    specified in the tuple instead of a single axis or all the axes as\n    before.\ndtype : dtype, optional\n    The type of the returned array and of the accumulator in which the\n    elements are summed.  The dtype of `a` is used by default unless `a`\n    has an integer dtype of less precision than the default platform\n    integer.  In that case, if `a` is signed then the platform integer\n    is used while if `a` is unsigned then an unsigned integer of the\n    same precision as the platform integer is used.\nout : ndarray, optional\n    Alternative output array in which to place the result. It must have\n    the same shape as the expected output, but the type of the output\n    values will be cast if necessary.\nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the input array.\n    If the default value is passed, then `keepdims` will not be\n    passed through to the `sum` method of sub-classes of\n    `ndarray`, however any non-default value will be.  If the\n    sub-class' method does not implement `keepdims` any\n    exceptions will be raised.\ninitial : scalar, optional\n    Starting value for the sum. See `~numpy.ufunc.reduce` for details.\n    .. versionadded:: 1.15.0\nwhere : array_like of bool, optional\n    Elements to include in the sum. See `~numpy.ufunc.reduce` for details.\n    .. versionadded:: 1.17.0\nReturns\n-------\nsum_along_axis : ndarray\n    An array with the same shape as `a`, with the specified\n    axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar\n    is returned.  If an output array is specified, a reference to\n    `out` is returned.\nSee Also\n--------\nndarray.sum : Equivalent method.\nadd.reduce : Equivalent functionality of `add`.\ncumsum : Cumulative sum of array elements.\ntrapz : Integration of array values using the composite trapezoidal rule.\nmean, average\nNotes\n-----\nArithmetic is modular when using integer types, and no error is\nraised on overflow.\nThe sum of an empty array is the neutral element 0:\n&gt;&gt;&gt; np.sum([])\n0.0\nFor floating point numbers the numerical precision of sum (and\n``np.add.reduce``) is in general limited by directly adding each number\nindividually to the result causing rounding errors in every step.\nHowever, often numpy will use a  numerically better approach (partial\npairwise summation) leading to improved precision in many use-cases.\nThis improved precision is always provided when no ``axis`` is given.\nWhen ``axis`` is given, it will depend on which axis is summed.\nTechnically, to provide the best speed possible, the improved precision\nis only used when the summation is along the fast axis in memory.\nNote that the exact precision may vary depending on other parameters.\nIn contrast to NumPy, Python's ``math.fsum`` function uses a slower but\nmore precise approach to summation.\nEspecially when summing a large number of lower precision floating point\nnumbers, such as ``float32``, numerical errors can become significant.\nIn such cases it can be advisable to use `dtype=\"float64\"` to use a higher\nprecision for the output.\nExamples\n--------\n&gt;&gt;&gt; np.sum([0.5, 1.5])\n2.0\n&gt;&gt;&gt; np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)\n1\n&gt;&gt;&gt; np.sum([[0, 1], [0, 5]])\n6\n&gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=0)\narray([0, 6])\n&gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=1)\narray([1, 5])\n&gt;&gt;&gt; np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1)\narray([1., 5.])\nIf the accumulator is too small, overflow occurs:\n&gt;&gt;&gt; np.ones(128, dtype=np.int8).sum(dtype=np.int8)\n-128\nYou can also start the sum with a value other than zero:\n&gt;&gt;&gt; np.sum([10], initial=5)\n15\nFile:      ~/anaconda3/envs/py39/lib/python3.9/site-packages/numpy/core/fromnumeric.py\nType:      function"
  },
  {
    "objectID": "posts/07wk-2.html#e.-hstack-vstack",
    "href": "posts/07wk-2.html#e.-hstack-vstack",
    "title": "07wk-2: numpy (2)",
    "section": "E. hstack, vstack",
    "text": "E. hstack, vstack\n- hstack, vstack 를 쓰는 사람도 있다.\n\na=np.arange(6) \nb=-a \n\n\nnp.vstack([a,b])\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 0, -1, -2, -3, -4, -5]])\n\n\n\nnp.stack([a,b],axis=0)\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 0, -1, -2, -3, -4, -5]])\n\n\n\nnp.hstack([a,b])\n\narray([ 0,  1,  2,  3,  4,  5,  0, -1, -2, -3, -4, -5])\n\n\n\nnp.concatenate([a,b],axis=0)\n\narray([ 0,  1,  2,  3,  4,  5,  0, -1, -2, -3, -4, -5])"
  },
  {
    "objectID": "posts/07wk-2.html#f.-append",
    "href": "posts/07wk-2.html#f.-append",
    "title": "07wk-2: numpy (2)",
    "section": "F. append",
    "text": "F. append\n- 기능1: reshape(-1) + concat\n\na=np.arange(30).reshape(5,6)\nb= -np.arange(8).reshape(2,2,2)\n\n\na.shape, b.shape\n\n((5, 6), (2, 2, 2))\n\n\n\nnp.append(a,b)\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,  0, -1, -2, -3,\n       -4, -5, -6, -7])\n\n\n\nnp.concatenate([a.reshape(-1),b.reshape(-1)])\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,  0, -1, -2, -3,\n       -4, -5, -6, -7])\n\n\n- 기능2: concat\n\na=np.arange(2*3*4).reshape(2,3,4)\nb=-a\n\n\na.shape,b.shape, np.append(a,b,axis=0).shape\n\n((2, 3, 4), (2, 3, 4), (4, 3, 4))\n\n\n\na.shape,b.shape, np.append(a,b,axis=1).shape\n\n((2, 3, 4), (2, 3, 4), (2, 6, 4))\n\n\n\na.shape,b.shape, np.append(a,b,axis=2).shape\n\n((2, 3, 4), (2, 3, 4), (2, 3, 8))\n\n\n- concat과의 차이?\n\na=np.arange(2*3*4).reshape(2,3,4)\nb=-a\nc=2*a\n\n\nnp.append(a,b,c,axis=0)\n\nTypeError: _append_dispatcher() got multiple values for argument 'axis'\n\n\n\nnp.concatenate([a,b,c],axis=0)\n\narray([[[  0,   1,   2,   3],\n        [  4,   5,   6,   7],\n        [  8,   9,  10,  11]],\n\n       [[ 12,  13,  14,  15],\n        [ 16,  17,  18,  19],\n        [ 20,  21,  22,  23]],\n\n       [[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]],\n\n       [[  0,   2,   4,   6],\n        [  8,  10,  12,  14],\n        [ 16,  18,  20,  22]],\n\n       [[ 24,  26,  28,  30],\n        [ 32,  34,  36,  38],\n        [ 40,  42,  44,  46]]])"
  },
  {
    "objectID": "posts/07wk-2.html#g.-ravel-flatten",
    "href": "posts/07wk-2.html#g.-ravel-flatten",
    "title": "07wk-2: numpy (2)",
    "section": "G. ravel, flatten",
    "text": "G. ravel, flatten\n\na=np.arange(2*3*4).reshape(2,3,4)\na\n\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n\n\n\na.reshape(-1)\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])\n\n\n\na.ravel()\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])\n\n\n\na.flatten()\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])"
  },
  {
    "objectID": "posts/07wk-2.html#h.-기타-통계함수들",
    "href": "posts/07wk-2.html#h.-기타-통계함수들",
    "title": "07wk-2: numpy (2)",
    "section": "H. 기타 통계함수들",
    "text": "H. 기타 통계함수들\n- 평균, 중앙값, 표준편차, 분산\n\na = np.random.normal(loc=0,scale=2,size=(100,))\na\n\narray([-1.12093037,  2.03228998,  0.97607763, -1.95129947, -1.49794935,\n       -2.69582142,  6.26294142,  0.17772869,  0.88248101, -0.0987605 ,\n       -2.20172938,  1.57977467, -3.70228648,  3.62666243,  0.35655652,\n        2.24552797,  1.82730641, -0.27324478,  2.96368325,  2.36722536,\n        1.00283717,  2.25966997,  0.74019075,  1.19192351,  2.70918979,\n        1.56791667, -3.9192988 ,  0.51262046,  2.1701658 ,  1.45665188,\n       -0.95216879, -0.78855745, -2.01741917, -0.93273601, -1.01042306,\n       -0.03667253,  0.4746618 , -2.55669289,  1.10739444,  1.15177071,\n       -2.96111607, -1.97698346, -1.62882279, -0.73025042, -4.41933873,\n        2.67699686, -1.49483629,  0.00726669, -0.91481464, -3.34965693,\n       -1.53808928,  0.45192716,  0.62408358,  4.00499954, -0.44609797,\n       -2.58265527, -3.66717305,  2.10773738, -0.51106569,  2.29246892,\n        2.79998629, -3.03791044,  1.89561133,  0.19501627,  0.72806721,\n       -1.50778943,  0.42474352,  0.12223567, -1.04890662, -1.9739829 ,\n       -1.4261672 , -0.20406325, -0.23939128,  1.41477338, -2.25923024,\n        1.17742253, -2.00670917,  0.1468111 , -0.57698109,  3.52781535,\n        1.71060134,  2.31381344, -1.06125884, -1.73359866,  0.21638374,\n        0.92504343,  2.50727404,  1.3510571 ,  0.62009821, -1.77908053,\n        1.85646061,  0.66264999, -1.64292395, -0.60274377, -1.1585586 ,\n       -0.66907802,  2.38660429,  1.41138093, -2.3059048 , -0.53353575])\n\n\n\nnp.mean(a)\n\n0.04457872598775192\n\n\n\nnp.median(a)\n\n0.13452338307274175\n\n\n\nnp.std(a)\n\n1.957280879505603\n\n\n\nnp.var(a)\n\n3.8309484412782266\n\n\n- corr matrix, cov matrix\n\nnp.random.seed(43052) \nx= np.random.randn(10000)\ny= np.random.randn(10000)*2\nz= np.random.randn(10000)*0.5 \n\n\nnp.corrcoef([x,y,z]).round(2)\n\narray([[ 1.  , -0.01,  0.01],\n       [-0.01,  1.  ,  0.  ],\n       [ 0.01,  0.  ,  1.  ]])\n\n\n\nnp.cov([x,y,z]).round(2)\n\narray([[ 0.99, -0.02,  0.  ],\n       [-0.02,  4.06,  0.  ],\n       [ 0.  ,  0.  ,  0.25]])"
  },
  {
    "objectID": "posts/07wk-2.html#i.-dtype",
    "href": "posts/07wk-2.html#i.-dtype",
    "title": "07wk-2: numpy (2)",
    "section": "I. dtype",
    "text": "I. dtype\n- np.array는 항상 dtype이 있다.\n\na = np.array([1,2,3])\na\n\narray([1, 2, 3])\n\n\n\na.dtype\n\ndtype('int64')\n\n\n\na = np.array([1.0,2.0,3.0])\na\n\narray([1., 2., 3.])\n\n\n\na.dtype\n\ndtype('float64')\n\n\n- 같은 int라도 int16,int32,int64으로 나누어진다.\n\na = np.array([1,2,3],dtype=np.int32)\na\n\narray([1, 2, 3], dtype=int32)\n\n\n\na.dtype\n\ndtype('int32')\n\n\n- float도 float16, float32, float64가 있다.\n\na = np.array([1,2,3],dtype=np.float32)\na\n\narray([1., 2., 3.], dtype=float32)\n\n\n- 데이터타입은 아래와 같은 방법으로 변환시킬 수 있다.\n\na = np.array([1,2,3],dtype=np.int32)\na\n\narray([1, 2, 3], dtype=int32)\n\n\n\na=a.astype(dtype=np.int64)\na\n\narray([1, 2, 3])\n\n\n\na.dtype\n\ndtype('int64')\n\n\n- 문자열의 경우\n\na = np.array(['a','b','c'])\na\n\narray(['a', 'b', 'c'], dtype='&lt;U1')\n\n\n\na = np.array(['ab','b','c'])\na\n\narray(['ab', 'b', 'c'], dtype='&lt;U2')\n\n\n\na = np.array(['abasdf','b','c'])\na\n\narray(['abasdf', 'b', 'c'], dtype='&lt;U6')\n\n\n- 문자열+숫자혼합 =&gt; 문자열로 통일\n\na= np.array(['a',1])\na\n\narray(['a', '1'], dtype='&lt;U21')\n\n\n\na= np.array(['a',1.0])\na\n\narray(['a', '1.0'], dtype='&lt;U32')\n\n\n- 숫자를 문자열로 전환\n\na= np.array([1,2,3])\na\n\narray([1, 2, 3])\n\n\n\na.astype(np.str_)\n\narray(['1', '2', '3'], dtype='&lt;U21')"
  },
  {
    "objectID": "posts/07wk-2.html#j.-브로드캐스팅과-시간측정",
    "href": "posts/07wk-2.html#j.-브로드캐스팅과-시간측정",
    "title": "07wk-2: numpy (2)",
    "section": "J. 브로드캐스팅과 시간측정",
    "text": "J. 브로드캐스팅과 시간측정\n(예비학습)\n\nimport time \n\n\nt1=time.time()\n\n\nt2=time.time()\nt2-t1\n\n0.21341419219970703\n\n\n예비학습끝\n(예제) x=[0,1,2,3,4] 인 벡터가 있다고 하자. (i,j)의 원소가 (x[i]-x[j])**2 을 의미하는 \\(5\\times 5\\) 매트릭스를 구하라.\n(풀이1)\n\nx=np.array(range(5))\nx\n\narray([0, 1, 2, 3, 4])\n\n\n\ndist = np.zeros([5,5])\ndist\n\narray([[0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.]])\n\n\n\nfor i in range(5):\n    for j in range(5):\n        dist[i,j]=(x[i]-x[j])**2\n\n\ndist\n\narray([[ 0.,  1.,  4.,  9., 16.],\n       [ 1.,  0.,  1.,  4.,  9.],\n       [ 4.,  1.,  0.,  1.,  4.],\n       [ 9.,  4.,  1.,  0.,  1.],\n       [16.,  9.,  4.,  1.,  0.]])\n\n\n(풀이2)\n\nx1=x.reshape(5,1).astype(dtype=np.float64)\nx2=x.reshape(1,5).astype(dtype=np.float64)\n\n\nx1\n\narray([[0.],\n       [1.],\n       [2.],\n       [3.],\n       [4.]])\n\n\n\nx2\n\narray([[0., 1., 2., 3., 4.]])\n\n\n\nx1-x2\n\narray([[ 0., -1., -2., -3., -4.],\n       [ 1.,  0., -1., -2., -3.],\n       [ 2.,  1.,  0., -1., -2.],\n       [ 3.,  2.,  1.,  0., -1.],\n       [ 4.,  3.,  2.,  1.,  0.]])\n\n\n\n(i,j)th element = x[i]-x[j]\n\n\n(x1-x2)**2\n\narray([[ 0.,  1.,  4.,  9., 16.],\n       [ 1.,  0.,  1.,  4.,  9.],\n       [ 4.,  1.,  0.,  1.,  4.],\n       [ 9.,  4.,  1.,  0.,  1.],\n       [16.,  9.,  4.,  1.,  0.]])\n\n\n\n\ny=np.array(range(10000))\n\n\ndist = np.zeros([10000,10000])\ndist\n\narray([[0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       ...,\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.]])\n\n\n\nt1=time.time()\nfor i in range(10000):\n    for j in range(10000):\n        dist[i,j]=(y[i]-y[j])**2\nt2=time.time()\nt2-t1\n\n37.53360199928284\n\n\n\ny1=y.reshape(10000,1).astype(np.float64)\ny2=y.reshape(1,10000).astype(np.float64)\n\n\nt1=time.time()\ndist2=(y1-y2)**2\nt2=time.time()\nt2-t1\n\n0.1297893524169922\n\n\n\n(dist-dist2).sum()\n\n0.0"
  },
  {
    "objectID": "posts/07wk-2.html#a.-회귀분석-미리보기",
    "href": "posts/07wk-2.html#a.-회귀분석-미리보기",
    "title": "07wk-2: numpy (2)",
    "section": "A. 회귀분석 미리보기",
    "text": "A. 회귀분석 미리보기\n1--7.\n1. \\(x_i\\)가 아래와 같이 주어졌다고 가정하자.\n\nx =  np.array([0.00983, 0.01098, 0.02951, 0.0384 , 0.03973, 0.04178, 0.0533 ,\n               0.058  , 0.09454, 0.1103 , 0.1328 , 0.1412 , 0.1497 , 0.1664 ,\n               0.1906 , 0.1923 , 0.198  , 0.2141 , 0.2393 , 0.2433 , 0.3157 ,\n               0.3228 , 0.3418 , 0.3552 , 0.3918 , 0.3962 , 0.4    , 0.4482 ,\n               0.496  , 0.507  , 0.53   , 0.5654 , 0.582  , 0.5854 , 0.5854 ,\n               0.6606 , 0.7007 , 0.723  , 0.7305 , 0.7383 , 0.7656 , 0.7725 ,\n               0.831  , 0.8896 , 0.9053 , 0.914  , 0.949  , 0.952  , 0.9727 ,\n               0.982  ])\n\n아래의 수식에 따라 \\(y_i\\)를 생성하라.\n\n\\(y_i = 2+3x_i +\\epsilon_i,\\quad \\epsilon_i \\overset{iid}{\\sim} N(0,1)\\)\n\n\\((x_i,y_i)\\)를 산점도를 이용하여 시각화하라.\n(풀이)\n\ny = 2+3*x + np.random.randn(50) \n\n\nplt.plot(x,y,'o',label=r'$(x_i,y_i)$')\nplt.legend()\n\n\n\n\n\n\n\n\n2. 1과 같은 자료를 잘 표현할 수 있는 적절한 추세선 \\((x_i, \\hat{y}_i)\\)를 그리기 위하여 아래의 수식을 고려하자.\n\n\\(\\hat{y}_i = ax_i+b\\)\n\na,b를 각각 아래의 표에 의하여 선택하였을 경우 추세선을 문제하단에 명시된 요구사항에 맞추어 시각화하라.\n\n\n\n\n\\(a\\)\n\\(b\\)\n\n\n\n\n(a)\n\\(1\\)\n\\(0\\)\n\n\n(b)\n\\(2.5\\)\n\\(2\\)\n\n\n(c)\n\\(3\\)\n\\(2\\)\n\n\n\n요구사항\n\n\\((x_i,y_i)\\)를 산점도로 그리고 각 (a),(b),(c)에 대한 \\((x_i,\\hat{y}_i)\\)를 lineplot으로 겹쳐그릴 것\n범례를 포함할 것\n\n\nplt.plot(x,y,'o',label=r'$(x_i,y_i)$')\nplt.plot(x,1*x+0,'--',label=r'(a) $(x_i,\\hat{y}_i)$')\nplt.plot(x,2.5*x+2,'--',label=r'(b) $(x_i,\\hat{y}_i)$')\nplt.plot(x,3*x+2,'--',label=r'(c) $(x_i,\\hat{y}_i)$')\nplt.legend()\n\n\n\n\n\n\n\n\n3. 아래를 각각 계산하라.\n(a) \\(\\frac{1}{n}\\sum_{i=1}^{n}(y_i-x_i)^2\\)\n(b) \\(\\frac{1}{n}\\sum_{i=1}^{n}(y_i-2-2.5x_i)^2\\)\n(c) \\(\\frac{1}{n}\\sum_{i=1}^{n}(y_i-2-3x_i)^2\\)\n가장 작은 값을 가지는 것은 무엇인가?\n(풀이)\n\nnp.mean((y-(1*x+0))**2), np.mean((y-(2.5*x+2))**2), np.mean((y-(3*x+2))**2)\n\n(9.883007643035032, 0.9387378995108477, 0.8266459475811891)\n\n\n가장 작은 값을 가지는 것은 (c)이다.\n4. 3의 결과를 근거로 (a)-(c)중 가장 적절한 추세선을 판단하고 적절한 순서대로 나열하라.\n(풀이)\n3-(a),(b),(c)는 각각\n\n\\(\\hat{y}_i=x_i\\)\n\\(\\hat{y}_i=2+2.5x_i\\)\n\\(\\hat{y}_i=2+3x_i\\)\n\n일 경우\n\\[{\\tt mse}({\\boldsymbol y}, \\hat{\\boldsymbol y}) = \\frac{1}{n}\\sum_{i=1}^{n}(y_i -\\hat{y}_i)^2\\]\n를 계산한 것이라 해석할 수 있다. 그런데 \\({\\tt mse}({\\boldsymbol y}, \\hat{\\boldsymbol y})\\)의 값은\n\n\\(y_1 \\approx \\hat{y}_1\\)\n\\(y_2 \\approx \\hat{y}_2\\)\n\\(\\dots\\)\n\\(y_n \\approx \\hat{y}_n\\)\n\n일수록 작은 값을 가진다. 그리고 위의 조건은 더 적절하게 추세선을 그렸을때 만족된다. 요약하면\n\n적절한 추세선을 그림 \\(\\Rightarrow\\) \\(y_i \\approx \\hat{y}_i\\) \\(\\Rightarrow\\) \\({\\tt mse}({\\boldsymbol y}, \\hat{\\boldsymbol y})\\) 값이 작아짐\n\n와 같은 관계가 있음을 파악할 수 있다. 따라서 \\({\\tt mse}({\\boldsymbol y}, \\hat{\\boldsymbol y})\\)의 값이 작을수록 적절한 추세선이라 생각할 수 있다.\n5. 아래와 같은 수식을 이용하여 \\(\\hat{\\beta}_0, \\hat{\\beta}_1\\) 을 계산하라.\n\\[\\begin{bmatrix} \\hat{\\beta}_0 \\\\ \\hat{\\beta}_1 \\end{bmatrix} = ({\\bf X}^T {\\bf X})^{-1}{\\bf X}^T {\\boldsymbol y}, \\quad {\\bf X}=\\begin{bmatrix} 1 & x_1 \\\\ 1 & x_2 \\\\ \\dots \\\\ 1 & x_n \\end{bmatrix}\\]\n(풀이)\n\nX = np.stack([[1]*50 ,x],axis=1)\nnp.linalg.inv(X.T @ X)@X.T@y \n\narray([2.02868583, 3.10073712])\n\n\n\\(\\hat{\\beta}_0=1.97914281\\) 이고 \\(\\hat{\\beta}_1= 2.90834079\\) 이다.\n6. 5에서 계산된 \\(\\hat{\\beta}_0, \\hat{\\beta}_1\\)을 각각 \\(b=\\hat{\\beta}_0, a=\\hat{\\beta}_1\\)으로 생각하고 적절한 추세선 \\((x_i, \\hat{y}_i)\\)를 그려라. (단, \\(\\hat{y}_i=ax_i+b\\) 이다)\n(풀이)\n\nb, a = np.linalg.inv(X.T @ X)@X.T@y \nyhat = a*x +b \n\n\nplt.plot(x,y,'o',label=r'$(x_i,y_i)$')\nplt.plot(x,yhat,'--',label=r'$(x_i,\\hat{y}_i)$')\nplt.legend()\n\n\n\n\n\n\n\n\n7. 4의 기준에 따르면, \\((a,b)=(3,2)\\) 일때 만들어지는 추세선과 \\((a,b)=(\\hat{\\beta}_1,\\hat{\\beta}_0)\\) 일때 만들어지는 추세선은 어떤 것이 더 적절한가?\n(풀이)\n\nnp.mean((y-(3*x+2))**2), np.mean((y-yhat)**2)\n\n(0.8266459475811891, 0.8204353969296209)"
  },
  {
    "objectID": "posts/07wk-2.html#b.-이미지-자료처리",
    "href": "posts/07wk-2.html#b.-이미지-자료처리",
    "title": "07wk-2: numpy (2)",
    "section": "B. 이미지 자료처리",
    "text": "B. 이미지 자료처리\n### – 예비학습 이미지 자료의 이해\n- plt.imshow(...) 에서 ...이 shape이 (??,??)이면 흑백이미지를 출력\n\nplt.imshow([[0,255],[0,255]],cmap='gray')\n\n\n\n\n\n\n\n\n- plt.imshow(...) 에서 ...의 shape이 (??,??,3)이면 칼라이미지를 출력\n\nr = [[0,255],[0,255]]\ng = [[255,0],[0,0]]\nb = [[0,0],[255,0]]\nplt.imshow(np.stack([r,g,b],axis=2))\n\n\n\n\n\n\n\n\n- plt.imshow(...) 에서 ...의 자료형이 int인지 float인지에 따라서 인식이 다름\n\nr = [[0,1],[0,1]]\ng = [[1,0],[0,0]]\nb = [[0,0],[1,0]]\nplt.imshow(np.stack([r,g,b],axis=2))\n\n\n\n\n\n\n\n\n\nr = [[0,1.0],[0,1.0]]\ng = [[1.0,0],[0,0]]\nb = [[0,0],[1.0,0]]\nplt.imshow(np.stack([r,g,b],axis=2))\n\n\n\n\n\n\n\n\n### – 예비학습 끝\n\n!wget https://raw.githubusercontent.com/guebin/SC2022/main/hani.jpeg\nhani = np.einsum('ijk-&gt;jik',np.array(PIL.Image.open('hani.jpeg'),dtype=np.int64)/255)\n!rm hani.jpeg\n\n--2024-04-12 10:25:35--  https://raw.githubusercontent.com/guebin/SC2022/main/hani.jpeg\nResolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.110.133, 185.199.108.133, 185.199.109.133, ...\nConnecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.110.133|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 2445959 (2.3M) [image/jpeg]\nSaving to: ‘hani.jpeg’\n\nhani.jpeg           100%[===================&gt;]   2.33M  --.-KB/s    in 0.04s   \n\n2024-04-12 10:25:36 (62.3 MB/s) - ‘hani.jpeg’ saved [2445959/2445959]\n\n\n\n\nnote: 위 코드는 코랩 혹은 리눅스기반 환경에서 동작가능.\n\n불러온 이미지는 아래와 같다.\n\nhani,hani.shape\n\n(array([[[0.44705882, 0.48627451, 0.49411765],\n         [0.43137255, 0.46666667, 0.48627451],\n         [0.45882353, 0.50196078, 0.5254902 ],\n         ...,\n         [0.6627451 , 0.6627451 , 0.70196078],\n         [0.63529412, 0.62745098, 0.67058824],\n         [0.64313725, 0.63529412, 0.67843137]],\n \n        [[0.45882353, 0.49803922, 0.50588235],\n         [0.44313725, 0.48235294, 0.49019608],\n         [0.4627451 , 0.50588235, 0.52156863],\n         ...,\n         [0.63921569, 0.63921569, 0.67843137],\n         [0.64313725, 0.63529412, 0.67843137],\n         [0.63137255, 0.62352941, 0.66666667]],\n \n        [[0.45490196, 0.49411765, 0.50196078],\n         [0.4627451 , 0.49803922, 0.51764706],\n         [0.45882353, 0.50196078, 0.5254902 ],\n         ...,\n         [0.64313725, 0.64313725, 0.68235294],\n         [0.65490196, 0.65490196, 0.69411765],\n         [0.64313725, 0.64313725, 0.68235294]],\n \n        ...,\n \n        [[0.69411765, 0.69803922, 0.70588235],\n         [0.68627451, 0.69019608, 0.69803922],\n         [0.69411765, 0.69803922, 0.70588235],\n         ...,\n         [0.60784314, 0.6       , 0.60392157],\n         [0.6       , 0.59215686, 0.59607843],\n         [0.59607843, 0.58823529, 0.59215686]],\n \n        [[0.70196078, 0.70588235, 0.71372549],\n         [0.72156863, 0.7254902 , 0.73333333],\n         [0.69019608, 0.69411765, 0.70196078],\n         ...,\n         [0.61176471, 0.60392157, 0.60784314],\n         [0.60392157, 0.59607843, 0.6       ],\n         [0.61568627, 0.60784314, 0.61176471]],\n \n        [[0.7254902 , 0.72941176, 0.7372549 ],\n         [0.73333333, 0.7372549 , 0.74509804],\n         [0.70980392, 0.71372549, 0.72156863],\n         ...,\n         [0.61176471, 0.60392157, 0.60784314],\n         [0.60392157, 0.59607843, 0.6       ],\n         [0.61960784, 0.61176471, 0.61568627]]]),\n (4032, 3024, 3))\n\n\n\n이미지는 4032 \\(\\times\\) 3024 개의 격자(픽셀)로 이루어져 있음\n\n이미지를 보는 방법은 아래와 같다.\n\nplt.imshow(hani) # 모든이미지, 하니매트릭스\n\n\n\n\n\n\n\n\n\nplt.imshow(hani[1000:1500, 1000:2000,:]) # 얼굴만 확대, 하니의 서브매트릭스 \n\n\n\n\n\n\n\n\n3. 하니이미지를 나타내는 어레이를 변형하여 빨간색을 의미하는 칼라만 남겨서 “빨간하니”를 만들고 이미지를 출력하라.\n(풀이)\n\nred_hani = hani*0 \nred_hani[:,:,0] = hani[:,:,0]\nplt.imshow(red_hani)\n\n\n\n\n\n\n\n\n4. 하니의 모든 값에 루트를 취하여 “루트하니”를 만들고 “원본하니”와 “루트하니”를 좌우로 나란히 배치하여 출력하라.\n(풀이)\n\nroot_hani = np.sqrt(hani)\nplt.imshow(np.concatenate([hani,root_hani],axis=1))\n\n\n\n\n\n\n\n\n“루트하니”의 이미지는 “원본하니”의 이미지와 비교하여 어떤가? 왜 그러한 결과가 나왔다고 생각하는가?\n5. 하니의 모든값에 아래와 같은 함수를 적용하라.\n\n\\(f(x)=\\begin{cases} \\sqrt{x} & x&gt;0.7 \\\\ x & x \\leq 0.7 \\end{cases}\\)\n\n함수의 결과로 얻어진 매트릭스를 “후광하니”라고 부르자. “원본하니”와 “후광하니”를 좌우로 나란히 배치하여 출력하라.\n\nshiny_hani = np.sqrt(hani)*(hani&gt;0.7)+hani*(hani&lt;=0.7)\nplt.imshow(np.concatenate([hani,shiny_hani],axis=1))"
  },
  {
    "objectID": "posts/07wk-2.html#c.-mnist-data",
    "href": "posts/07wk-2.html#c.-mnist-data",
    "title": "07wk-2: numpy (2)",
    "section": "C. MNIST data",
    "text": "C. MNIST data\n아래는 0~9가지의 숫자이미지가 저장된 이미지데이터를 불러오는 코드이다.\n\n# URL 설정\nurl = 'https://github.com/guebin/PP2023/raw/main/posts/02_DataScience/mnist.npz'\n# URL에서 파일 다운로드\nurllib.request.urlretrieve(url, './mnist.npz')\n\n# 데이터 로드\ndata = np.load('./mnist.npz')\nxtrain, ytrain, xtest, ytest = data['x_train'], data['y_train'], data['x_test'], data['y_test']\n\n아래는 데이터에 대한 설명이다.\n\n전체의 이미지의 수는 70000개이며, 60000개의 이미지 \\({\\tt xtrain}\\)에 10000개의 이미지는 \\({\\tt xtest}\\)에 저장되어 있다.\n이미지에 대한 라벨은 각각 \\({\\tt ytrain}\\)과 \\(\\tt ytest\\)에 저장되어 있다. 따라서 \\(\\tt ytrain\\)에는 60000개의 이미지에 해당하는 라벨이, \\(\\tt ytest\\)에는 10000개의 이미지에 해당하는 라벨이 기록되어 있다.\n보통 분석에서는 60000개의 이미지를 가지고 라벨을 맞추는 “훈련”을 하고 (\\({\\tt xtrain}\\)을 이용하여 \\({\\tt ytrain}\\)을 맞추는 방법을 학습하고), 그러한 훈련이 잘 되었는지 10000개의 이미지를 이용하여 “테스트”한다.\n위와 같은 의미로 \\(({\\tt xtrain}, {\\tt ytrain})\\) 을 training data set, \\(({\\tt xtest},{\\tt ytest})\\) 를 test data set 이라고 부른다. (ref: 위키참고)\n\n아래는 이미지자료와 시각화에 대한 설명이다.\n\n각 이미지는 (28,28) 픽셀의 흑백이미지이다. 따라서 각 이미지는 (28,28,3) 이 아니라 (28,28) 의 shape을 가진 텐서로 구성되어있다.\n흑백이미지를 시각화 하기 위해서는 plt.imshow(img, cmap='gray')를 이용한다. 여기에서 \\({\\tt img}\\)은 임의의 2차원 텐서이며 이 예제의 경우 (28,28)의 shape을 가진다.\n\n아래는 \\({\\tt xtrain}\\)의 두번째 이미지, 즉 \\({\\tt xtrain[1,:,:]}\\)를 확인하는 코드의 예시이다.\n\n# plt.imshow(xtrain[1,:,:],cmap='gray')\nplt.imshow(xtrain[1],cmap='gray') ## 같은코드임\n\n\n\n\n\n\n\n\n이 이미지에 대한 label은 \\({\\tt ytrain[1]}\\)의 값으로 확인가능하다.\n\nytrain[1]\n\n0\n\n\n이미지와 라벨을 한번에 표현하는 코드는 아래와 같이 작성가능하다.\n\nplt.imshow(xtrain[1],cmap='gray')\nplt.title('label={}'.format(ytrain[1]));\n\n\n\n\n\n\n\n\n아래는 10개의 이미지를 라벨과 함께 출력하는 코드의 예시이다.\n\nfig, ax = plt.subplots(2,5,figsize=(10,5))\n\nax[0][0].imshow(xtrain[0],cmap='gray'); ax[0][0].set_title('label={}'.format(ytrain[0]));\nax[0][1].imshow(xtrain[1],cmap='gray'); ax[0][1].set_title('label={}'.format(ytrain[1]));\nax[0][2].imshow(xtrain[2],cmap='gray'); ax[0][2].set_title('label={}'.format(ytrain[2]));\nax[0][3].imshow(xtrain[3],cmap='gray'); ax[0][3].set_title('label={}'.format(ytrain[3]));\nax[0][4].imshow(xtrain[4],cmap='gray'); ax[0][4].set_title('label={}'.format(ytrain[4]));\n\nax[1][0].imshow(xtrain[5],cmap='gray'); ax[1][0].set_title('label={}'.format(ytrain[5]));\nax[1][1].imshow(xtrain[6],cmap='gray'); ax[1][1].set_title('label={}'.format(ytrain[6]));\nax[1][2].imshow(xtrain[7],cmap='gray'); ax[1][2].set_title('label={}'.format(ytrain[7]));\nax[1][3].imshow(xtrain[8],cmap='gray'); ax[1][3].set_title('label={}'.format(ytrain[8]));\nax[1][4].imshow(xtrain[9],cmap='gray'); ax[1][4].set_title('label={}'.format(ytrain[9]));\n\nfig.tight_layout()\n\n\n\n\n\n\n\n\n(1) 70000개의 이미지중 0~9에 해당하는 이미지는 각각 몇장씩 들어있는가?\n(풀이)\n\n_y = ytrain.tolist()+ytest.tolist()\n\n\n{s:_y.count(s) for s in set(_y)}\n\n{0: 6903,\n 1: 7877,\n 2: 6990,\n 3: 7141,\n 4: 6824,\n 5: 6313,\n 6: 6876,\n 7: 7293,\n 8: 6825,\n 9: 6958}\n\n\n(2) \\({\\tt xtrain}\\)에서 손글씨 0을 의미하는 이미지만을 모아서 새로운 텐서 \\({\\tt xtrain0}\\)를 만들어라. 이 텐서에서 처음과 마지막 이미지를 출력하라.\nhint: \\({\\tt xtrain0}\\) 의 shape은 (5923,28,28)이어야 한다.\n(풀이)\n\nxtrain0 = xtrain[ytrain==0]\nxtrain0.shape\n\n(5923, 28, 28)\n\n\n\nplt.imshow(xtrain0[0],cmap='gray') # 처음이미지\n\n\n\n\n\n\n\n\n\nplt.imshow(xtrain0[-1],cmap='gray') # 마지막이미지\n\n\n\n\n\n\n\n\n(3) \\({\\tt xtrain}\\)에서 손글씨 0을 의미하는 이미지의 평균을 계산하라. 즉 아래를 계산하라.\n\n\\({\\tt xtrain0mean} = \\frac{1}{5923}\\sum_{i=1}^{5923} {\\tt xtrain0[i, :, :]}\\)\n\n계산결과를 출력하라.\n(풀이)\n\nplt.imshow(xtrain0.mean(axis=0),cmap='gray')\n\n\n\n\n\n\n\n\n(4) \\({\\tt xtrain}\\)에서 각 라벨에 대한 평균이미지를 계산하고 계산결과를 \\({\\tt imgmean}\\)에 길이가 10인 list로 저장하라. 즉 \\({\\tt imgmean}\\)은 아래와 같은 자료구조를 가지고 있어야 한다.\n\n\\({\\tt imgmean}=\\big[{\\tt imgmean[0]},\\dots, {\\tt imgmean[9]}\\big]\\)\n\\({\\tt imgmean[0]}, \\dots, {\\tt imgmean[9]}\\) 는 각각 (28,28)의 shape을 가진 numpy array\n\\({\\tt imgmean[0]}, \\dots, {\\tt imgmean[9]}\\) 는 각각 숫자 0,1, …, 9의 평균이미지를 의미\n\n\\({\\tt imgmean[0]},\\dots, {\\tt imgmean[9]}\\)를 시각화 하라.\n(풀이)\n\nimgmean = [xtrain[ytrain==i].mean(axis=0) for i in range(10)] \n\n\nfig, ax = plt.subplots(2,5,figsize=(10,5))\n\nax[0][0].imshow(imgmean[0],cmap='gray')\nax[0][1].imshow(imgmean[1],cmap='gray')\nax[0][2].imshow(imgmean[2],cmap='gray')\nax[0][3].imshow(imgmean[3],cmap='gray')\nax[0][4].imshow(imgmean[4],cmap='gray')\n\nax[1][0].imshow(imgmean[5],cmap='gray')\nax[1][1].imshow(imgmean[6],cmap='gray')\nax[1][2].imshow(imgmean[7],cmap='gray')\nax[1][3].imshow(imgmean[8],cmap='gray')\nax[1][4].imshow(imgmean[9],cmap='gray')\n\nfig.tight_layout()\n\n\n\n\n\n\n\n\n(5) \\({\\tt xtrain}\\)의 두번째 이미지와 \\({\\tt imgmean[0]}\\)의 차이를 제곱한 값의 평균을 구하라. 즉 아래를 계산하라.\n\n\\(\\frac{1}{28\\times 28} \\sum_{p=0}^{27}\\sum_{q=0}^{27}\\big({\\tt xtrain[1,p,q]}-{\\tt imgmean[0][p,q]}\\big)^2\\)\n\n(풀이)\n\nnp.mean((xtrain[1,:,:]- imgmean[0])**2)\n\n2299.9585279846365\n\n\n(6) 모든 \\(j=0,1,\\dots,9\\) 에 대하여 아래를 계산하라.\n\n\\(\\frac{1}{28\\times 28} \\sum_{p=0}^{27}\\sum_{q=0}^{27}\\big({\\tt xtrain[1,p,q]}-{\\tt imgmean[j][p,q]}\\big)^2\\)\n\n계산값이 가장 작게 나오는 \\(j\\)는 얼마인가? 위의 계산결과를 토대로 \\({\\tt xtrain}\\)의 두번째 이미지는 어떠한 숫자를 의미한다고 “분류”하는 것이 타당한가?\n\n[np.mean((xtrain[1,:,:]- imgmean[i])**2) for i in range(10)]\n\n[2299.9585279846365,\n 7474.876421640121,\n 6154.997099653264,\n 5889.84882305034,\n 6763.709480023399,\n 4616.900123430389,\n 5856.367892213506,\n 6465.999476962735,\n 5916.546346421647,\n 6385.5252510342525]\n\n\n(7) 아래와 같은 numpy array 를 생성하라.\n\\[{\\tt loss}=\n\\begin{bmatrix}\n{\\tt loss[0,0]} & \\dots & {\\tt loss[0,9]} \\\\\n{\\tt loss[1,0]} & \\dots & {\\tt loss[1,9]} \\\\\n\\dots & \\dots &  \\dots \\\\\n{\\tt loss[59999,0]}& \\dots &{\\tt loss[59999,9]} \\\\\n\\end{bmatrix}\\]\n단, \\({\\tt loss[i,j]} = \\frac{1}{28\\times 28} \\sum_{p=0}^{27}\\sum_{q=0}^{27}\\big({\\tt xtrain[i,p,q]}-{\\tt imgmean[j][p,q]}\\big)^2\\)\n위에서 생성한 \\({\\tt loss}\\)를 이용해 (6)와 같은 방식으로 \\({\\tt xtrain}\\)의 모든 이미지에 대한 분류를 수행하라.\nhint: \\({\\tt loss}\\)에서 “최소값을 가지는 원소의 인덱스를 출력”하는 함수를 각 행별로 적용하면 된다.\n(풀이)\n\nloss = np.array([[np.mean((xtrain[j,:,:]- imgmean[i])**2) for i in range(10)] for j in range(60000)])\n\n\nloss.argmin(axis=1)\n\narray([5, 0, 4, ..., 5, 6, 8])\n\n\n(8) (7)에서 수행한 분류결과와 실제 라벨 \\({\\tt ytrain}\\)을 비교하라. 얼마나 많은 결과가 일치하는지 비율을 계산하라.\n(풀이)\n\nnp.sum(ytrain == loss.argmin(axis=1)) / 60000\n\n0.8079833333333334\n\n\n(9) \\({\\tt xtrain}\\)에서 학습한 평균이미지 \\({\\tt imgmean}\\)를 바탕으로 \\({\\tt xtest}\\)의 이미지를 분류하라. 분류결과를 \\({\\tt ytest}\\)와 비교하라. 얼마나 많은 결과가 일치하는지 비율을 계산하라.\n(풀이)\n\nest = np.array([[np.mean((xtest[j,:,:]- imgmean[i])**2) for i in range(10)] for j in range(10000)]).argmin(axis=1)\n\n\nnp.sum(est == ytest)/10000\n\n0.8203\n\n\n(10) (9)의 과정에서 잘못분류된 이미지 10개를 선택하여 시각화 하라.\n\n실제 라벨과 잘못된 라벨을 구분하여 시각화 할 것\n\n\n_ytest = ytest[est != ytest]\n_xtest = xtest[est != ytest]\n_est = est[est != ytest]\n\n\nfig, ax = plt.subplots(2,5,figsize=(10,5))\n\nax[0][0].imshow(_xtest[0],cmap='gray'); ax[0][0].set_title('{}/{}'.format(_ytest[0],_est[0]));\nax[0][1].imshow(_xtest[1],cmap='gray'); ax[0][1].set_title('{}/{}'.format(_ytest[1],_est[1]));\nax[0][2].imshow(_xtest[2],cmap='gray'); ax[0][2].set_title('{}/{}'.format(_ytest[2],_est[2]));\nax[0][3].imshow(_xtest[3],cmap='gray'); ax[0][3].set_title('{}/{}'.format(_ytest[3],_est[3]));\nax[0][4].imshow(_xtest[4],cmap='gray'); ax[0][4].set_title('{}/{}'.format(_ytest[4],_est[4]));\n\nax[1][0].imshow(_xtest[5],cmap='gray'); ax[1][0].set_title('{}/{}'.format(_ytest[5],_est[5]));\nax[1][1].imshow(_xtest[6],cmap='gray'); ax[1][1].set_title('{}/{}'.format(_ytest[6],_est[6]));\nax[1][2].imshow(_xtest[7],cmap='gray'); ax[1][2].set_title('{}/{}'.format(_ytest[7],_est[7]));\nax[1][3].imshow(_xtest[8],cmap='gray'); ax[1][3].set_title('{}/{}'.format(_ytest[8],_est[8]));\nax[1][4].imshow(_xtest[9],cmap='gray'); ax[1][4].set_title('{}/{}'.format(_ytest[9],_est[9]));\n\nfig.tight_layout()"
  },
  {
    "objectID": "posts/07wk-2.html#d.-회전변환",
    "href": "posts/07wk-2.html#d.-회전변환",
    "title": "07wk-2: numpy (2)",
    "section": "D. 회전변환",
    "text": "D. 회전변환\n1-3. 아래는 우산모양의 scatter plot을 그릴 수 있는 \\((x_i,y_i)\\) 좌표값을 불러와서 시각화하는 코드이다.\n\n# 자료저장 \ndata_raw = np.array(pd.read_csv('https://raw.githubusercontent.com/guebin/2021IR/master/_notebooks/round2.csv')).T\ndata_raw\n\narray([[ 12,  12,  13, ..., 636, 636, 637],\n       [313, 314, 279, ..., 416, 417, 409]])\n\n\n\n# 저장된 자료를 x,y로 분해 \nx_raw,y_raw = data_raw\nx_raw,y_raw\n\n(array([ 12,  12,  13, ..., 636, 636, 637]),\n array([313, 314, 279, ..., 416, 417, 409]))\n\n\n\n# 시각화\nplt.figure(figsize=(6,6)) # 그림크기고정\nplt.plot(x_raw,y_raw,'o')\n\n\n\n\n\n\n\n\n1. x_raw와 y_raw를 각각 표준화하고 x, y에 저장하라. 결과를 시각화하라. 그리고 x, y를 바탕으로 data matrix를 다시 구성하라.\n(풀이)\n표준화\n\nx= (x_raw-np.mean(x_raw)) / np.std(x_raw,ddof=1)\ny= (y_raw-np.mean(y_raw)) / np.std(y_raw,ddof=1)\n\n시각화\n\nplt.figure(figsize=(6,6)) # 그림크기고정\nplt.plot(x,y,'o')\n\n\n\n\n\n\n\n\ndata matrix 재구성\n\ndata = np.array([x,y])\ndata\n\narray([[-1.79820085, -1.79820085, -1.79255336, ...,  1.72583347,\n         1.72583347,  1.73148096],\n       [-0.18390658, -0.17703046, -0.41769466, ...,  0.52433376,\n         0.53120988,  0.47620092]])\n\n\n2. 아래와 같은 규칙에 따라 \\((x_i,y_i)\\)를 \\((\\tilde{x}_i,\\tilde{y}_i\\))로 변환하라. 단 여기에서 \\(\\theta= \\frac{\\pi}{4}\\)로 가정한다.\n\n\\({\\tt xx}_i = \\tilde{x}_i = (\\cos\\theta) x_i - (\\sin\\theta) y_i\\)\n\\({\\tt yy}_i = \\tilde{y}_i = (\\sin\\theta) x_i + (\\cos\\theta) y_i\\)\n\n\\((x_i,y_i)\\)와 \\((\\tilde{x}_i, \\tilde{y}_i)\\)를 겹쳐서 시각화 하라. 이 변환이 의미하는 바는 무엇이라고 생각하는가?\n(풀이1)\n\ntheta = np.pi/4 \nxx = np.cos(theta)*x - np.sin(theta)*y\nyy = np.sin(theta)*x + np.cos(theta)*y\nplt.figure(figsize=(6,6))\nplt.plot(x,y,'o', label=r'$(x,y)$') \nplt.plot(xx,yy,'o', label=r'$(xx,yy)$')\nplt.legend()\n\n\n\n\n\n\n\n\n(풀이2)\n아래의 규칙을 다시 고려하자.\n\n\\({\\tt xx}_i = \\tilde{x}_i = (\\cos\\theta) x_i - (\\sin\\theta) y_i\\)\n\\({\\tt yy}_i = \\tilde{y}_i = (\\sin\\theta) x_i + (\\cos\\theta) y_i\\)\n\n이는 아래와 같이 재표현가능하다.\n\n\\(\\begin{cases} {\\tt xx}_1 = (\\cos\\theta)x_1 - (\\sin\\theta)y_1 \\\\ {\\tt yy}_1 = (\\sin\\theta)x_1 + (\\cos\\theta)y_1 \\end{cases}\\)\n\\(\\begin{cases} {\\tt xx}_2 = (\\cos\\theta)x_2 - (\\sin\\theta)y_2 \\\\ {\\tt yy}_2 = (\\sin\\theta)x_2 + (\\cos\\theta)y_2 \\end{cases}\\)\n\\(\\dots\\)\n\\(\\begin{cases} {\\tt xx}_n = (\\cos\\theta)x_n - (\\sin\\theta)y_1 \\\\ {\\tt yy}_n = (\\sin\\theta)x_n + (\\cos\\theta)y_n \\end{cases}\\)\n\n이는 다시 아래와 같이 재 표현가능하다.\n\n\\(\\begin{bmatrix} {\\tt xx}_1 \\\\ {\\tt yy}_1 \\end{bmatrix} = \\begin{bmatrix} \\cos\\theta & - \\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ y_1 \\end{bmatrix}\\)\n\\(\\begin{bmatrix} {\\tt xx}_2 \\\\ {\\tt yy}_2 \\end{bmatrix} = \\begin{bmatrix} \\cos\\theta & - \\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix} \\begin{bmatrix} x_2 \\\\ y_2 \\end{bmatrix}\\)\n\\(\\dots\\)\n\\(\\begin{bmatrix} {\\tt xx}_n \\\\ {\\tt yy}_n \\end{bmatrix} = \\begin{bmatrix} \\cos\\theta & - \\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix} \\begin{bmatrix} x_n \\\\ y_n \\end{bmatrix}\\)\n\n이는 다시 아래와 같이 재 표현가능하다. (이게 처음엔 생각하기 어려워요!! \\(\\star\\star\\star\\))\n\n\\(\\begin{bmatrix} {\\tt xx}_1 & {\\tt xx}_2 & \\dots & {\\tt xx}_n \\\\ {\\tt yy}_1 & {\\tt yy}_2 & \\dots & {\\tt yy}_n \\end{bmatrix} = \\begin{bmatrix} \\cos\\theta & - \\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix} \\begin{bmatrix} x_1 & x_2 & \\dots & x_n \\\\ y_1 & y_2 & \\dots & y_n \\end{bmatrix}\\)\n\n위의 수식에 맞추어 변환을 진행하면\n\ntheta = np.pi/4 \nR = np.array([[np.cos(theta), -np.sin(theta)],[np.sin(theta),np.cos(theta)]])\nR \n\narray([[ 0.70710678, -0.70710678],\n       [ 0.70710678,  0.70710678]])\n\n\n\nR @ data\n\narray([[-1.14147842, -1.14634057, -0.97217191, ...,  0.8495886 ,\n         0.84472644,  0.88761703],\n       [-1.40156161, -1.39669946, -1.56288136, ...,  1.59110851,\n         1.59597066,  1.56106683]])\n\n\n\nxx,yy = R @ data \n\n\nplt.figure(figsize=(6,6))\nplt.plot(x,y,'o', label=r'$(x,y)$') \nplt.plot(xx,yy,'o', label=r'$(xx,yy)$')\nplt.legend()\n\n\n\n\n\n\n\n\n3. 2번과 같은 변환을 8번 연속진행한 결과를 시각화하라.\n(풀이)\n\nplt.figure(figsize=(6,6))\nxx,yy=np.linalg.matrix_power(R,8) @ data\nplt.plot(x,y,'o',label=r'$data=(x,y)$') \nplt.plot(xx,yy,'o',label=r'$R^8@data=(xx,yy)$')\nplt.legend()\n\n\n\n\n\n\n\n\n4. 2번의 변환을 역변환하는 코드를 구현하라. 원본, 변환, 역변환한 자료를 순서대로 시각화 하라. 결과를 아래와 같이 저장하라.\n\n원본: \\({\\tt x}, {\\tt y}\\)\n2번변환: \\({\\tt xx}, {\\tt yy}\\)\n2번의역변환 \\({\\tt xxx}, {\\tt yyy}\\)\n\n(풀이)\n\nxx,yy = R@data \nxxx,yyy = np.linalg.inv(R)@data\n\n\nplt.figure(figsize=(6,6))\nplt.plot(x,y,'.', label=r'$data = (x,y)$') \nplt.plot(xx,yy,'.', label=r'$R@data = (xx,yy)$')\nplt.plot(xxx,yyy,'.', label=r'$R^{-1}@data = (xxx,yyy)$')\nplt.legend()"
  },
  {
    "objectID": "posts/07wk-2.html#e.-삼성전자의-주가",
    "href": "posts/07wk-2.html#e.-삼성전자의-주가",
    "title": "07wk-2: numpy (2)",
    "section": "E. 삼성전자의 주가",
    "text": "E. 삼성전자의 주가\n5-8. 시계열 자료와 이동평균\n5. 아래의 수식에 따르는 수열 \\(x_t\\)를 생성하라. 단, \\(T=1000\\) 으로 설정하고 랜덤시드는 np.random.seed(2)와 같이 설정한다.\n\n\\(x_1=\\epsilon_1\\)\n\\(x_2=\\epsilon_1+\\epsilon_2\\)\n\\(x_3=\\epsilon_1+\\epsilon_2+\\epsilon_3\\)\n\\(\\dots\\)\n\\(x_T=\\sum_{t=1}^{T} \\epsilon_t\\)\n\n생성결과를 시각화하라.\nhint 아래의 코드를 활용하면 쉽다.\n\nnp.cumsum([1,2,3,4])\n\narray([ 1,  3,  6, 10])\n\n\n(풀이)\n\nT = 1000\nnp.random.seed(2)\nepsilon = np.random.randn(1000)\nx = epsilon.cumsum()\nplt.plot(x)\n\n\n\n\n\n\n\n\n6. 아래와 같은 변환을 수행하고 결과를 시각화 하라.\n\n\\({\\tt xx}_1= \\frac{1}{3}(x_1+x_2)\\)\n\\({\\tt xx}_2= \\frac{1}{3}(x_1+x_2+x_3)\\)\n\\({\\tt xx}_3= \\frac{1}{3}(x_2+x_3+x_4)\\)\n\\(\\dots\\)\n\\({\\tt xx}_{T-1}= \\frac{1}{3}(x_{T-1}+x_{T-1}+x_T)\\)\n\\({\\tt xx}_{T}= \\frac{1}{3}(x_{T-1}+x_T)\\)\n\nhint 아래의 수식을 이용하라.\n\n\\(\\begin{bmatrix} {\\tt xx}_1 \\\\ {\\tt xx}_2 \\\\ {\\tt xx}_3 \\\\ \\dots \\\\ {\\tt xx}_{T-1} \\\\ {\\tt xx}_T \\end{bmatrix}= \\begin{bmatrix} 1/3 & 1/3 & 0 & 0 & 0 & \\dots & 0 & 0 & 0 & 0 \\\\ 1/3 & 1/3 & 1/3 & 0 & 0 & \\dots & 0 & 0 & 0 & 0 \\\\ 0 & 1/3 & 1/3 & 1/3 & 0 & \\dots & 0 & 0 & 0 & 0 \\\\ \\dots & \\dots & \\dots & \\dots & \\dots & \\dots & \\dots & \\dots & \\dots & \\dots \\\\ 0 & 0 & 0 & 0 & 0 & \\dots & 0 & 1/3 & 1/3 & 1/3 \\\\ 0 & 0 & 0 & 0 & 0 & \\dots & 0 & 0 & 1/3 & 1/3 \\\\ \\end{bmatrix}\\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ \\dots \\\\ x_{T-1} \\\\ x_T \\end{bmatrix}\\)\n\n(풀이)\n\nM = np.array([[abs(i-j)&lt;2 for i in range(T)] for j in range(T)])*1/3\nM\n\narray([[0.33333333, 0.33333333, 0.        , ..., 0.        , 0.        ,\n        0.        ],\n       [0.33333333, 0.33333333, 0.33333333, ..., 0.        , 0.        ,\n        0.        ],\n       [0.        , 0.33333333, 0.33333333, ..., 0.        , 0.        ,\n        0.        ],\n       ...,\n       [0.        , 0.        , 0.        , ..., 0.33333333, 0.33333333,\n        0.        ],\n       [0.        , 0.        , 0.        , ..., 0.33333333, 0.33333333,\n        0.33333333],\n       [0.        , 0.        , 0.        , ..., 0.        , 0.33333333,\n        0.33333333]])\n\n\n\nplt.plot(x,label=r'$x$')\nplt.plot(M@x,'--',label=r'$M@x$')\nplt.legend()\n\n\n\n\n\n\n\n\n\n끝이 올라간 이유? 마지막에 \\(\\frac{1}{3}(x_{T-1}+x_T+x_{T+1})\\) 대신에 \\(\\frac{1}{3}(x_{T-1}+x_T+0)\\) 을 이용하였기 때문\n\n7. 아래와 같은 변환을 수행하고 결과를 시각화하라.\n\n\\({\\tt xx}_1= \\frac{1}{3}(x_1+x_1+x_2)\\)\n\\({\\tt xx}_2= \\frac{1}{3}(x_1+x_2+x_3)\\)\n\\({\\tt xx}_3= \\frac{1}{3}(x_2+x_3+x_4)\\)\n\\(\\dots\\)\n\\({\\tt xx}_{T-1}= \\frac{1}{3}(x_{T-1}+x_{T-1}+x_T)\\)\n\\({\\tt xx}_{T}= \\frac{1}{3}(x_{T-1}+x_T+x_T)\\)\n\n(풀이)\n\nM[0,0] = 2/3 \nM[-1,-1] = 2/3 \nplt.plot(x,label=r'$x$')\nplt.plot(M@x,label=r'$M@x$')\nplt.legend()\n\n\n\n\n\n\n\n\n8. 7번의 변환을 100번 반복하고 시각화하라.\n(풀이)\n\nplt.plot(x,label=r'$x$')\nplt.plot(np.linalg.matrix_power(M,100)@x,label=r'$M^{100}@x$')\nplt.legend()\n\n\n\n\n\n\n\n\n\nplt.plot(x,label=r'$x$')\nplt.plot(np.linalg.matrix_power(M,1000)@x,label=r'$M^{1000}@x$')\nplt.legend()"
  },
  {
    "objectID": "posts/07wk-2.html#a.-np.random.rand-1",
    "href": "posts/07wk-2.html#a.-np.random.rand-1",
    "title": "07wk-2: numpy (2)",
    "section": "A. np.random.rand()",
    "text": "A. np.random.rand()\n- 0~1사이에서 10개의 난수 생성\n\nnp.random.rand(10)\n\narray([0.01174913, 0.91587271, 0.88325068, 0.32707103, 0.45758847,\n       0.55495369, 0.55845013, 0.75018778, 0.29947949, 0.85888413])\n\n\n- 0~2사이에서 10개의 난수 생성\n\nnp.random.rand(10)*2 \n\narray([1.20931097, 0.01302267, 1.61211776, 0.13977794, 1.53527907,\n       1.44876328, 0.12494504, 1.95142067, 1.53362653, 0.24277993])\n\n\n- 1~2사이에서 10개의 난수 생성\n\nnp.random.rand(10)+1\n\narray([1.14946193, 1.08540348, 1.41658001, 1.91196224, 1.56491703,\n       1.85295256, 1.45750574, 1.26272651, 1.97333158, 1.838797  ])\n\n\n- 1~3사이에서 10개의 난수 생성\n\nnp.random.rand(10)*2+1 # 1~3\n\narray([1.61667643, 2.80011097, 1.31152492, 1.85084398, 1.73866127,\n       1.46425599, 2.51877008, 1.71378585, 1.57511749, 2.24413128])"
  },
  {
    "objectID": "posts/07wk-2.html#b.-np.random.randn-1",
    "href": "posts/07wk-2.html#b.-np.random.randn-1",
    "title": "07wk-2: numpy (2)",
    "section": "B. np.random.randn()",
    "text": "B. np.random.randn()\n- N(0,1)에서 10개 추출\n\nnp.random.randn(10) # 표준정규분포에서 10개의 샘플 추출 \n\narray([-0.16847185,  1.29054265,  0.36478515, -0.09947444, -0.82877225,\n       -0.65347034,  0.07046089, -2.46535548,  1.3927757 , -0.05533013])\n\n\n- N(1,1)에서 10개 추출\n\nnp.random.randn(10)+1 \n\narray([ 0.15876552,  0.62279321,  2.33180976,  1.17026483,  0.48580015,\n       -0.27040806,  2.74260265,  0.6414686 ,  0.8154233 ,  1.62244756])\n\n\n- N(0,4)에서 10개 추출 (평균이 0이고 분산이 4인 분포)\n\nnp.random.randn(10)*2\n\narray([ 0.90095895, -0.79682218, -2.13391486, -0.36689153, -2.84838756,\n       -1.37338419,  1.47154709,  4.37582762, -2.29684053, -0.55865428])\n\n\n- N(3,4)에서 10개 추출\n\nnp.random.randn(10)*2+3 \n\narray([ 1.99277107, -0.32804188, -1.44153951,  3.8343609 ,  1.82989546,\n        3.33888294,  2.97837722, -0.6657107 ,  3.51753206,  1.78019191])"
  },
  {
    "objectID": "posts/07wk-2.html#c.-np.random.randint-1",
    "href": "posts/07wk-2.html#c.-np.random.randint-1",
    "title": "07wk-2: numpy (2)",
    "section": "C. np.random.randint()",
    "text": "C. np.random.randint()\n- [0,7)의 범위에서 하나의 정수를 랜덤으로 생성\n\nnp.random.randint(7) # [0,7)의 범위에서 하나의 정수 생성 \n\n3\n\n\n- [0,7)의 범위에서 20개의 정수를 랜덤으로 생성\n\nnp.random.randint(7,size=(20,)) # [0,7)의 범위에서 20개의 정수 생성 \n\narray([2, 6, 2, 5, 0, 1, 0, 1, 1, 1, 6, 3, 6, 3, 0, 6, 2, 5, 4, 6])\n\n\n- [0,7)의 범위에서 (2,2) shape 으로 정수를 랜덤으로 생성\n\nnp.random.randint(7,size=(2,2)) # [0,7)의 범위에서 (2,2) shape의 정수 생성 \n\narray([[2, 0],\n       [5, 4]])\n\n\n- 위와 같은 코드를 아래와 같이 구현가능\n\nnp.random.randint(low=7,size=(5,5)) # [0,7)의 범위에서 (5,5) shape의 정수 생성 \n\narray([[4, 6, 1, 1, 3],\n       [0, 2, 4, 2, 4],\n       [4, 3, 1, 4, 0],\n       [2, 4, 5, 1, 3],\n       [1, 3, 3, 6, 5]])\n\n\n- [10,20) 의 범위에서 (5,5) shape 정수를 랜덤으로 생성\n\nnp.random.randint(low=10,high=20,size=(5,5)) # [10,20)의 범위에서 (5,5)shape의 정수생성 \n\narray([[17, 16, 10, 14, 11],\n       [12, 17, 13, 19, 10],\n       [16, 10, 14, 17, 12],\n       [16, 18, 18, 18, 19],\n       [14, 14, 12, 10, 16]])\n\n\n- 의문: np.random.randint(low=7,size=(5,5)) 가 좀 이상하다. 사실 np.random.randint(high=7,size=(5,5))가 되어야 맞지 않는가?\n-&gt; 저도 그렇게 생각하긴 하는데요, 구현이 이렇게 되어있습니다. 도움말 확인!\nReturn random integers from the \"discrete uniform\" distribution of the specified dtype in the \"half-open\" interval [`low`, `high`). If `high` is None (the default), then results are from [0, `low`)."
  },
  {
    "objectID": "posts/07wk-2.html#d.-np.random.choice-1",
    "href": "posts/07wk-2.html#d.-np.random.choice-1",
    "title": "07wk-2: numpy (2)",
    "section": "D. np.random.choice()",
    "text": "D. np.random.choice()\n- ver1\n\nnp.random.choice(5,20) # [0,5)에서 20개를 뽑음, 중복허용 \n\narray([1, 0, 1, 2, 2, 2, 2, 3, 0, 3, 3, 4, 2, 4, 4, 1, 0, 0, 3, 2])\n\n\n\n이것은 np.random.randint(5,size=(20,)) 와 같은 코드임\n\n- ver2\n\nnp.random.choice([0,1,2,3],20) # [0,1,2,3]에서 20개를 뽑음, 중복허용\n\narray([2, 0, 1, 2, 1, 2, 1, 2, 3, 0, 1, 0, 2, 1, 0, 3, 1, 0, 2, 1])\n\n\n\nnp.random.choice([\"apple\",\"orange\",\"banana\"],20)\n\narray(['orange', 'banana', 'apple', 'apple', 'orange', 'orange', 'banana',\n       'orange', 'orange', 'orange', 'orange', 'apple', 'apple', 'banana',\n       'apple', 'banana', 'banana', 'orange', 'orange', 'orange'],\n      dtype='&lt;U6')\n\n\n\nnp.random.choice([\"apple\",\"orange\",\"banana\"],2,replace=False) # 중복허용 X \n\narray(['orange', 'banana'], dtype='&lt;U6')"
  },
  {
    "objectID": "posts/07wk-2.html#e.-통계분포-1",
    "href": "posts/07wk-2.html#e.-통계분포-1",
    "title": "07wk-2: numpy (2)",
    "section": "E. 통계분포",
    "text": "E. 통계분포\n\nnp.random.binomial(n=10,p=0.2,size=(5,)) # X1, ..., X5 ~ B(10,0.2) \n\narray([4, 2, 2, 0, 3])\n\n\n\nnp.random.normal(loc=10,scale=2,size=(5,)) # X1, ..., X5 ~ N(10,4) \n\narray([ 9.01849598, 10.300486  ,  9.43740222,  9.26415294, 10.74645402])\n\n\n\nnp.radom.randn(5)*2 + 10와 같은코드\n\n\nnp.random.uniform(low=2,high=4,size=(5,)) # X1, ..., X5 ~ U(2,4) \n\narray([2.22499611, 3.94154104, 2.56319561, 3.93942319, 2.33948715])\n\n\n\nnp.random.rand(5)*2+2와 같은 코드\n\n\nnp.random.poisson(lam=5,size=(5,)) # X1,...,X5 ~ Poi(5) \n\narray([3, 6, 7, 5, 6])"
  },
  {
    "objectID": "posts/07wk-2.html#a.-np.where-np.argwhere-1",
    "href": "posts/07wk-2.html#a.-np.where-np.argwhere-1",
    "title": "07wk-2: numpy (2)",
    "section": "A. np.where, np.argwhere",
    "text": "A. np.where, np.argwhere\n- 1차원\n\na=np.array([0,0,0,1,0])\na\n\narray([0, 0, 0, 1, 0])\n\n\n\nnp.where(a==1) # 조건 a==1을 만족하는 인덱스를 출력하라!\n\n(array([3]),)\n\n\n\nnp.argwhere(a==1)\n\narray([[3]])\n\n\n- 2차원\n\nnp.random.seed(43052)\na=np.random.randn(12).reshape(3,4)\na\n\narray([[ 0.38342049,  1.0841745 ,  1.14277825,  0.30789368],\n       [ 0.23778744,  0.35595116, -1.66307542, -1.38277318],\n       [-1.92684484, -1.4862163 ,  0.00692519, -0.03488725]])\n\n\n\nnp.where(a&lt;0) # 조건을 만족하는 인덱스가 (1,2), (1,3), (2,0), (2,1), (2,3) 이라는 의미\n\n(array([1, 1, 2, 2, 2]), array([2, 3, 0, 1, 3]))\n\n\n\nnp.argwhere(a&lt;0) # 조건을 만족하는 인덱스가 (1,2), (1,3), (2,0), (2,1), (2,3) 이라는 의미\n\narray([[1, 2],\n       [1, 3],\n       [2, 0],\n       [2, 1],\n       [2, 3]])\n\n\n\na[np.where(a&lt;0)] # 조건을 만족하는 인덱스가 모두 출력 =&gt; 1차원 array로 출력 \n\narray([-1.66307542, -1.38277318, -1.92684484, -1.4862163 , -0.03488725])\n\n\n\na[np.argwhere(a&lt;0)] # 출력불가능\n\nIndexError: index 3 is out of bounds for axis 0 with size 3\n\n\n\na[np.argwhere(a&lt;0)[0][0],np.argwhere(a&lt;0)[0][1]] # 어거지로 출력할수는 있음 \n\n-1.6630754187023522\n\n\n- np.where의 특수기능\n\nnp.random.seed(43052) \na=np.random.randn(12).reshape(3,4) \na\n\narray([[ 0.38342049,  1.0841745 ,  1.14277825,  0.30789368],\n       [ 0.23778744,  0.35595116, -1.66307542, -1.38277318],\n       [-1.92684484, -1.4862163 ,  0.00692519, -0.03488725]])\n\n\n\nnp.where(a&lt;0,0,a) # a&lt;0을 체크 =&gt; 조건에 맞으면 0 =&gt; 조건에 안맞으면 a \n\narray([[0.38342049, 1.0841745 , 1.14277825, 0.30789368],\n       [0.23778744, 0.35595116, 0.        , 0.        ],\n       [0.        , 0.        , 0.00692519, 0.        ]])\n\n\n\nnp.where(a&lt;0,0,1) # a&lt;0을 체크 =&gt; 조건에 맞으면 0 =&gt; 조건에 안맞으면 1\n\narray([[1, 1, 1, 1],\n       [1, 1, 0, 0],\n       [0, 0, 1, 0]])\n\n\n- 요약 - np.where: 인덱스의 좌표를 읽는 가독성은 떨어짐. 그런데 조건에 맞는 원소를 출력하거나 처리하는 (특수기능) 목적으로는 좋은 함수\n- np.argwhere: 인덱스의 좌표를 읽는 가독성은 좋은 편임. 그런데 조건에 맞는 원소를 출력하거나 처리하는 기능은 떨어짐"
  },
  {
    "objectID": "posts/07wk-2.html#b.-인덱싱고급-1",
    "href": "posts/07wk-2.html#b.-인덱싱고급-1",
    "title": "07wk-2: numpy (2)",
    "section": "B. 인덱싱고급",
    "text": "B. 인덱싱고급\n- 원래 a는 2d array\n\na=np.arange(12).reshape(3,4)\na\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n- 경우1: 인덱싱 결과가 1d array로 나올수 있음\n\na[0,:] # 인덱싱의 결과 축의 갯수가 바뀐다! 2d array -&gt; 1d array\n\narray([0, 1, 2, 3])\n\n\n- 경우2: 물론 인덱싱 결과가 2d array로 나올 수도 있음\n\na[[0,1],:] # 이것은 축의 숫자가 유지된다. 2d array -&gt; 2d array \n\narray([[0, 1, 2, 3],\n       [4, 5, 6, 7]])\n\n\n- 경우1의 상황에서도 축의 갯수를 유지하면서 인덱싱하려면?\n\na[[0],:] # 이번에는 인덱싱의 결과 축의 갯수가 유지된다! 2d array -&gt; 2d array\n\narray([[0, 1, 2, 3]])\n\n\n\na[:,[0]] #\n\narray([[0],\n       [4],\n       [8]])\n\n\n- 미묘한 차이를 이해할것\n\na[0,:], a[[0],:]\n\n(array([0, 1, 2, 3]), array([[0, 1, 2, 3]]))\n\n\n\na[:,0], a[:,[0]]\n\n(array([0, 4, 8]),\n array([[0],\n        [4],\n        [8]]))"
  },
  {
    "objectID": "posts/07wk-2.html#c.-np.ix_-1",
    "href": "posts/07wk-2.html#c.-np.ix_-1",
    "title": "07wk-2: numpy (2)",
    "section": "C. np.ix_",
    "text": "C. np.ix_\n- 아래의 인덱싱을 비교하자.\n\na=np.arange(12).reshape(3,4)\na\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n\na[0:2,0:2]\n\narray([[0, 1],\n       [4, 5]])\n\n\n\na[[0,1],0:2]\n\narray([[0, 1],\n       [4, 5]])\n\n\n\na[0:2,[0,1]]\n\narray([[0, 1],\n       [4, 5]])\n\n\n- 언뜻 생각하면 위의 결과와 a[[0,1],[0,1]]는 결과가 동일할 것 같다.\n\na[[0,1],[0,1]]\n\narray([0, 5])\n\n\n\n실제로는 [a[0,0],a[1,1]]이 array로 나옴\n\n- 사실 np.where에서 이미 관찰하였음\n\na\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n\nnp.where(a % 5 ==0)\n\n(array([0, 1, 2]), array([0, 1, 2]))\n\n\n\na[np.where(a % 5 ==0)]\n\narray([ 0,  5, 10])\n\n\n\na[[0, 1, 2],[0, 1, 2]]\n\narray([ 0,  5, 10])\n\n\n- a[[0,1],[0,1]]이 a[0:2,0:2]를 의미하게 하려면 아래와 같이 하면 된다.\n\na[np.ix_([0,1],[0,1])]\n\narray([[0, 1],\n       [4, 5]])"
  },
  {
    "objectID": "posts/07wk-2.html#d.-note-1-메소드-도움말-확인하기-1",
    "href": "posts/07wk-2.html#d.-note-1-메소드-도움말-확인하기-1",
    "title": "07wk-2: numpy (2)",
    "section": "D. note 1: 메소드 도움말 확인하기",
    "text": "D. note 1: 메소드 도움말 확인하기\n- numpy서 sum을 수행하는 2가지 방식\n\nnp.sum(a)\na.sum()\n\n\na=np.array([1,2,3,4,5])\na\n\narray([1, 2, 3, 4, 5])\n\n\n\na.sum()\n\n15\n\n\n\nsum(a)\n\n15\n\n\n- 넘파이에서 a.sum()에 대한 도움말은 보통 np.sum()에 자세히 나와있음. \\(\\to\\) np.sum()의 도움말을 확인하고 np.sum(a)와 a.sum()이 동일함을 이용하여 a.sum()의 사용법을 미루어 유추해야함.\n\na.sum?\n\n\nDocstring:\na.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True)\nReturn the sum of the array elements over the given axis.\nRefer to `numpy.sum` for full documentation.\nSee Also\n--------\nnumpy.sum : equivalent function\nType:      builtin_function_or_method\n\n\n\n\n\nnp.sum?\n\n\nSignature:\nnp.sum(\n    a,\n    axis=None,\n    dtype=None,\n    out=None,\n    keepdims=&lt;no value&gt;,\n    initial=&lt;no value&gt;,\n    where=&lt;no value&gt;,\n)\nDocstring:\nSum of array elements over a given axis.\nParameters\n----------\na : array_like\n    Elements to sum.\naxis : None or int or tuple of ints, optional\n    Axis or axes along which a sum is performed.  The default,\n    axis=None, will sum all of the elements of the input array.  If\n    axis is negative it counts from the last to the first axis.\n    .. versionadded:: 1.7.0\n    If axis is a tuple of ints, a sum is performed on all of the axes\n    specified in the tuple instead of a single axis or all the axes as\n    before.\ndtype : dtype, optional\n    The type of the returned array and of the accumulator in which the\n    elements are summed.  The dtype of `a` is used by default unless `a`\n    has an integer dtype of less precision than the default platform\n    integer.  In that case, if `a` is signed then the platform integer\n    is used while if `a` is unsigned then an unsigned integer of the\n    same precision as the platform integer is used.\nout : ndarray, optional\n    Alternative output array in which to place the result. It must have\n    the same shape as the expected output, but the type of the output\n    values will be cast if necessary.\nkeepdims : bool, optional\n    If this is set to True, the axes which are reduced are left\n    in the result as dimensions with size one. With this option,\n    the result will broadcast correctly against the input array.\n    If the default value is passed, then `keepdims` will not be\n    passed through to the `sum` method of sub-classes of\n    `ndarray`, however any non-default value will be.  If the\n    sub-class' method does not implement `keepdims` any\n    exceptions will be raised.\ninitial : scalar, optional\n    Starting value for the sum. See `~numpy.ufunc.reduce` for details.\n    .. versionadded:: 1.15.0\nwhere : array_like of bool, optional\n    Elements to include in the sum. See `~numpy.ufunc.reduce` for details.\n    .. versionadded:: 1.17.0\nReturns\n-------\nsum_along_axis : ndarray\n    An array with the same shape as `a`, with the specified\n    axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar\n    is returned.  If an output array is specified, a reference to\n    `out` is returned.\nSee Also\n--------\nndarray.sum : Equivalent method.\nadd.reduce : Equivalent functionality of `add`.\ncumsum : Cumulative sum of array elements.\ntrapz : Integration of array values using the composite trapezoidal rule.\nmean, average\nNotes\n-----\nArithmetic is modular when using integer types, and no error is\nraised on overflow.\nThe sum of an empty array is the neutral element 0:\n&gt;&gt;&gt; np.sum([])\n0.0\nFor floating point numbers the numerical precision of sum (and\n``np.add.reduce``) is in general limited by directly adding each number\nindividually to the result causing rounding errors in every step.\nHowever, often numpy will use a  numerically better approach (partial\npairwise summation) leading to improved precision in many use-cases.\nThis improved precision is always provided when no ``axis`` is given.\nWhen ``axis`` is given, it will depend on which axis is summed.\nTechnically, to provide the best speed possible, the improved precision\nis only used when the summation is along the fast axis in memory.\nNote that the exact precision may vary depending on other parameters.\nIn contrast to NumPy, Python's ``math.fsum`` function uses a slower but\nmore precise approach to summation.\nEspecially when summing a large number of lower precision floating point\nnumbers, such as ``float32``, numerical errors can become significant.\nIn such cases it can be advisable to use `dtype=\"float64\"` to use a higher\nprecision for the output.\nExamples\n--------\n&gt;&gt;&gt; np.sum([0.5, 1.5])\n2.0\n&gt;&gt;&gt; np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)\n1\n&gt;&gt;&gt; np.sum([[0, 1], [0, 5]])\n6\n&gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=0)\narray([0, 6])\n&gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=1)\narray([1, 5])\n&gt;&gt;&gt; np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1)\narray([1., 5.])\nIf the accumulator is too small, overflow occurs:\n&gt;&gt;&gt; np.ones(128, dtype=np.int8).sum(dtype=np.int8)\n-128\nYou can also start the sum with a value other than zero:\n&gt;&gt;&gt; np.sum([10], initial=5)\n15\nFile:      ~/anaconda3/envs/py39/lib/python3.9/site-packages/numpy/core/fromnumeric.py\nType:      function"
  },
  {
    "objectID": "posts/07wk-2.html#e.-hstack-vstack-1",
    "href": "posts/07wk-2.html#e.-hstack-vstack-1",
    "title": "07wk-2: numpy (2)",
    "section": "E. hstack, vstack",
    "text": "E. hstack, vstack\n- hstack, vstack 를 쓰는 사람도 있다.\n\na=np.arange(6) \nb=-a \n\n\nnp.vstack([a,b])\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 0, -1, -2, -3, -4, -5]])\n\n\n\nnp.stack([a,b],axis=0)\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 0, -1, -2, -3, -4, -5]])\n\n\n\nnp.hstack([a,b])\n\narray([ 0,  1,  2,  3,  4,  5,  0, -1, -2, -3, -4, -5])\n\n\n\nnp.concatenate([a,b],axis=0)\n\narray([ 0,  1,  2,  3,  4,  5,  0, -1, -2, -3, -4, -5])"
  },
  {
    "objectID": "posts/07wk-2.html#f.-append-1",
    "href": "posts/07wk-2.html#f.-append-1",
    "title": "07wk-2: numpy (2)",
    "section": "F. append",
    "text": "F. append\n- 기능1: reshape(-1) + concat\n\na=np.arange(30).reshape(5,6)\nb= -np.arange(8).reshape(2,2,2)\n\n\na.shape, b.shape\n\n((5, 6), (2, 2, 2))\n\n\n\nnp.append(a,b)\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,  0, -1, -2, -3,\n       -4, -5, -6, -7])\n\n\n\nnp.concatenate([a.reshape(-1),b.reshape(-1)])\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,  0, -1, -2, -3,\n       -4, -5, -6, -7])\n\n\n- 기능2: concat\n\na=np.arange(2*3*4).reshape(2,3,4)\nb=-a\n\n\na.shape,b.shape, np.append(a,b,axis=0).shape\n\n((2, 3, 4), (2, 3, 4), (4, 3, 4))\n\n\n\na.shape,b.shape, np.append(a,b,axis=1).shape\n\n((2, 3, 4), (2, 3, 4), (2, 6, 4))\n\n\n\na.shape,b.shape, np.append(a,b,axis=2).shape\n\n((2, 3, 4), (2, 3, 4), (2, 3, 8))\n\n\n- concat과의 차이?\n\na=np.arange(2*3*4).reshape(2,3,4)\nb=-a\nc=2*a\n\n\nnp.append(a,b,c,axis=0)\n\nTypeError: _append_dispatcher() got multiple values for argument 'axis'\n\n\n\nnp.concatenate([a,b,c],axis=0)\n\narray([[[  0,   1,   2,   3],\n        [  4,   5,   6,   7],\n        [  8,   9,  10,  11]],\n\n       [[ 12,  13,  14,  15],\n        [ 16,  17,  18,  19],\n        [ 20,  21,  22,  23]],\n\n       [[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]],\n\n       [[  0,   2,   4,   6],\n        [  8,  10,  12,  14],\n        [ 16,  18,  20,  22]],\n\n       [[ 24,  26,  28,  30],\n        [ 32,  34,  36,  38],\n        [ 40,  42,  44,  46]]])"
  },
  {
    "objectID": "posts/07wk-2.html#g.-ravel-flatten-1",
    "href": "posts/07wk-2.html#g.-ravel-flatten-1",
    "title": "07wk-2: numpy (2)",
    "section": "G. ravel, flatten",
    "text": "G. ravel, flatten\n\na=np.arange(2*3*4).reshape(2,3,4)\na\n\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n\n\n\na.reshape(-1)\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])\n\n\n\na.ravel()\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])\n\n\n\na.flatten()\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])"
  },
  {
    "objectID": "posts/07wk-2.html#h.-기타-통계함수들-1",
    "href": "posts/07wk-2.html#h.-기타-통계함수들-1",
    "title": "07wk-2: numpy (2)",
    "section": "H. 기타 통계함수들",
    "text": "H. 기타 통계함수들\n- 평균, 중앙값, 표준편차, 분산\n\na = np.random.normal(loc=0,scale=2,size=(100,))\na\n\narray([-1.12093037,  2.03228998,  0.97607763, -1.95129947, -1.49794935,\n       -2.69582142,  6.26294142,  0.17772869,  0.88248101, -0.0987605 ,\n       -2.20172938,  1.57977467, -3.70228648,  3.62666243,  0.35655652,\n        2.24552797,  1.82730641, -0.27324478,  2.96368325,  2.36722536,\n        1.00283717,  2.25966997,  0.74019075,  1.19192351,  2.70918979,\n        1.56791667, -3.9192988 ,  0.51262046,  2.1701658 ,  1.45665188,\n       -0.95216879, -0.78855745, -2.01741917, -0.93273601, -1.01042306,\n       -0.03667253,  0.4746618 , -2.55669289,  1.10739444,  1.15177071,\n       -2.96111607, -1.97698346, -1.62882279, -0.73025042, -4.41933873,\n        2.67699686, -1.49483629,  0.00726669, -0.91481464, -3.34965693,\n       -1.53808928,  0.45192716,  0.62408358,  4.00499954, -0.44609797,\n       -2.58265527, -3.66717305,  2.10773738, -0.51106569,  2.29246892,\n        2.79998629, -3.03791044,  1.89561133,  0.19501627,  0.72806721,\n       -1.50778943,  0.42474352,  0.12223567, -1.04890662, -1.9739829 ,\n       -1.4261672 , -0.20406325, -0.23939128,  1.41477338, -2.25923024,\n        1.17742253, -2.00670917,  0.1468111 , -0.57698109,  3.52781535,\n        1.71060134,  2.31381344, -1.06125884, -1.73359866,  0.21638374,\n        0.92504343,  2.50727404,  1.3510571 ,  0.62009821, -1.77908053,\n        1.85646061,  0.66264999, -1.64292395, -0.60274377, -1.1585586 ,\n       -0.66907802,  2.38660429,  1.41138093, -2.3059048 , -0.53353575])\n\n\n\nnp.mean(a)\n\n0.04457872598775192\n\n\n\nnp.median(a)\n\n0.13452338307274175\n\n\n\nnp.std(a)\n\n1.957280879505603\n\n\n\nnp.var(a)\n\n3.8309484412782266\n\n\n- corr matrix, cov matrix\n\nnp.random.seed(43052) \nx= np.random.randn(10000)\ny= np.random.randn(10000)*2\nz= np.random.randn(10000)*0.5 \n\n\nnp.corrcoef([x,y,z]).round(2)\n\narray([[ 1.  , -0.01,  0.01],\n       [-0.01,  1.  ,  0.  ],\n       [ 0.01,  0.  ,  1.  ]])\n\n\n\nnp.cov([x,y,z]).round(2)\n\narray([[ 0.99, -0.02,  0.  ],\n       [-0.02,  4.06,  0.  ],\n       [ 0.  ,  0.  ,  0.25]])"
  },
  {
    "objectID": "posts/07wk-2.html#i.-dtype-1",
    "href": "posts/07wk-2.html#i.-dtype-1",
    "title": "07wk-2: numpy (2)",
    "section": "I. dtype",
    "text": "I. dtype\n- np.array는 항상 dtype이 있다.\n\na = np.array([1,2,3])\na\n\narray([1, 2, 3])\n\n\n\na.dtype\n\ndtype('int64')\n\n\n\na = np.array([1.0,2.0,3.0])\na\n\narray([1., 2., 3.])\n\n\n\na.dtype\n\ndtype('float64')\n\n\n- 같은 int라도 int16,int32,int64으로 나누어진다.\n\na = np.array([1,2,3],dtype=np.int32)\na\n\narray([1, 2, 3], dtype=int32)\n\n\n\na.dtype\n\ndtype('int32')\n\n\n- float도 float16, float32, float64가 있다.\n\na = np.array([1,2,3],dtype=np.float32)\na\n\narray([1., 2., 3.], dtype=float32)\n\n\n- 데이터타입은 아래와 같은 방법으로 변환시킬 수 있다.\n\na = np.array([1,2,3],dtype=np.int32)\na\n\narray([1, 2, 3], dtype=int32)\n\n\n\na=a.astype(dtype=np.int64)\na\n\narray([1, 2, 3])\n\n\n\na.dtype\n\ndtype('int64')\n\n\n- 문자열의 경우\n\na = np.array(['a','b','c'])\na\n\narray(['a', 'b', 'c'], dtype='&lt;U1')\n\n\n\na = np.array(['ab','b','c'])\na\n\narray(['ab', 'b', 'c'], dtype='&lt;U2')\n\n\n\na = np.array(['abasdf','b','c'])\na\n\narray(['abasdf', 'b', 'c'], dtype='&lt;U6')\n\n\n- 문자열+숫자혼합 =&gt; 문자열로 통일\n\na= np.array(['a',1])\na\n\narray(['a', '1'], dtype='&lt;U21')\n\n\n\na= np.array(['a',1.0])\na\n\narray(['a', '1.0'], dtype='&lt;U32')\n\n\n- 숫자를 문자열로 전환\n\na= np.array([1,2,3])\na\n\narray([1, 2, 3])\n\n\n\na.astype(np.str_)\n\narray(['1', '2', '3'], dtype='&lt;U21')"
  },
  {
    "objectID": "posts/07wk-2.html#j.-브로드캐스팅과-시간측정-1",
    "href": "posts/07wk-2.html#j.-브로드캐스팅과-시간측정-1",
    "title": "07wk-2: numpy (2)",
    "section": "J. 브로드캐스팅과 시간측정",
    "text": "J. 브로드캐스팅과 시간측정\n(예비학습)\n\nimport time \n\n\nt1=time.time()\n\n\nt2=time.time()\nt2-t1\n\n0.21341419219970703\n\n\n예비학습끝\n(예제) x=[0,1,2,3,4] 인 벡터가 있다고 하자. (i,j)의 원소가 (x[i]-x[j])**2 을 의미하는 \\(5\\times 5\\) 매트릭스를 구하라.\n(풀이1)\n\nx=np.array(range(5))\nx\n\narray([0, 1, 2, 3, 4])\n\n\n\ndist = np.zeros([5,5])\ndist\n\narray([[0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.]])\n\n\n\nfor i in range(5):\n    for j in range(5):\n        dist[i,j]=(x[i]-x[j])**2\n\n\ndist\n\narray([[ 0.,  1.,  4.,  9., 16.],\n       [ 1.,  0.,  1.,  4.,  9.],\n       [ 4.,  1.,  0.,  1.,  4.],\n       [ 9.,  4.,  1.,  0.,  1.],\n       [16.,  9.,  4.,  1.,  0.]])\n\n\n(풀이2)\n\nx1=x.reshape(5,1).astype(dtype=np.float64)\nx2=x.reshape(1,5).astype(dtype=np.float64)\n\n\nx1\n\narray([[0.],\n       [1.],\n       [2.],\n       [3.],\n       [4.]])\n\n\n\nx2\n\narray([[0., 1., 2., 3., 4.]])\n\n\n\nx1-x2\n\narray([[ 0., -1., -2., -3., -4.],\n       [ 1.,  0., -1., -2., -3.],\n       [ 2.,  1.,  0., -1., -2.],\n       [ 3.,  2.,  1.,  0., -1.],\n       [ 4.,  3.,  2.,  1.,  0.]])\n\n\n\n(i,j)th element = x[i]-x[j]\n\n\n(x1-x2)**2\n\narray([[ 0.,  1.,  4.,  9., 16.],\n       [ 1.,  0.,  1.,  4.,  9.],\n       [ 4.,  1.,  0.,  1.,  4.],\n       [ 9.,  4.,  1.,  0.,  1.],\n       [16.,  9.,  4.,  1.,  0.]])\n\n\n\n\ny=np.array(range(10000))\n\n\ndist = np.zeros([10000,10000])\ndist\n\narray([[0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       ...,\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.]])\n\n\n\nt1=time.time()\nfor i in range(10000):\n    for j in range(10000):\n        dist[i,j]=(y[i]-y[j])**2\nt2=time.time()\nt2-t1\n\n37.53360199928284\n\n\n\ny1=y.reshape(10000,1).astype(np.float64)\ny2=y.reshape(1,10000).astype(np.float64)\n\n\nt1=time.time()\ndist2=(y1-y2)**2\nt2=time.time()\nt2-t1\n\n0.1297893524169922\n\n\n\n(dist-dist2).sum()\n\n0.0"
  },
  {
    "objectID": "posts/07wk-2.html#a.-회귀분석-미리보기-1",
    "href": "posts/07wk-2.html#a.-회귀분석-미리보기-1",
    "title": "07wk-2: numpy (2)",
    "section": "A. 회귀분석 미리보기",
    "text": "A. 회귀분석 미리보기\n1--7.\n1. \\(x_i\\)가 아래와 같이 주어졌다고 가정하자.\n\nx =  np.array([0.00983, 0.01098, 0.02951, 0.0384 , 0.03973, 0.04178, 0.0533 ,\n               0.058  , 0.09454, 0.1103 , 0.1328 , 0.1412 , 0.1497 , 0.1664 ,\n               0.1906 , 0.1923 , 0.198  , 0.2141 , 0.2393 , 0.2433 , 0.3157 ,\n               0.3228 , 0.3418 , 0.3552 , 0.3918 , 0.3962 , 0.4    , 0.4482 ,\n               0.496  , 0.507  , 0.53   , 0.5654 , 0.582  , 0.5854 , 0.5854 ,\n               0.6606 , 0.7007 , 0.723  , 0.7305 , 0.7383 , 0.7656 , 0.7725 ,\n               0.831  , 0.8896 , 0.9053 , 0.914  , 0.949  , 0.952  , 0.9727 ,\n               0.982  ])\n\n아래의 수식에 따라 \\(y_i\\)를 생성하라.\n\n\\(y_i = 2+3x_i +\\epsilon_i,\\quad \\epsilon_i \\overset{iid}{\\sim} N(0,1)\\)\n\n\\((x_i,y_i)\\)를 산점도를 이용하여 시각화하라.\n(풀이)\n\ny = 2+3*x + np.random.randn(50) \n\n\nplt.plot(x,y,'o',label=r'$(x_i,y_i)$')\nplt.legend()\n\n\n\n\n\n\n\n\n2. 1과 같은 자료를 잘 표현할 수 있는 적절한 추세선 \\((x_i, \\hat{y}_i)\\)를 그리기 위하여 아래의 수식을 고려하자.\n\n\\(\\hat{y}_i = ax_i+b\\)\n\na,b를 각각 아래의 표에 의하여 선택하였을 경우 추세선을 문제하단에 명시된 요구사항에 맞추어 시각화하라.\n\n\n\n\n\\(a\\)\n\\(b\\)\n\n\n\n\n(a)\n\\(1\\)\n\\(0\\)\n\n\n(b)\n\\(2.5\\)\n\\(2\\)\n\n\n(c)\n\\(3\\)\n\\(2\\)\n\n\n\n요구사항\n\n\\((x_i,y_i)\\)를 산점도로 그리고 각 (a),(b),(c)에 대한 \\((x_i,\\hat{y}_i)\\)를 lineplot으로 겹쳐그릴 것\n범례를 포함할 것\n\n\nplt.plot(x,y,'o',label=r'$(x_i,y_i)$')\nplt.plot(x,1*x+0,'--',label=r'(a) $(x_i,\\hat{y}_i)$')\nplt.plot(x,2.5*x+2,'--',label=r'(b) $(x_i,\\hat{y}_i)$')\nplt.plot(x,3*x+2,'--',label=r'(c) $(x_i,\\hat{y}_i)$')\nplt.legend()\n\n\n\n\n\n\n\n\n3. 아래를 각각 계산하라.\n(a) \\(\\frac{1}{n}\\sum_{i=1}^{n}(y_i-x_i)^2\\)\n(b) \\(\\frac{1}{n}\\sum_{i=1}^{n}(y_i-2-2.5x_i)^2\\)\n(c) \\(\\frac{1}{n}\\sum_{i=1}^{n}(y_i-2-3x_i)^2\\)\n가장 작은 값을 가지는 것은 무엇인가?\n(풀이)\n\nnp.mean((y-(1*x+0))**2), np.mean((y-(2.5*x+2))**2), np.mean((y-(3*x+2))**2)\n\n(9.883007643035032, 0.9387378995108477, 0.8266459475811891)\n\n\n가장 작은 값을 가지는 것은 (c)이다.\n4. 3의 결과를 근거로 (a)-(c)중 가장 적절한 추세선을 판단하고 적절한 순서대로 나열하라.\n(풀이)\n3-(a),(b),(c)는 각각\n\n\\(\\hat{y}_i=x_i\\)\n\\(\\hat{y}_i=2+2.5x_i\\)\n\\(\\hat{y}_i=2+3x_i\\)\n\n일 경우\n\\[{\\tt mse}({\\boldsymbol y}, \\hat{\\boldsymbol y}) = \\frac{1}{n}\\sum_{i=1}^{n}(y_i -\\hat{y}_i)^2\\]\n를 계산한 것이라 해석할 수 있다. 그런데 \\({\\tt mse}({\\boldsymbol y}, \\hat{\\boldsymbol y})\\)의 값은\n\n\\(y_1 \\approx \\hat{y}_1\\)\n\\(y_2 \\approx \\hat{y}_2\\)\n\\(\\dots\\)\n\\(y_n \\approx \\hat{y}_n\\)\n\n일수록 작은 값을 가진다. 그리고 위의 조건은 더 적절하게 추세선을 그렸을때 만족된다. 요약하면\n\n적절한 추세선을 그림 \\(\\Rightarrow\\) \\(y_i \\approx \\hat{y}_i\\) \\(\\Rightarrow\\) \\({\\tt mse}({\\boldsymbol y}, \\hat{\\boldsymbol y})\\) 값이 작아짐\n\n와 같은 관계가 있음을 파악할 수 있다. 따라서 \\({\\tt mse}({\\boldsymbol y}, \\hat{\\boldsymbol y})\\)의 값이 작을수록 적절한 추세선이라 생각할 수 있다.\n5. 아래와 같은 수식을 이용하여 \\(\\hat{\\beta}_0, \\hat{\\beta}_1\\) 을 계산하라.\n\\[\\begin{bmatrix} \\hat{\\beta}_0 \\\\ \\hat{\\beta}_1 \\end{bmatrix} = ({\\bf X}^T {\\bf X})^{-1}{\\bf X}^T {\\boldsymbol y}, \\quad {\\bf X}=\\begin{bmatrix} 1 & x_1 \\\\ 1 & x_2 \\\\ \\dots \\\\ 1 & x_n \\end{bmatrix}\\]\n(풀이)\n\nX = np.stack([[1]*50 ,x],axis=1)\nnp.linalg.inv(X.T @ X)@X.T@y \n\narray([2.02868583, 3.10073712])\n\n\n\\(\\hat{\\beta}_0=1.97914281\\) 이고 \\(\\hat{\\beta}_1= 2.90834079\\) 이다.\n6. 5에서 계산된 \\(\\hat{\\beta}_0, \\hat{\\beta}_1\\)을 각각 \\(b=\\hat{\\beta}_0, a=\\hat{\\beta}_1\\)으로 생각하고 적절한 추세선 \\((x_i, \\hat{y}_i)\\)를 그려라. (단, \\(\\hat{y}_i=ax_i+b\\) 이다)\n(풀이)\n\nb, a = np.linalg.inv(X.T @ X)@X.T@y \nyhat = a*x +b \n\n\nplt.plot(x,y,'o',label=r'$(x_i,y_i)$')\nplt.plot(x,yhat,'--',label=r'$(x_i,\\hat{y}_i)$')\nplt.legend()\n\n\n\n\n\n\n\n\n7. 4의 기준에 따르면, \\((a,b)=(3,2)\\) 일때 만들어지는 추세선과 \\((a,b)=(\\hat{\\beta}_1,\\hat{\\beta}_0)\\) 일때 만들어지는 추세선은 어떤 것이 더 적절한가?\n(풀이)\n\nnp.mean((y-(3*x+2))**2), np.mean((y-yhat)**2)\n\n(0.8266459475811891, 0.8204353969296209)"
  },
  {
    "objectID": "posts/07wk-2.html#b.-이미지-자료처리-1",
    "href": "posts/07wk-2.html#b.-이미지-자료처리-1",
    "title": "07wk-2: numpy (2)",
    "section": "B. 이미지 자료처리",
    "text": "B. 이미지 자료처리\n### – 예비학습 이미지 자료의 이해\n- plt.imshow(...) 에서 ...이 shape이 (??,??)이면 흑백이미지를 출력\n\nplt.imshow([[0,255],[0,255]],cmap='gray')\n\n\n\n\n\n\n\n\n- plt.imshow(...) 에서 ...의 shape이 (??,??,3)이면 칼라이미지를 출력\n\nr = [[0,255],[0,255]]\ng = [[255,0],[0,0]]\nb = [[0,0],[255,0]]\nplt.imshow(np.stack([r,g,b],axis=2))\n\n\n\n\n\n\n\n\n- plt.imshow(...) 에서 ...의 자료형이 int인지 float인지에 따라서 인식이 다름\n\nr = [[0,1],[0,1]]\ng = [[1,0],[0,0]]\nb = [[0,0],[1,0]]\nplt.imshow(np.stack([r,g,b],axis=2))\n\n\n\n\n\n\n\n\n\nr = [[0,1.0],[0,1.0]]\ng = [[1.0,0],[0,0]]\nb = [[0,0],[1.0,0]]\nplt.imshow(np.stack([r,g,b],axis=2))\n\n\n\n\n\n\n\n\n### – 예비학습 끝\n\n!wget https://raw.githubusercontent.com/guebin/SC2022/main/hani.jpeg\nhani = np.einsum('ijk-&gt;jik',np.array(PIL.Image.open('hani.jpeg'),dtype=np.int64)/255)\n!rm hani.jpeg\n\n--2024-04-12 10:25:35--  https://raw.githubusercontent.com/guebin/SC2022/main/hani.jpeg\nResolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.110.133, 185.199.108.133, 185.199.109.133, ...\nConnecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.110.133|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 2445959 (2.3M) [image/jpeg]\nSaving to: ‘hani.jpeg’\n\nhani.jpeg           100%[===================&gt;]   2.33M  --.-KB/s    in 0.04s   \n\n2024-04-12 10:25:36 (62.3 MB/s) - ‘hani.jpeg’ saved [2445959/2445959]\n\n\n\n\nnote: 위 코드는 코랩 혹은 리눅스기반 환경에서 동작가능.\n\n불러온 이미지는 아래와 같다.\n\nhani,hani.shape\n\n(array([[[0.44705882, 0.48627451, 0.49411765],\n         [0.43137255, 0.46666667, 0.48627451],\n         [0.45882353, 0.50196078, 0.5254902 ],\n         ...,\n         [0.6627451 , 0.6627451 , 0.70196078],\n         [0.63529412, 0.62745098, 0.67058824],\n         [0.64313725, 0.63529412, 0.67843137]],\n \n        [[0.45882353, 0.49803922, 0.50588235],\n         [0.44313725, 0.48235294, 0.49019608],\n         [0.4627451 , 0.50588235, 0.52156863],\n         ...,\n         [0.63921569, 0.63921569, 0.67843137],\n         [0.64313725, 0.63529412, 0.67843137],\n         [0.63137255, 0.62352941, 0.66666667]],\n \n        [[0.45490196, 0.49411765, 0.50196078],\n         [0.4627451 , 0.49803922, 0.51764706],\n         [0.45882353, 0.50196078, 0.5254902 ],\n         ...,\n         [0.64313725, 0.64313725, 0.68235294],\n         [0.65490196, 0.65490196, 0.69411765],\n         [0.64313725, 0.64313725, 0.68235294]],\n \n        ...,\n \n        [[0.69411765, 0.69803922, 0.70588235],\n         [0.68627451, 0.69019608, 0.69803922],\n         [0.69411765, 0.69803922, 0.70588235],\n         ...,\n         [0.60784314, 0.6       , 0.60392157],\n         [0.6       , 0.59215686, 0.59607843],\n         [0.59607843, 0.58823529, 0.59215686]],\n \n        [[0.70196078, 0.70588235, 0.71372549],\n         [0.72156863, 0.7254902 , 0.73333333],\n         [0.69019608, 0.69411765, 0.70196078],\n         ...,\n         [0.61176471, 0.60392157, 0.60784314],\n         [0.60392157, 0.59607843, 0.6       ],\n         [0.61568627, 0.60784314, 0.61176471]],\n \n        [[0.7254902 , 0.72941176, 0.7372549 ],\n         [0.73333333, 0.7372549 , 0.74509804],\n         [0.70980392, 0.71372549, 0.72156863],\n         ...,\n         [0.61176471, 0.60392157, 0.60784314],\n         [0.60392157, 0.59607843, 0.6       ],\n         [0.61960784, 0.61176471, 0.61568627]]]),\n (4032, 3024, 3))\n\n\n\n이미지는 4032 \\(\\times\\) 3024 개의 격자(픽셀)로 이루어져 있음\n\n이미지를 보는 방법은 아래와 같다.\n\nplt.imshow(hani) # 모든이미지, 하니매트릭스\n\n\n\n\n\n\n\n\n\nplt.imshow(hani[1000:1500, 1000:2000,:]) # 얼굴만 확대, 하니의 서브매트릭스 \n\n\n\n\n\n\n\n\n3. 하니이미지를 나타내는 어레이를 변형하여 빨간색을 의미하는 칼라만 남겨서 “빨간하니”를 만들고 이미지를 출력하라.\n(풀이)\n\nred_hani = hani*0 \nred_hani[:,:,0] = hani[:,:,0]\nplt.imshow(red_hani)\n\n\n\n\n\n\n\n\n4. 하니의 모든 값에 루트를 취하여 “루트하니”를 만들고 “원본하니”와 “루트하니”를 좌우로 나란히 배치하여 출력하라.\n(풀이)\n\nroot_hani = np.sqrt(hani)\nplt.imshow(np.concatenate([hani,root_hani],axis=1))\n\n\n\n\n\n\n\n\n“루트하니”의 이미지는 “원본하니”의 이미지와 비교하여 어떤가? 왜 그러한 결과가 나왔다고 생각하는가?\n5. 하니의 모든값에 아래와 같은 함수를 적용하라.\n\n\\(f(x)=\\begin{cases} \\sqrt{x} & x&gt;0.7 \\\\ x & x \\leq 0.7 \\end{cases}\\)\n\n함수의 결과로 얻어진 매트릭스를 “후광하니”라고 부르자. “원본하니”와 “후광하니”를 좌우로 나란히 배치하여 출력하라.\n\nshiny_hani = np.sqrt(hani)*(hani&gt;0.7)+hani*(hani&lt;=0.7)\nplt.imshow(np.concatenate([hani,shiny_hani],axis=1))"
  },
  {
    "objectID": "posts/07wk-2.html#c.-mnist-data-1",
    "href": "posts/07wk-2.html#c.-mnist-data-1",
    "title": "07wk-2: numpy (2)",
    "section": "C. MNIST data",
    "text": "C. MNIST data\n아래는 0~9가지의 숫자이미지가 저장된 이미지데이터를 불러오는 코드이다.\n\n# URL 설정\nurl = 'https://github.com/guebin/PP2023/raw/main/posts/02_DataScience/mnist.npz'\n# URL에서 파일 다운로드\nurllib.request.urlretrieve(url, './mnist.npz')\n\n# 데이터 로드\ndata = np.load('./mnist.npz')\nxtrain, ytrain, xtest, ytest = data['x_train'], data['y_train'], data['x_test'], data['y_test']\n\n아래는 데이터에 대한 설명이다.\n\n전체의 이미지의 수는 70000개이며, 60000개의 이미지 \\({\\tt xtrain}\\)에 10000개의 이미지는 \\({\\tt xtest}\\)에 저장되어 있다.\n이미지에 대한 라벨은 각각 \\({\\tt ytrain}\\)과 \\(\\tt ytest\\)에 저장되어 있다. 따라서 \\(\\tt ytrain\\)에는 60000개의 이미지에 해당하는 라벨이, \\(\\tt ytest\\)에는 10000개의 이미지에 해당하는 라벨이 기록되어 있다.\n보통 분석에서는 60000개의 이미지를 가지고 라벨을 맞추는 “훈련”을 하고 (\\({\\tt xtrain}\\)을 이용하여 \\({\\tt ytrain}\\)을 맞추는 방법을 학습하고), 그러한 훈련이 잘 되었는지 10000개의 이미지를 이용하여 “테스트”한다.\n위와 같은 의미로 \\(({\\tt xtrain}, {\\tt ytrain})\\) 을 training data set, \\(({\\tt xtest},{\\tt ytest})\\) 를 test data set 이라고 부른다. (ref: 위키참고)\n\n아래는 이미지자료와 시각화에 대한 설명이다.\n\n각 이미지는 (28,28) 픽셀의 흑백이미지이다. 따라서 각 이미지는 (28,28,3) 이 아니라 (28,28) 의 shape을 가진 텐서로 구성되어있다.\n흑백이미지를 시각화 하기 위해서는 plt.imshow(img, cmap='gray')를 이용한다. 여기에서 \\({\\tt img}\\)은 임의의 2차원 텐서이며 이 예제의 경우 (28,28)의 shape을 가진다.\n\n아래는 \\({\\tt xtrain}\\)의 두번째 이미지, 즉 \\({\\tt xtrain[1,:,:]}\\)를 확인하는 코드의 예시이다.\n\n# plt.imshow(xtrain[1,:,:],cmap='gray')\nplt.imshow(xtrain[1],cmap='gray') ## 같은코드임\n\n\n\n\n\n\n\n\n이 이미지에 대한 label은 \\({\\tt ytrain[1]}\\)의 값으로 확인가능하다.\n\nytrain[1]\n\n0\n\n\n이미지와 라벨을 한번에 표현하는 코드는 아래와 같이 작성가능하다.\n\nplt.imshow(xtrain[1],cmap='gray')\nplt.title('label={}'.format(ytrain[1]));\n\n\n\n\n\n\n\n\n아래는 10개의 이미지를 라벨과 함께 출력하는 코드의 예시이다.\n\nfig, ax = plt.subplots(2,5,figsize=(10,5))\n\nax[0][0].imshow(xtrain[0],cmap='gray'); ax[0][0].set_title('label={}'.format(ytrain[0]));\nax[0][1].imshow(xtrain[1],cmap='gray'); ax[0][1].set_title('label={}'.format(ytrain[1]));\nax[0][2].imshow(xtrain[2],cmap='gray'); ax[0][2].set_title('label={}'.format(ytrain[2]));\nax[0][3].imshow(xtrain[3],cmap='gray'); ax[0][3].set_title('label={}'.format(ytrain[3]));\nax[0][4].imshow(xtrain[4],cmap='gray'); ax[0][4].set_title('label={}'.format(ytrain[4]));\n\nax[1][0].imshow(xtrain[5],cmap='gray'); ax[1][0].set_title('label={}'.format(ytrain[5]));\nax[1][1].imshow(xtrain[6],cmap='gray'); ax[1][1].set_title('label={}'.format(ytrain[6]));\nax[1][2].imshow(xtrain[7],cmap='gray'); ax[1][2].set_title('label={}'.format(ytrain[7]));\nax[1][3].imshow(xtrain[8],cmap='gray'); ax[1][3].set_title('label={}'.format(ytrain[8]));\nax[1][4].imshow(xtrain[9],cmap='gray'); ax[1][4].set_title('label={}'.format(ytrain[9]));\n\nfig.tight_layout()\n\n\n\n\n\n\n\n\n(1) 70000개의 이미지중 0~9에 해당하는 이미지는 각각 몇장씩 들어있는가?\n(풀이)\n\n_y = ytrain.tolist()+ytest.tolist()\n\n\n{s:_y.count(s) for s in set(_y)}\n\n{0: 6903,\n 1: 7877,\n 2: 6990,\n 3: 7141,\n 4: 6824,\n 5: 6313,\n 6: 6876,\n 7: 7293,\n 8: 6825,\n 9: 6958}\n\n\n(2) \\({\\tt xtrain}\\)에서 손글씨 0을 의미하는 이미지만을 모아서 새로운 텐서 \\({\\tt xtrain0}\\)를 만들어라. 이 텐서에서 처음과 마지막 이미지를 출력하라.\nhint: \\({\\tt xtrain0}\\) 의 shape은 (5923,28,28)이어야 한다.\n(풀이)\n\nxtrain0 = xtrain[ytrain==0]\nxtrain0.shape\n\n(5923, 28, 28)\n\n\n\nplt.imshow(xtrain0[0],cmap='gray') # 처음이미지\n\n\n\n\n\n\n\n\n\nplt.imshow(xtrain0[-1],cmap='gray') # 마지막이미지\n\n\n\n\n\n\n\n\n(3) \\({\\tt xtrain}\\)에서 손글씨 0을 의미하는 이미지의 평균을 계산하라. 즉 아래를 계산하라.\n\n\\({\\tt xtrain0mean} = \\frac{1}{5923}\\sum_{i=1}^{5923} {\\tt xtrain0[i, :, :]}\\)\n\n계산결과를 출력하라.\n(풀이)\n\nplt.imshow(xtrain0.mean(axis=0),cmap='gray')\n\n\n\n\n\n\n\n\n(4) \\({\\tt xtrain}\\)에서 각 라벨에 대한 평균이미지를 계산하고 계산결과를 \\({\\tt imgmean}\\)에 길이가 10인 list로 저장하라. 즉 \\({\\tt imgmean}\\)은 아래와 같은 자료구조를 가지고 있어야 한다.\n\n\\({\\tt imgmean}=\\big[{\\tt imgmean[0]},\\dots, {\\tt imgmean[9]}\\big]\\)\n\\({\\tt imgmean[0]}, \\dots, {\\tt imgmean[9]}\\) 는 각각 (28,28)의 shape을 가진 numpy array\n\\({\\tt imgmean[0]}, \\dots, {\\tt imgmean[9]}\\) 는 각각 숫자 0,1, …, 9의 평균이미지를 의미\n\n\\({\\tt imgmean[0]},\\dots, {\\tt imgmean[9]}\\)를 시각화 하라.\n(풀이)\n\nimgmean = [xtrain[ytrain==i].mean(axis=0) for i in range(10)] \n\n\nfig, ax = plt.subplots(2,5,figsize=(10,5))\n\nax[0][0].imshow(imgmean[0],cmap='gray')\nax[0][1].imshow(imgmean[1],cmap='gray')\nax[0][2].imshow(imgmean[2],cmap='gray')\nax[0][3].imshow(imgmean[3],cmap='gray')\nax[0][4].imshow(imgmean[4],cmap='gray')\n\nax[1][0].imshow(imgmean[5],cmap='gray')\nax[1][1].imshow(imgmean[6],cmap='gray')\nax[1][2].imshow(imgmean[7],cmap='gray')\nax[1][3].imshow(imgmean[8],cmap='gray')\nax[1][4].imshow(imgmean[9],cmap='gray')\n\nfig.tight_layout()\n\n\n\n\n\n\n\n\n(5) \\({\\tt xtrain}\\)의 두번째 이미지와 \\({\\tt imgmean[0]}\\)의 차이를 제곱한 값의 평균을 구하라. 즉 아래를 계산하라.\n\n\\(\\frac{1}{28\\times 28} \\sum_{p=0}^{27}\\sum_{q=0}^{27}\\big({\\tt xtrain[1,p,q]}-{\\tt imgmean[0][p,q]}\\big)^2\\)\n\n(풀이)\n\nnp.mean((xtrain[1,:,:]- imgmean[0])**2)\n\n2299.9585279846365\n\n\n(6) 모든 \\(j=0,1,\\dots,9\\) 에 대하여 아래를 계산하라.\n\n\\(\\frac{1}{28\\times 28} \\sum_{p=0}^{27}\\sum_{q=0}^{27}\\big({\\tt xtrain[1,p,q]}-{\\tt imgmean[j][p,q]}\\big)^2\\)\n\n계산값이 가장 작게 나오는 \\(j\\)는 얼마인가? 위의 계산결과를 토대로 \\({\\tt xtrain}\\)의 두번째 이미지는 어떠한 숫자를 의미한다고 “분류”하는 것이 타당한가?\n\n[np.mean((xtrain[1,:,:]- imgmean[i])**2) for i in range(10)]\n\n[2299.9585279846365,\n 7474.876421640121,\n 6154.997099653264,\n 5889.84882305034,\n 6763.709480023399,\n 4616.900123430389,\n 5856.367892213506,\n 6465.999476962735,\n 5916.546346421647,\n 6385.5252510342525]\n\n\n(7) 아래와 같은 numpy array 를 생성하라.\n\\[{\\tt loss}=\n\\begin{bmatrix}\n{\\tt loss[0,0]} & \\dots & {\\tt loss[0,9]} \\\\\n{\\tt loss[1,0]} & \\dots & {\\tt loss[1,9]} \\\\\n\\dots & \\dots &  \\dots \\\\\n{\\tt loss[59999,0]}& \\dots &{\\tt loss[59999,9]} \\\\\n\\end{bmatrix}\\]\n단, \\({\\tt loss[i,j]} = \\frac{1}{28\\times 28} \\sum_{p=0}^{27}\\sum_{q=0}^{27}\\big({\\tt xtrain[i,p,q]}-{\\tt imgmean[j][p,q]}\\big)^2\\)\n위에서 생성한 \\({\\tt loss}\\)를 이용해 (6)와 같은 방식으로 \\({\\tt xtrain}\\)의 모든 이미지에 대한 분류를 수행하라.\nhint: \\({\\tt loss}\\)에서 “최소값을 가지는 원소의 인덱스를 출력”하는 함수를 각 행별로 적용하면 된다.\n(풀이)\n\nloss = np.array([[np.mean((xtrain[j,:,:]- imgmean[i])**2) for i in range(10)] for j in range(60000)])\n\n\nloss.argmin(axis=1)\n\narray([5, 0, 4, ..., 5, 6, 8])\n\n\n(8) (7)에서 수행한 분류결과와 실제 라벨 \\({\\tt ytrain}\\)을 비교하라. 얼마나 많은 결과가 일치하는지 비율을 계산하라.\n(풀이)\n\nnp.sum(ytrain == loss.argmin(axis=1)) / 60000\n\n0.8079833333333334\n\n\n(9) \\({\\tt xtrain}\\)에서 학습한 평균이미지 \\({\\tt imgmean}\\)를 바탕으로 \\({\\tt xtest}\\)의 이미지를 분류하라. 분류결과를 \\({\\tt ytest}\\)와 비교하라. 얼마나 많은 결과가 일치하는지 비율을 계산하라.\n(풀이)\n\nest = np.array([[np.mean((xtest[j,:,:]- imgmean[i])**2) for i in range(10)] for j in range(10000)]).argmin(axis=1)\n\n\nnp.sum(est == ytest)/10000\n\n0.8203\n\n\n(10) (9)의 과정에서 잘못분류된 이미지 10개를 선택하여 시각화 하라.\n\n실제 라벨과 잘못된 라벨을 구분하여 시각화 할 것\n\n\n_ytest = ytest[est != ytest]\n_xtest = xtest[est != ytest]\n_est = est[est != ytest]\n\n\nfig, ax = plt.subplots(2,5,figsize=(10,5))\n\nax[0][0].imshow(_xtest[0],cmap='gray'); ax[0][0].set_title('{}/{}'.format(_ytest[0],_est[0]));\nax[0][1].imshow(_xtest[1],cmap='gray'); ax[0][1].set_title('{}/{}'.format(_ytest[1],_est[1]));\nax[0][2].imshow(_xtest[2],cmap='gray'); ax[0][2].set_title('{}/{}'.format(_ytest[2],_est[2]));\nax[0][3].imshow(_xtest[3],cmap='gray'); ax[0][3].set_title('{}/{}'.format(_ytest[3],_est[3]));\nax[0][4].imshow(_xtest[4],cmap='gray'); ax[0][4].set_title('{}/{}'.format(_ytest[4],_est[4]));\n\nax[1][0].imshow(_xtest[5],cmap='gray'); ax[1][0].set_title('{}/{}'.format(_ytest[5],_est[5]));\nax[1][1].imshow(_xtest[6],cmap='gray'); ax[1][1].set_title('{}/{}'.format(_ytest[6],_est[6]));\nax[1][2].imshow(_xtest[7],cmap='gray'); ax[1][2].set_title('{}/{}'.format(_ytest[7],_est[7]));\nax[1][3].imshow(_xtest[8],cmap='gray'); ax[1][3].set_title('{}/{}'.format(_ytest[8],_est[8]));\nax[1][4].imshow(_xtest[9],cmap='gray'); ax[1][4].set_title('{}/{}'.format(_ytest[9],_est[9]));\n\nfig.tight_layout()"
  },
  {
    "objectID": "posts/07wk-2.html#d.-회전변환-1",
    "href": "posts/07wk-2.html#d.-회전변환-1",
    "title": "07wk-2: numpy (2)",
    "section": "D. 회전변환",
    "text": "D. 회전변환\n1-3. 아래는 우산모양의 scatter plot을 그릴 수 있는 \\((x_i,y_i)\\) 좌표값을 불러와서 시각화하는 코드이다.\n\n# 자료저장 \ndata_raw = np.array(pd.read_csv('https://raw.githubusercontent.com/guebin/2021IR/master/_notebooks/round2.csv')).T\ndata_raw\n\narray([[ 12,  12,  13, ..., 636, 636, 637],\n       [313, 314, 279, ..., 416, 417, 409]])\n\n\n\n# 저장된 자료를 x,y로 분해 \nx_raw,y_raw = data_raw\nx_raw,y_raw\n\n(array([ 12,  12,  13, ..., 636, 636, 637]),\n array([313, 314, 279, ..., 416, 417, 409]))\n\n\n\n# 시각화\nplt.figure(figsize=(6,6)) # 그림크기고정\nplt.plot(x_raw,y_raw,'o')\n\n\n\n\n\n\n\n\n1. x_raw와 y_raw를 각각 표준화하고 x, y에 저장하라. 결과를 시각화하라. 그리고 x, y를 바탕으로 data matrix를 다시 구성하라.\n(풀이)\n표준화\n\nx= (x_raw-np.mean(x_raw)) / np.std(x_raw,ddof=1)\ny= (y_raw-np.mean(y_raw)) / np.std(y_raw,ddof=1)\n\n시각화\n\nplt.figure(figsize=(6,6)) # 그림크기고정\nplt.plot(x,y,'o')\n\n\n\n\n\n\n\n\ndata matrix 재구성\n\ndata = np.array([x,y])\ndata\n\narray([[-1.79820085, -1.79820085, -1.79255336, ...,  1.72583347,\n         1.72583347,  1.73148096],\n       [-0.18390658, -0.17703046, -0.41769466, ...,  0.52433376,\n         0.53120988,  0.47620092]])\n\n\n2. 아래와 같은 규칙에 따라 \\((x_i,y_i)\\)를 \\((\\tilde{x}_i,\\tilde{y}_i\\))로 변환하라. 단 여기에서 \\(\\theta= \\frac{\\pi}{4}\\)로 가정한다.\n\n\\({\\tt xx}_i = \\tilde{x}_i = (\\cos\\theta) x_i - (\\sin\\theta) y_i\\)\n\\({\\tt yy}_i = \\tilde{y}_i = (\\sin\\theta) x_i + (\\cos\\theta) y_i\\)\n\n\\((x_i,y_i)\\)와 \\((\\tilde{x}_i, \\tilde{y}_i)\\)를 겹쳐서 시각화 하라. 이 변환이 의미하는 바는 무엇이라고 생각하는가?\n(풀이1)\n\ntheta = np.pi/4 \nxx = np.cos(theta)*x - np.sin(theta)*y\nyy = np.sin(theta)*x + np.cos(theta)*y\nplt.figure(figsize=(6,6))\nplt.plot(x,y,'o', label=r'$(x,y)$') \nplt.plot(xx,yy,'o', label=r'$(xx,yy)$')\nplt.legend()\n\n\n\n\n\n\n\n\n(풀이2)\n아래의 규칙을 다시 고려하자.\n\n\\({\\tt xx}_i = \\tilde{x}_i = (\\cos\\theta) x_i - (\\sin\\theta) y_i\\)\n\\({\\tt yy}_i = \\tilde{y}_i = (\\sin\\theta) x_i + (\\cos\\theta) y_i\\)\n\n이는 아래와 같이 재표현가능하다.\n\n\\(\\begin{cases} {\\tt xx}_1 = (\\cos\\theta)x_1 - (\\sin\\theta)y_1 \\\\ {\\tt yy}_1 = (\\sin\\theta)x_1 + (\\cos\\theta)y_1 \\end{cases}\\)\n\\(\\begin{cases} {\\tt xx}_2 = (\\cos\\theta)x_2 - (\\sin\\theta)y_2 \\\\ {\\tt yy}_2 = (\\sin\\theta)x_2 + (\\cos\\theta)y_2 \\end{cases}\\)\n\\(\\dots\\)\n\\(\\begin{cases} {\\tt xx}_n = (\\cos\\theta)x_n - (\\sin\\theta)y_1 \\\\ {\\tt yy}_n = (\\sin\\theta)x_n + (\\cos\\theta)y_n \\end{cases}\\)\n\n이는 다시 아래와 같이 재 표현가능하다.\n\n\\(\\begin{bmatrix} {\\tt xx}_1 \\\\ {\\tt yy}_1 \\end{bmatrix} = \\begin{bmatrix} \\cos\\theta & - \\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ y_1 \\end{bmatrix}\\)\n\\(\\begin{bmatrix} {\\tt xx}_2 \\\\ {\\tt yy}_2 \\end{bmatrix} = \\begin{bmatrix} \\cos\\theta & - \\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix} \\begin{bmatrix} x_2 \\\\ y_2 \\end{bmatrix}\\)\n\\(\\dots\\)\n\\(\\begin{bmatrix} {\\tt xx}_n \\\\ {\\tt yy}_n \\end{bmatrix} = \\begin{bmatrix} \\cos\\theta & - \\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix} \\begin{bmatrix} x_n \\\\ y_n \\end{bmatrix}\\)\n\n이는 다시 아래와 같이 재 표현가능하다. (이게 처음엔 생각하기 어려워요!! \\(\\star\\star\\star\\))\n\n\\(\\begin{bmatrix} {\\tt xx}_1 & {\\tt xx}_2 & \\dots & {\\tt xx}_n \\\\ {\\tt yy}_1 & {\\tt yy}_2 & \\dots & {\\tt yy}_n \\end{bmatrix} = \\begin{bmatrix} \\cos\\theta & - \\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix} \\begin{bmatrix} x_1 & x_2 & \\dots & x_n \\\\ y_1 & y_2 & \\dots & y_n \\end{bmatrix}\\)\n\n위의 수식에 맞추어 변환을 진행하면\n\ntheta = np.pi/4 \nR = np.array([[np.cos(theta), -np.sin(theta)],[np.sin(theta),np.cos(theta)]])\nR \n\narray([[ 0.70710678, -0.70710678],\n       [ 0.70710678,  0.70710678]])\n\n\n\nR @ data\n\narray([[-1.14147842, -1.14634057, -0.97217191, ...,  0.8495886 ,\n         0.84472644,  0.88761703],\n       [-1.40156161, -1.39669946, -1.56288136, ...,  1.59110851,\n         1.59597066,  1.56106683]])\n\n\n\nxx,yy = R @ data \n\n\nplt.figure(figsize=(6,6))\nplt.plot(x,y,'o', label=r'$(x,y)$') \nplt.plot(xx,yy,'o', label=r'$(xx,yy)$')\nplt.legend()\n\n\n\n\n\n\n\n\n3. 2번과 같은 변환을 8번 연속진행한 결과를 시각화하라.\n(풀이)\n\nplt.figure(figsize=(6,6))\nxx,yy=np.linalg.matrix_power(R,8) @ data\nplt.plot(x,y,'o',label=r'$data=(x,y)$') \nplt.plot(xx,yy,'o',label=r'$R^8@data=(xx,yy)$')\nplt.legend()\n\n\n\n\n\n\n\n\n4. 2번의 변환을 역변환하는 코드를 구현하라. 원본, 변환, 역변환한 자료를 순서대로 시각화 하라. 결과를 아래와 같이 저장하라.\n\n원본: \\({\\tt x}, {\\tt y}\\)\n2번변환: \\({\\tt xx}, {\\tt yy}\\)\n2번의역변환 \\({\\tt xxx}, {\\tt yyy}\\)\n\n(풀이)\n\nxx,yy = R@data \nxxx,yyy = np.linalg.inv(R)@data\n\n\nplt.figure(figsize=(6,6))\nplt.plot(x,y,'.', label=r'$data = (x,y)$') \nplt.plot(xx,yy,'.', label=r'$R@data = (xx,yy)$')\nplt.plot(xxx,yyy,'.', label=r'$R^{-1}@data = (xxx,yyy)$')\nplt.legend()"
  },
  {
    "objectID": "posts/07wk-2.html#e.-삼성전자의-주가-1",
    "href": "posts/07wk-2.html#e.-삼성전자의-주가-1",
    "title": "07wk-2: numpy (2)",
    "section": "E. 삼성전자의 주가",
    "text": "E. 삼성전자의 주가\n5-8. 시계열 자료와 이동평균\n5. 아래의 수식에 따르는 수열 \\(x_t\\)를 생성하라. 단, \\(T=1000\\) 으로 설정하고 랜덤시드는 np.random.seed(2)와 같이 설정한다.\n\n\\(x_1=\\epsilon_1\\)\n\\(x_2=\\epsilon_1+\\epsilon_2\\)\n\\(x_3=\\epsilon_1+\\epsilon_2+\\epsilon_3\\)\n\\(\\dots\\)\n\\(x_T=\\sum_{t=1}^{T} \\epsilon_t\\)\n\n생성결과를 시각화하라.\nhint 아래의 코드를 활용하면 쉽다.\n\nnp.cumsum([1,2,3,4])\n\narray([ 1,  3,  6, 10])\n\n\n(풀이)\n\nT = 1000\nnp.random.seed(2)\nepsilon = np.random.randn(1000)\nx = epsilon.cumsum()\nplt.plot(x)\n\n\n\n\n\n\n\n\n6. 아래와 같은 변환을 수행하고 결과를 시각화 하라.\n\n\\({\\tt xx}_1= \\frac{1}{3}(x_1+x_2)\\)\n\\({\\tt xx}_2= \\frac{1}{3}(x_1+x_2+x_3)\\)\n\\({\\tt xx}_3= \\frac{1}{3}(x_2+x_3+x_4)\\)\n\\(\\dots\\)\n\\({\\tt xx}_{T-1}= \\frac{1}{3}(x_{T-1}+x_{T-1}+x_T)\\)\n\\({\\tt xx}_{T}= \\frac{1}{3}(x_{T-1}+x_T)\\)\n\nhint 아래의 수식을 이용하라.\n\n\\(\\begin{bmatrix} {\\tt xx}_1 \\\\ {\\tt xx}_2 \\\\ {\\tt xx}_3 \\\\ \\dots \\\\ {\\tt xx}_{T-1} \\\\ {\\tt xx}_T \\end{bmatrix}= \\begin{bmatrix} 1/3 & 1/3 & 0 & 0 & 0 & \\dots & 0 & 0 & 0 & 0 \\\\ 1/3 & 1/3 & 1/3 & 0 & 0 & \\dots & 0 & 0 & 0 & 0 \\\\ 0 & 1/3 & 1/3 & 1/3 & 0 & \\dots & 0 & 0 & 0 & 0 \\\\ \\dots & \\dots & \\dots & \\dots & \\dots & \\dots & \\dots & \\dots & \\dots & \\dots \\\\ 0 & 0 & 0 & 0 & 0 & \\dots & 0 & 1/3 & 1/3 & 1/3 \\\\ 0 & 0 & 0 & 0 & 0 & \\dots & 0 & 0 & 1/3 & 1/3 \\\\ \\end{bmatrix}\\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ \\dots \\\\ x_{T-1} \\\\ x_T \\end{bmatrix}\\)\n\n(풀이)\n\nM = np.array([[abs(i-j)&lt;2 for i in range(T)] for j in range(T)])*1/3\nM\n\narray([[0.33333333, 0.33333333, 0.        , ..., 0.        , 0.        ,\n        0.        ],\n       [0.33333333, 0.33333333, 0.33333333, ..., 0.        , 0.        ,\n        0.        ],\n       [0.        , 0.33333333, 0.33333333, ..., 0.        , 0.        ,\n        0.        ],\n       ...,\n       [0.        , 0.        , 0.        , ..., 0.33333333, 0.33333333,\n        0.        ],\n       [0.        , 0.        , 0.        , ..., 0.33333333, 0.33333333,\n        0.33333333],\n       [0.        , 0.        , 0.        , ..., 0.        , 0.33333333,\n        0.33333333]])\n\n\n\nplt.plot(x,label=r'$x$')\nplt.plot(M@x,'--',label=r'$M@x$')\nplt.legend()\n\n\n\n\n\n\n\n\n\n끝이 올라간 이유? 마지막에 \\(\\frac{1}{3}(x_{T-1}+x_T+x_{T+1})\\) 대신에 \\(\\frac{1}{3}(x_{T-1}+x_T+0)\\) 을 이용하였기 때문\n\n7. 아래와 같은 변환을 수행하고 결과를 시각화하라.\n\n\\({\\tt xx}_1= \\frac{1}{3}(x_1+x_1+x_2)\\)\n\\({\\tt xx}_2= \\frac{1}{3}(x_1+x_2+x_3)\\)\n\\({\\tt xx}_3= \\frac{1}{3}(x_2+x_3+x_4)\\)\n\\(\\dots\\)\n\\({\\tt xx}_{T-1}= \\frac{1}{3}(x_{T-1}+x_{T-1}+x_T)\\)\n\\({\\tt xx}_{T}= \\frac{1}{3}(x_{T-1}+x_T+x_T)\\)\n\n(풀이)\n\nM[0,0] = 2/3 \nM[-1,-1] = 2/3 \nplt.plot(x,label=r'$x$')\nplt.plot(M@x,label=r'$M@x$')\nplt.legend()\n\n\n\n\n\n\n\n\n8. 7번의 변환을 100번 반복하고 시각화하라.\n(풀이)\n\nplt.plot(x,label=r'$x$')\nplt.plot(np.linalg.matrix_power(M,100)@x,label=r'$M^{100}@x$')\nplt.legend()\n\n\n\n\n\n\n\n\n9. 7번의 변환을 1000번 반복하고 시각화하라.\n\nplt.plot(x,label=r'$x$')\nplt.plot(np.linalg.matrix_power(M,1000)@x,label=r'$M^{1000}@x$')\nplt.legend()"
  },
  {
    "objectID": "posts/03wk-2.html#a.-벡터화연산브로드캐스팅-불가능",
    "href": "posts/03wk-2.html#a.-벡터화연산브로드캐스팅-불가능",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "A. 벡터화연산(브로드캐스팅) 불가능",
    "text": "A. 벡터화연산(브로드캐스팅) 불가능\n- 벡터화연산 불가능 (최악의 단점)\n\nlst = [1,2,3]\nlst + 1\n\nTypeError: can only concatenate list (not \"int\") to list\n\n\n\narr = np.array([1,2,3])\narr + 1\n\narray([2, 3, 4])"
  },
  {
    "objectID": "posts/03wk-2.html#b.-bool을-이용한-인덱싱이-불가능",
    "href": "posts/03wk-2.html#b.-bool을-이용한-인덱싱이-불가능",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "B. bool을 이용한 인덱싱이 불가능",
    "text": "B. bool을 이용한 인덱싱이 불가능\n- True, False 가 포함된 array를 이용한 인덱싱이 불가능하다.\n- 넘파이에서 bool을 이용한 인덱싱\n\narr = np.array([1,2,3,4,5])\narr[arr&gt;3]\n\narray([4, 5])\n\n\n- 리스트는 불가능\n\nlst = [1,2,3,4,5]\nlst[lst&gt;3]\n\nTypeError: '&gt;' not supported between instances of 'list' and 'int'\n\n\n\nlst&gt;3\n\nTypeError: '&gt;' not supported between instances of 'list' and 'int'"
  },
  {
    "objectID": "posts/03wk-2.html#c.-넘파이-특화-메소드-사용불가능",
    "href": "posts/03wk-2.html#c.-넘파이-특화-메소드-사용불가능",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "C. 넘파이 특화 메소드 사용불가능",
    "text": "C. 넘파이 특화 메소드 사용불가능\n- 넘파이 특화 메소드\n\narr = np.array([5,4,3,2,1])\narr\n\narray([5, 4, 3, 2, 1])\n\n\n\narr.min(), arr.max(), arr.mean(), arr.argmin(), arr.argmax()\n\n(1, 5, 3.0, 4, 0)\n\n\n\narr.sort()\narr\n\narray([1, 2, 3, 4, 5])\n\n\n- 리스트는?\n\nlst = [5,4,3,2,1]\nlst\n\n[5, 4, 3, 2, 1]\n\n\n\nlst.min(), lst.max(), lst.mean(), lst.argmin(), lst.argmax()\n\nAttributeError: 'list' object has no attribute 'min'\n\n\n\nlst.sort()\nlst\n\n[1, 2, 3, 4, 5]\n\n\n# 메소드란? – 자료형에 종속된 특수기술\n\n# 넘파이 특수기술\narr = np.array([1,2,3])\narr.max() # max(arr)로 해석\n\n3\n\n\n\n# ?.max() 이런건 넘파이 특수기술 이니까 ?자리에 리스트일 경우는 실행안됨\nlst = [1,2,3]\nlst.max() \n\nAttributeError: 'list' object has no attribute 'max'\n\n\n\n# 리스트의 특수기술 \nlst = [1,2,3]\nlst.append(4) # append(lst,4) 로 해석\nlst\n\n[1, 2, 3, 4]\n\n\n\n# 문자열 특수기술\ns = 'asdf'\ns.capitalize() # capitalize(s) 로 해석\n\n'Asdf'\n\n\n\n# 문자열 특수기술\ns = '-'\nlst = ['x','y','z']\ns.join(lst) # join(s,lst) 로 해석\n\n'x-y-z'\n\n\n\njoin(s,lst)의 뜻: lst의 각 원소를 모두 “이어서” 하나의 문자열로 만들어라. 단, 원소간의 구분은 s에 저장된 문자열로 하라.\n\n\n# 문자열 특수기술 응용\n''.join(['x','y','z'])\n\n'xyz'\n\n\n\n# 문자열 특수기능 \ns = \"제 이름은 {} 입니다.\" \nname = \"최규빈\"\ns.format(name) # format(s,name)\n\n'제 이름은 최규빈 입니다.'\n\n\n\nformat(s,name)의 뜻: s라는 문자열의 포맷에 {} 자리에 name을 끼워넣어라."
  },
  {
    "objectID": "posts/03wk-2.html#d.-파이썬에서-쓰레기-같은-자료형은-없다.",
    "href": "posts/03wk-2.html#d.-파이썬에서-쓰레기-같은-자료형은-없다.",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "D. 파이썬에서 쓰레기 같은 자료형은 없다.",
    "text": "D. 파이썬에서 쓰레기 같은 자료형은 없다.\n- 파이썬에는 각 자료형마다 사용할 수 있는 고유기술(=메소드)이나 문법이 있음.\n- 내가 생각할 때 리스트는 필요없는 자료형이야 = 난 리스트만 가지고 있는 어떠한 고유특징을 활용하지 못해.\n- 파이썬을 잘 하려면 자료형에 따른 고유 특징을 이해하고 활용할 줄 알아야 한다.\n\n기본자료형: str, list, tuple, dict, set – 이러한 자료형을 이해하고 기능을 활용해야함\n모듈: 넘파이배열, 판다스"
  },
  {
    "objectID": "posts/03wk-2.html#a.-문제파악",
    "href": "posts/03wk-2.html#a.-문제파악",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "A. 문제파악",
    "text": "A. 문제파악\n\n- 기존의 문제들과 다르게 numpy를 이용하여 풀기는 어려울 것 같다. 뭔가 기존문제들과 결이 다름\n- 그런데 코딩으로 해결가능할 것 같긴 함"
  },
  {
    "objectID": "posts/03wk-2.html#b.-슈도알고리즘",
    "href": "posts/03wk-2.html#b.-슈도알고리즘",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "B. 슈도알고리즘",
    "text": "B. 슈도알고리즘\n1. 편의상 \\([x,x,y,y,z]\\)를 \\([x_1,x_2,y_1,y_2,z]\\)와 같이 생각하고 나열한다. (5! = 120 개만큼 경우가 나열되겠지)\n2. 중복을 제거한다. 즉 아래는 모두 같은 경우로 생각한다.\n\n\\([x_1,x_2,y_1,y_2,z]\\)\n\\([x_1,x_2,y_2,y_1,z]\\)\n\\([x_2,x_1,y_1,y_2,z]\\)\n\\([x_2,x_1,y_2,y_1,z]\\)"
  },
  {
    "objectID": "posts/03wk-2.html#c.-예비학습",
    "href": "posts/03wk-2.html#c.-예비학습",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "C. 예비학습",
    "text": "C. 예비학습\n# 개념1 – 집합이라는 자료형이 있음.\n\na = {1,2,3}\ntype(a)\n\nset\n\n\n그런데 집합은 중복된 원소를 포함하지 않았음 (중학교때 배운듯)\n\na = {1,2,3,3,3}\na\n\n{1, 2, 3}\n\n\n#\n# 개념2 – 자료형변환을 이용하여 중복된 원소를 제거\n아래와 같은 자료형이 있다고 하자.\n\nlst = [1,2,3,3,3] \nlst\n\n[1, 2, 3, 3, 3]\n\n\n중복된 것을 제외하고 싶다면?\n\nlist(set(lst)) # 자료형변환\n\n[1, 2, 3]\n\n\n#\n# 개념3 – 고유의 원소 숫자 세기\n\nlst = [1,2,3,3,3,4,4,5,5,6] \nlst\n\n[1, 2, 3, 3, 3, 4, 4, 5, 5, 6]\n\n\n\nlen(set(lst))\n\n6\n\n\n#\n# 개념4 – for문\n아래를 출력하고 싶다고 하자.\n이효리는 핑클의 멤버이다. \n옥주현은 핑클의 멤버이다.\n성유리는 핑클의 멤버이다. \n이진은 핑클의 멤버이다. \n(풀이1) – 단순한 풀이\n\nprint(\"이효리는 핑클의 멤버이다.\")\nprint(\"옥주현은 핑클의 멤버이다.\")\nprint(\"성유리는 핑클의 멤버이다.\")\nprint(\"이진은 핑클의 멤버이다.\")\n\n이효리는 핑클의 멤버이다.\n옥주현은 핑클의 멤버이다.\n성유리는 핑클의 멤버이다.\n이진은 핑클의 멤버이다.\n\n\n(풀이2) – 문자열 특수기능을 이용해볼까?\n“{} 핑클의 멤버이다.” 이 공통포맷이므로, 아래와 같이 수행할 수 있겠다.\n\nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\ni = 0\nprint(\"{} 핑클의 멤버이다.\".format(lst[i]))\ni = 1 \nprint(\"{} 핑클의 멤버이다.\".format(lst[i]))\ni = 2 \nprint(\"{} 핑클의 멤버이다.\".format(lst[i]))\ni = 3 \nprint(\"{} 핑클의 멤버이다.\".format(lst[i]))\n\n이효리는 핑클의 멤버이다.\n옥주현은 핑클의 멤버이다.\n성유리는 핑클의 멤버이다.\n이진은 핑클의 멤버이다.\n\n\n(풀이3) - for와 문자열 특수기능을 이용해볼까?\n\nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\nfor i in [0,1,2,3]:\n    print(\"{} 핑클의 멤버이다.\".format(lst[i]))\n\n이효리는 핑클의 멤버이다.\n옥주현은 핑클의 멤버이다.\n성유리는 핑클의 멤버이다.\n이진은 핑클의 멤버이다.\n\n\n(풀이4) - for와 문자열 특수기능을 이용해볼까? (2)\n[0,1,2,3]은 대충 range(4)와 비슷한 것이므로 아래와 같이 수행할 수도 있겠음.\n\nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\nfor i in range(4):\n    print(\"{} 핑클의 멤버이다.\".format(lst[i]))\n\n이효리는 핑클의 멤버이다.\n옥주현은 핑클의 멤버이다.\n성유리는 핑클의 멤버이다.\n이진은 핑클의 멤버이다.\n\n\n(풀이5) - for와 문자열 특수기능을 이용해볼까? (3)\n아래의 코드는 \\(i\\) 자리에 [0,1,2,3]의 원소가 번갈아 대입되며 ??????가 수행되었음.\nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\nfor i in [0,1,2,3]:\n    ??????\n아래의 코드도 \\(i\\) 자리에 range(4)의 원소가 번갈아 대입되며 ??????가 수행되었다고 해석가능.\nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\nfor i in range(4):\n    ??????\n아래의 코드는 어떻게 실행될까??\nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\nfor i in lst:\n    ??????\n\n# R과 다른 방식으로 동작하는 for문 \nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\nfor l in lst:\n    print(\"{} 핑클의 멤버이다.\".format(l))\n\n이효리는 핑클의 멤버이다.\n옥주현은 핑클의 멤버이다.\n성유리는 핑클의 멤버이다.\n이진은 핑클의 멤버이다.\n\n\n#\n# 개념5 – for문을 이용하여 리스트의 원소 추가하기\n\nlst2 = [] # lst2 = list() 와 같은결과임\nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\nfor l in lst: \n    lst2.append(\"{} 핑클의 멤버이다.\".format(l))\n\n\nlst2\n\n['이효리는 핑클의 멤버이다.', '옥주현은 핑클의 멤버이다.', '성유리는 핑클의 멤버이다.', '이진은 핑클의 멤버이다.']\n\n\n그런데 이걸 아래와 같이 해결할 수도 있다.\n\nlst = [\"이효리는\",\"옥주현은\",\"성유리는\",\"이진은\"]\n[\"{} 핑클의 멤버이다.\".format(l) for l in lst] # 리스트컴프리헨션 \n\n['이효리는 핑클의 멤버이다.', '옥주현은 핑클의 멤버이다.', '성유리는 핑클의 멤버이다.', '이진은 핑클의 멤버이다.']\n\n\n#\n# 개념6 – 리스트컴프리헨션\n집합을 표현하는 방법에는 원소나열법과 조건제시법이 있다.\n\n원소나열법: \\(\\{2^0,2^1,2^2,2^3\\}\\)\n조건제시법: \\(\\{2^i: \\text{ for } i=0,1,2,3\\}\\)\n\n이중에서 조건제시법은 아래와 같이 표현할 수 있음.\n\n\\(\\{2^i: \\text{ for } i \\in \\{0,1,2,3\\}\\}\\)\n\n여기에서 \\(\\in\\) 은 in 으로 읽으므로, 위의 표기법을 연상하여 파이썬 코드로 바꿔보면\n[2^i: for i in [0,1,2,3]]\n와 같은 방식으로 리스트의 원소를 표현할 수 있을 것 같다. 위의 코드는 실행되지 않지만 아래의 코드는 실행가능하다.\n\n[2**i for i in [0,1,2,3]]\n\n[1, 2, 4, 8]\n\n\n\n[2**i for i in range(4)]\n\n[1, 2, 4, 8]\n\n\n이를 응용하면\n\n[\"asdf{}\".format(2**i) for i in range(4)]\n\n['asdf1', 'asdf2', 'asdf4', 'asdf8']\n\n\n이것을 다시 응용하면\n\nlst = [\"이효리는\", \"성유리는\", \"옥주현은\", \"이진은\"]\n[\"{} 핑클의 멤버이다.\".format(l) for l in lst]\n\n['이효리는 핑클의 멤버이다.', '성유리는 핑클의 멤버이다.', '옥주현은 핑클의 멤버이다.', '이진은 핑클의 멤버이다.']\n\n\n#\n# 개념7 – 스트링의 인덱싱 (파이썬에서는 스트링을 array로 취급)\n\ns = 'asdf'\ns\n\n'asdf'\n\n\n\ns[0]\n\n'a'\n\n\n\ns[-1]\n\n'f'\n\n\n\ns[:2]\n\n'as'\n\n\n#\n# 개념8 – 스트링과 리스트의 변환\n\ns = 'asdf' \ns\n\n'asdf'\n\n\n\nlst = list(s)\nlst\n\n['a', 's', 'd', 'f']\n\n\n\n''.join(lst)\n\n'asdf'\n\n\n# 개념9 – 튜플자료형\n\nlst = [1,2,3]\nlst\n\n[1, 2, 3]\n\n\n\ntpl = (1,2,3)\ntpl\n\n(1, 2, 3)\n\n\n튜플은 (의미가 명확할때) 괄호를 생략할 수 있음\n\ntpl = 1,2,3\ntpl\n\n(1, 2, 3)\n\n\n튜플은 리스트와 매우 비슷함.\n\n[1,2,3] + [4,5] \n\n[1, 2, 3, 4, 5]\n\n\n\n(1,2,3) + (4,5)\n\n(1, 2, 3, 4, 5)\n\n\n아래도 가능\n\n''.join(['a','b','c'])\n\n'abc'\n\n\n\n''.join(('a','b','c'))\n\n'abc'\n\n\n#\n# 개념10 – for를 수행하는 다양한 테크닉\n우리가 알고 있는 for: 리스트 비슷한 것을 만든 뒤, 그 리스트의 원소를 하나씩 뽑아가면서 어떠한 반복구문 “??????” 수행하는 것.\n\nimport itertools\n\n\nfor i in itertools.permutations(['a','b','c']):\n    print(i)\n\n('a', 'b', 'c')\n('a', 'c', 'b')\n('b', 'a', 'c')\n('b', 'c', 'a')\n('c', 'a', 'b')\n('c', 'b', 'a')\n\n\n\nfor i in itertools.product(['x','y'],['a','b','c']):\n    print(i)\n\n('x', 'a')\n('x', 'b')\n('x', 'c')\n('y', 'a')\n('y', 'b')\n('y', 'c')\n\n\n#"
  },
  {
    "objectID": "posts/03wk-2.html#d.-풀이",
    "href": "posts/03wk-2.html#d.-풀이",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "D. 풀이",
    "text": "D. 풀이\n아래의 문제를 풀어보자..\n\n(풀이)\n\nlen(set([''.join(i) for i in itertools.permutations(['x','x','y','y','z'])]))\n\n30"
  },
  {
    "objectID": "posts/03wk-2.html#a.-문제이해",
    "href": "posts/03wk-2.html#a.-문제이해",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "A. 문제이해",
    "text": "A. 문제이해"
  },
  {
    "objectID": "posts/03wk-2.html#b.-슈도알고리즘-1",
    "href": "posts/03wk-2.html#b.-슈도알고리즘-1",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "B. 슈도알고리즘",
    "text": "B. 슈도알고리즘\n1. 아래의 경우를 모두 나열한다.\na,b,c,d = 1,1,1,1 \na,b,c,d = 1,1,1,2 \n....\na,b,c,d = 6,6,6,6\n2. 조건 \\(a \\leq c \\leq d\\) 와 \\(b \\leq c \\leq d\\) 를 동시에 만족하는 경우를 센다."
  },
  {
    "objectID": "posts/03wk-2.html#c.-예비학습-1",
    "href": "posts/03wk-2.html#c.-예비학습-1",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "C. 예비학습",
    "text": "C. 예비학습\n# 개념1 – for문과 튜플\n\nlst = [['최규빈',43052,'M'],['아이유',54321,'F'],['하니',11223,'F']]\nlst[0]\n\n['최규빈', 43052, 'M']\n\n\n아래의 코드가 가능하다.\n\nfor [name,student_id,sex] in lst:\n    print([name,student_id,sex])\n# [name,student_id,sex] = ['최규빈', 43052, 'M']\n# print([name,student_id,sex])\n# [name,student_id,sex] = ['아이유', 54321, 'F']\n# print([name,student_id,sex])\n# [name,student_id,sex] = ['하니', 11223, 'F']\n# print([name,student_id,sex])\n\n['최규빈', 43052, 'M']\n['아이유', 54321, 'F']\n['하니', 11223, 'F']\n\n\n리스트를 튜플로 바꾼다면?\n\nfor (name,student_id,sex) in lst:\n    print((name,student_id,sex))\n# (name,student_id,sex) = ['최규빈', 43052, 'M']\n# print((name,student_id,sex))\n# (name,student_id,sex) = ['아이유', 54321, 'F']\n# print((name,student_id,sex))\n# (name,student_id,sex) = ['하니', 11223, 'F']\n# print((name,student_id,sex))\n\n('최규빈', 43052, 'M')\n('아이유', 54321, 'F')\n('하니', 11223, 'F')\n\n\nfor (name,student_id,sex) in lst: 대신에 for name,student_id,sex in lst: 도 가능\n\nfor name,student_id,sex in lst:\n    print((name,student_id,sex))\n# name,student_id,sex = ['최규빈', 43052, 'M']\n# print((name,student_id,sex))\n# name,student_id,sex = ['아이유', 54321, 'F']\n# print((name,student_id,sex))\n# name,student_id,sex = ['하니', 11223, 'F']\n# print((name,student_id,sex))\n\n('최규빈', 43052, 'M')\n('아이유', 54321, 'F')\n('하니', 11223, 'F')\n\n\n아래와 같이 컴프리헨션으로 만들 수도 있음.\n\n[[name,student_id,sex] for name,student_id,sex in lst]\n\n[['최규빈', 43052, 'M'], ['아이유', 54321, 'F'], ['하니', 11223, 'F']]\n\n\n\n[(name,student_id,sex) for name,student_id,sex in lst]\n\n[('최규빈', 43052, 'M'), ('아이유', 54321, 'F'), ('하니', 11223, 'F')]\n\n\n아래는 불가능\n\n[name,student_id,sex for name,student_id,sex in lst]\n\nSyntaxError: did you forget parentheses around the comprehension target? (905514563.py, line 1)\n\n\n하지만 괄호를 명확하게 쓰기만 하면 만들어짐\n\n[(name,sex) for name,student_id,sex in lst]\n\n[('최규빈', 'M'), ('아이유', 'F'), ('하니', 'F')]\n\n\n\n[(sex,name) for name,student_id,sex in lst]\n\n[('M', '최규빈'), ('F', '아이유'), ('F', '하니')]\n\n\n\n[name for name,student_id,sex in lst]\n\n['최규빈', '아이유', '하니']\n\n\n언더스코어(_)를 사용할 수도 있음.\n\n[name for name,_,_ in lst]\n\n['최규빈', '아이유', '하니']\n\n\n언더스코어(_)를 사용시 lst[0], lst[1] 등의 원소숫자와 일치하도록 사용해야함\n\n[name for name,_ in lst] # 이건 또 실행불가능..\n\nValueError: too many values to unpack (expected 2)\n\n\n\n[name for name, *args in lst] # 이건 실행가능\n\n['최규빈', '아이유', '하니']\n\n\n# 개념2 – 조건문\n아래의 리스트 원소 \\(l\\) 중에서 조건 \\(1 &lt; l \\leq 5\\)를 만족하는 원소는 모두 몇개인가?\n\nlst = [1,2,3,4,5,6,7,8,9] \nlst\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n(풀이)\n\nsum([1&lt;l and l&lt;=5 for l in lst])\n\n4\n\n\n\nsum([1&lt;l&lt;=5 for l in lst])\n\n4"
  },
  {
    "objectID": "posts/03wk-2.html#d.-풀이-1",
    "href": "posts/03wk-2.html#d.-풀이-1",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "D. 풀이",
    "text": "D. 풀이\n\n(풀이)\n\nlst = [1,2,3,4,5,6]\nsum([a&lt;=c&lt;=d and b&lt;=c&lt;=d for a,b,c,d in itertools.product(lst,lst,lst,lst)])\n\n196"
  },
  {
    "objectID": "posts/03wk-2.html#a.-문제파악-1",
    "href": "posts/03wk-2.html#a.-문제파악-1",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "A. 문제파악",
    "text": "A. 문제파악"
  },
  {
    "objectID": "posts/03wk-2.html#b.-예비학습",
    "href": "posts/03wk-2.html#b.-예비학습",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "B. 예비학습",
    "text": "B. 예비학습\n- 예제: 제곱수중에서 12로 나누어서 떨어지는 수만 원소르 가지는 리스트를 만들고 싶다.\n\n제곱수: 1,4,9,16,25,36,…\n12로 나누어서 떨어지는 수: 36\n\n(복습1)\n\n12 % 4 # % 는 나머지를 계산하는 연산자, 12를 4로 나누었더니 나머지가 0\n\n0\n\n\n\n12 % 5 # 12 = 5*2 +2 \n\n2\n\n\n(복습2)\n\na = 3 # a에 2를 대입하라...\n\n\na == 2 # a에 들어있는 값이 2이인지 테스트하라..\n\nFalse\n\n\n\na == 3\n\nTrue\n\n\n(풀이1) – 비어있는 리스트를 만들고, for + if 를 사용\n\nlst = []\nfor i in range(1,101):\n    if i**2 % 12 == 0: # i^2을 12로 나누어서 나누어 떨어진다면\n        lst.append(i**2)\n\n\nlst\n\n[36,\n 144,\n 324,\n 576,\n 900,\n 1296,\n 1764,\n 2304,\n 2916,\n 3600,\n 4356,\n 5184,\n 6084,\n 7056,\n 8100,\n 9216]\n\n\n(풀이2) - if문이 포함된 리스트 컴프리헨션\n\n[i**2 for i in range(1,101) if i**2 % 12 ==0] \n\n[36,\n 144,\n 324,\n 576,\n 900,\n 1296,\n 1764,\n 2304,\n 2916,\n 3600,\n 4356,\n 5184,\n 6084,\n 7056,\n 8100,\n 9216]"
  },
  {
    "objectID": "posts/03wk-2.html#c.-풀이",
    "href": "posts/03wk-2.html#c.-풀이",
    "title": "03wk-2: 리스트는 쓰레기인가?",
    "section": "C. 풀이",
    "text": "C. 풀이\n\n(풀이)\n\nx = list(range(1,16))\nf = lambda x: np.sin(np.pi/4*x)\nsum([xi for xi in x if f(2+xi)*f(2-xi)&lt;1/4])\n\n32"
  },
  {
    "objectID": "posts/07wk-1.html",
    "href": "posts/07wk-1.html",
    "title": "07wk-1: 퀴즈4",
    "section": "",
    "text": "Caution\n\n\n\n\n전북대 학생들을 시험당일 학생증을 지참할 것. (출석체크 및 본인확인) 학생증 외에 신분증 여권등도 가능.\n부정행위 (카카오톡 채팅을 통한 코드공유, 생성형모델 사용, 대리시험 등) 적발시 F 처리함.\n퀴즈 중 지각할 경우 지각사실을 기록함. 하지만 별 다른 감점은 하지 않음.\n.ipynb 파일 형태로 제출된 답안지만 채점하며 그 외의 형식 (.hwp, .py 등)은 채점하지 않음. 즉 0점 처리함.\n\n\n\n\nimport numpy as np\nimport pandas as pd\n\n\n1. – 10점\n아래는 파이썬프로그래밍 수강생들의 학번, 이름, 출석점수, 과제점수, 중간고사점수, 기말고사점수를 저장한 중첩리스트이다.\n\nlst = [['2021-43052', 'GuebinChoi', 5, 10, 20, 25],\n       ['2019-12342', 'Heung-min Son', 10, 15, 30, 15],\n       ['2018-32234', 'hynn', 7, 20, 30, 15],\n       ['2022-42323', 'Minji', 8, 20, 20, 35],\n       ['2023-55342', 'Hanni', 7, 20, 30, 35],\n       ['2022-46624', 'Danielle', 3, 15, 30, 40],\n       ['2022-11239', 'Haerin', 10, 20, 30, 40],\n       ['2022-32114', 'Hyein', 10, 20, 20, 35]]\nlst \n\n[['2021-43052', 'GuebinChoi', 5, 10, 20, 25],\n ['2019-12342', 'Heung-min Son', 10, 15, 30, 15],\n ['2018-32234', 'hynn', 7, 20, 30, 15],\n ['2022-42323', 'Minji', 8, 20, 20, 35],\n ['2023-55342', 'Hanni', 7, 20, 30, 35],\n ['2022-46624', 'Danielle', 3, 15, 30, 40],\n ['2022-11239', 'Haerin', 10, 20, 30, 40],\n ['2022-32114', 'Hyein', 10, 20, 20, 35]]\n\n\n중간고사와 기말고사의 합이 60점 이상인 학생은 몇명인가? (확장 가능한 코드만 정답으로 인정)\n(풀이)\n\nlen([l for l in lst if sum(l[-2:])&gt;=60])\n\n3\n\n\n\n\n2. – 10점\n아래의 list를 관찰하라.\n\nlst = ['2022/09/21','2022/10/30','2022/12/25','2023/01/01','2023/01/31','2023/03/20']\n\n이를 아래와 같은 리스트로 변환하는 코드를 작성하라. (확장 가능한 코드만 정답으로 인정)\n\n['2022.09.21.','2022.10.30.','2022.12.25.','2023.01.01.','2023.01.31.','2023.03.20.']\n\n['2022.09.21.',\n '2022.10.30.',\n '2022.12.25.',\n '2023.01.01.',\n '2023.01.31.',\n '2023.03.20.']\n\n\n(풀이)\n\n[l.replace('/','.')+'.' for l in lst]\n\n['2022.09.21.',\n '2022.10.30.',\n '2022.12.25.',\n '2023.01.01.',\n '2023.01.31.',\n '2023.03.20.']\n\n\n\n\n3. – 10점\n아래의 문자열을 관찰하라.\n\ntest_arr = 'ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@mylaptop.local'\n\n‘A’ 가 몇개 있는지 count하라\n(풀이)\n\nlist(test_arr).count('A')\n\n18\n\n\n\ntest_arr.count('A')\n\n18\n\n\n\n\n4. – 10점\n\n모두 맞출경우만 정답으로 인정\n\n(1) 아래의 조건을 만족하는 자료형 a를 선언하라.\n\ntype(a), len(a), a[0]\n\n(tuple, 1, 'a')\n\n\n(풀이)\n\na= ('a',)\n\n\ntype(a), len(a), a[0]\n\n(tuple, 1, 'a')\n\n\n(2) 아래와 같은 출력결과를 보이는 numpy array a,b 를 선언하라.\n\na, a.shape\n\n(array(3), ())\n\n\n\nb, b.shape\n\n(array([3]), (1,))\n\n\n(풀이)\n\na = np.array(3)\nb = np.array([3])\n\n\na, a.shape\n\n(array(3), ())\n\n\n\nb, b.shape\n\n(array([3]), (1,))\n\n\n\n\n5. – 20점\n\n모두 맞출경우만 정답으로 인정\n\n아래와 같은 2차원 numpy array를 선언하라.\n\nnp.random.seed(43052)\nX = np.random.randn(20,5).round(2)\nX\n\narray([[ 0.38,  1.08,  1.14,  0.31,  0.24],\n       [ 0.36, -1.66, -1.38, -1.93, -1.49],\n       [ 0.01, -0.03, -0.34,  0.71, -1.55],\n       [ 1.35, -0.06, -0.83, -1.46, -0.35],\n       [-0.34,  0.76,  2.22, -1.72,  1.59],\n       [ 0.37,  0.77, -0.43,  0.77,  0.92],\n       [-0.45,  0.32,  0.82, -0.17,  1.13],\n       [ 0.21, -1.68, -0.3 ,  0.62, -0.3 ],\n       [-0.25, -1.16, -1.29, -0.63, -0.7 ],\n       [ 1.27,  0.84, -1.46, -0.17,  1.29],\n       [ 0.36, -0.1 , -0.83, -0.65,  0.07],\n       [-2.47,  1.39, -0.06, -0.84, -0.38],\n       [ 1.33,  0.17, -0.51, -1.27,  1.74],\n       [-0.36, -0.18,  0.62,  0.45, -0.4 ],\n       [-1.07, -0.18, -1.42, -0.69,  0.74],\n       [ 2.19, -1.15, -0.28, -0.5 , -1.66],\n       [-2.22,  0.42, -0.59,  0.17, -0.01],\n       [-1.83,  0.26, -0.61,  0.14, -0.02],\n       [-0.99,  0.73,  0.37,  0.34,  0.55],\n       [ 1.31,  0.41, -0.19,  1.06,  1.19]])\n\n\n(1) 열별로(column-wise) X의 평균을 계산하라.\n\n# 답: np.array([-0.042 ,  0.0475, -0.2675, -0.273 ,  0.13  ])\n\n(풀이)\n\nX.mean(axis=0)\n\narray([-0.042 ,  0.0475, -0.2675, -0.273 ,  0.13  ])\n\n\n(2) 행별로(row-wise) X의 최대값과 최소값의 차이를 계산하라.\n\n# 답: np.array([0.9 , 2.29, 2.26, 2.81, 3.94, 1.35, 1.58, 2.3 , 1.04, 2.75, 1.19, 3.86, 3.01, 1.02, 2.16, 3.85, 2.64, 2.09, 1.72, 1.5 ])\n\n(풀이)\n\nX.max(axis=1) - X.min(axis=1) \n\narray([0.9 , 2.29, 2.26, 2.81, 3.94, 1.35, 1.58, 2.3 , 1.04, 2.75, 1.19,\n       3.86, 3.01, 1.02, 2.16, 3.85, 2.64, 2.09, 1.72, 1.5 ])\n\n\n\n\n6. – 40점\n\n각 20점\n\n아래의 코드를 실행하여 data를 생성하라.\n\ndata = pd.read_csv('https://raw.githubusercontent.com/guebin/DV2021/master/_notebooks/2021-10-25-FIFA22_official_data.csv').drop(['Loaned From','Marking'],axis=1).dropna().loc[:,['Name','Nationality','Overall']].to_numpy().tolist()\n\ndata는 list로 만들어져 있으며 각 원소는 축구선수들의 능력치를 나타낸다. data의 각 원소는 [이름,소속국가,능력치]를 의미하며 처음 5개의 원소는 아래와 같다.\n\ndata[:5]\n\n[['Bruno Fernandes', 'Portugal', 88],\n ['L. Goretzka', 'Germany', 87],\n ['L. Suárez', 'Uruguay', 88],\n ['K. De Bruyne', 'Belgium', 91],\n ['M. Acuña', 'Argentina', 84]]\n\n\n(1) 아래의 dictionary를 이용하여 data의 국가이름을 대륙이름으로 바꾸라.\n\ncontinent_dict = {\n    'Asia': ['Afghanistan', 'Japan', 'Macau', 'Chinese Taipei', 'Indonesia', 'Korea Republic', 'Kazakhstan', 'Kyrgyzstan', 'Bhutan', 'Philippines', 'Syria', 'China PR', 'Oman', 'Guam', 'Vietnam', 'Jordan', 'Palestine', 'Malaysia', 'Hong Kong', 'Korea DPR', 'Lebanon', 'Uzbekistan', 'India','Iraq', 'Iran', 'Saudi Arabia', 'United Arab Emirates','Australia'],\n    'Europe': ['Portugal', 'Germany', 'Belgium', 'Netherlands', 'Croatia', 'Spain', 'Austria', 'Italy', 'France', 'Serbia', 'England', 'Poland', 'Ukraine', 'Wales', 'Scotland', 'Czech Republic', 'Slovakia', 'Romania', 'Bosnia and Herzegovina', 'Republic of Ireland', 'Norway', 'Sweden', 'Bulgaria', 'Lithuania', 'Estonia', 'Latvia', 'Liechtenstein','Albania','Denmark','Finland','Greece','Hungary','Iceland','Luxembourg','Northern Ireland','Slovenia','Switzerland','Andorra','Azerbaijan','Belarus','Cyprus','Faroe Islands','Georgia','Kosovo','Malta','Moldova','Montenegro','North Macedonia','Armenia','Gibraltar','Russia','Turkey','Israel'],\n    'South America': ['Uruguay', 'Argentina', 'Brazil', 'Chile', 'Colombia', 'Ecuador', 'Paraguay', 'Venezuela', 'Suriname', 'Bolivia','Peru','Guyana'],\n    'Africa': ['Egypt', \"Côte d'Ivoire\", 'Senegal', 'Morocco', 'Ghana', 'Algeria', 'Guinea', 'Mali', 'Congo DR', 'Liberia', 'Cameroon', 'Tunisia', 'Comoros', 'Kenya', 'South Africa', 'Zimbabwe', 'Madagascar', 'Mozambique', 'Equatorial Guinea', 'Congo', 'Burundi', 'Grenada', 'Thailand', 'Togo', 'Sudan', 'Mauritania','Guinea Bissau','Libya','Nigeria','Zambia','Angola','Benin','Burkina Faso','Cape Verde Islands','Central African Republic','Chad','Eritrea','Gabon','Gambia','Mauritius','Namibia','Rwanda','Sierra Leone','South Sudan','São Tomé e Príncipe','Uganda','Niger'],\n    'North and Central America': ['Antigua and Barbuda', 'Barbados', 'Belize', 'Bermuda', 'Canada', 'Costa Rica', 'Cuba', 'Curacao', 'Dominican Republic', 'El Salvador', 'Guatemala', 'Haiti', 'Honduras', 'Jamaica', 'Mexico', 'Montserrat', 'Panama', 'Puerto Rico', 'Saint Kitts and Nevis', 'Saint Lucia', 'Trinidad and Tobago', 'United States'],\n    'Oceania': ['New Zealand', 'Fiji', 'Papua New Guinea','New Caledonia'],\n}\n\n바뀐 data의 처음 5개의 출력결과는 아래와 같다.\n[['Bruno Fernandes', 'Europe', 88],\n ['L. Goretzka', 'Europe', 87],\n ['L. Suárez', 'South America', 88],\n ['K. De Bruyne', 'Europe', 91],\n ['M. Acuña', 'South America', 84]]\n(풀이)\n\ndata2 = [[name,key,overall] for name,nationality,overall in data for key in continent_dict if nationality in continent_dict[key]]\n\n(2) 능력치가 80 보다 큰 선수들은 대륙별로 몇명의 선수가 있는가? count하라.\n\n# 답\n# {'South America': 71,\n#  'Africa': 21,\n#  'North and Central America': 8,\n#  'Europe': 272,\n#  'Asia': 1}\n\n(풀이)\n\nlst = [continent for _,continent,overall in data2 if overall&gt;80]\n\n\n{s:lst.count(s) for s in set(lst)}\n\n{'Africa': 21,\n 'North and Central America': 8,\n 'Europe': 272,\n 'South America': 71,\n 'Asia': 1}"
  },
  {
    "objectID": "posts/02wk-1.html",
    "href": "posts/02wk-1.html",
    "title": "02wk-1: 퀴즈1",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt \n\n\n\n\n\n\n\nWarning\n\n\n\n\n모든 문항은 부분점수 없음.\n일부문항은 부분문제를 모두 맞출경우만 정답으로 인정함.\n.ipynb 파일 형태로 제출된 답안지만 채점하며 그 외의 형식 (.hwp등)은 채점하지 않음. 즉 0점 처리함. 제출방법 모르면 물어볼것!\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\n\n전북대 학생들을 시험당일 학생증을 지참할 것. (출석체크 및 본인확인) 학생증 외에 신분증 여권등도 가능.\n부정행위 (카카오톡 채팅을 통한 코드공유, 생성형모델 사용, 대리시험 등) 적발시 F 처리함.\n퀴즈 중 지각할 경우 지각사실을 기록함. 하지만 별다른 감점은 하지 않음.\n\n\n\n\n문제 1. – 10점\n\n모두 맞출 경우만 정답으로 인정\n\n(1) 아래와 같이 50개의 숫자를 나열한 배열 \\({\\bf x}=[x_1,x_2,\\dots,x_n]\\)을 상상하자.\n\nx = np.array([0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1,\n              0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,\n              0, 0, 0, 0, 1, 0])\nx\n\narray([0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1,\n       0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,\n       0, 0, 0, 0, 1, 0])\n\n\n위와 같은 \\(x_i\\)에 대하여 \\(0&lt;p&lt;1\\)에서의 아래와 같은 함수 \\(l(p)\\)를 정의하라.\n\\[l(p)=\\sum_{i=1}^nx_i \\log p +\\left(n-\\sum_{i=1}^{n}x_i \\right)\\log(1-p)\\]\n파이썬을 이용하여 아래를 근사계산하라.\n\\[\\lim_{h \\to 0}\\frac{l(0.32+h)-l(0.32)}{h}\\]\n(풀이)\n\nl = lambda p: 16*np.log(p) + (50-16)*np.log(1-p)\nh =0.000000001\n(l(0.32+h)-l(0.32))/h\n\n3.5527136788005005e-06\n\n\n(2) \\(0&lt;p&lt;1\\)의 범위에서 \\(l(p)\\)를 최대로 만드는 \\(p\\)의 값을 구하라. 즉 \\(\\underset{p}{\\operatorname{argmax}} l(p)\\)를 구하라.\n(풀이)\n\np = np.linspace(1/100,1,100)[:-1]\np\n\narray([0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1 , 0.11,\n       0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.2 , 0.21, 0.22,\n       0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3 , 0.31, 0.32, 0.33,\n       0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4 , 0.41, 0.42, 0.43, 0.44,\n       0.45, 0.46, 0.47, 0.48, 0.49, 0.5 , 0.51, 0.52, 0.53, 0.54, 0.55,\n       0.56, 0.57, 0.58, 0.59, 0.6 , 0.61, 0.62, 0.63, 0.64, 0.65, 0.66,\n       0.67, 0.68, 0.69, 0.7 , 0.71, 0.72, 0.73, 0.74, 0.75, 0.76, 0.77,\n       0.78, 0.79, 0.8 , 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87, 0.88,\n       0.89, 0.9 , 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99])\n\n\n\np[np.argmax(l(p))]\n\n0.32\n\n\n\n\n문제 2. – 10점\n\n모두 맞출 경우만 정답으로 인정\n\n길이가 100인 벡터 \\({\\bf x} = [x_0, x_1, \\dots, x_{99}]\\)를 아래와 같이 선언하라.\n\nnp.random.seed(43052)\nx = np.random.randn(100)\n\n(1) \\(x_0\\)의 값은 얼마인가?\n(풀이)\n\nx[0]\n\n0.38342048800857303\n\n\n(2) \\(x_{99}\\)의 값은 얼마인가?\n(풀이)\n\nx[99]\n\n1.1870144262405193\n\n\n(3) \\(\\sum_{i=0}^{99} x_i\\)의 값은 얼마인가?\n(풀이)\n\nnp.sum(x)\n\n-8.136079223187856\n\n\n(4) \\(\\sum_{i=22}^{55} x_i\\)의 값은 얼마인가?\n(풀이)\n\nnp.sum(x[22:56])\n\n-1.1780743585314586\n\n\n\n\n문제 3. – 10점\n길이가 100인 벡터 \\({\\bf x} = [x_0, x_1, \\dots, x_{99}]\\)를 아래와 같이 선언하라.\n\nnp.random.seed(43052)\nx = np.random.randn(100)\n\n이 벡터에 대하여\n\n\\(a=\\sum_{i=0}^{24}x_i\\)\n\\(b=\\sum_{i=25}^{49}x_i\\)\n\\(c=\\sum_{i=50}^{74}x_i\\)\n\\(d=\\sum_{i=75}^{99}x_i\\)\n\n의 값을 각각 조사하라. a,b,c,d 중 가장 큰 값은 무엇인가?\n(풀이)\n\na = np.sum(x[:25])\nb = np.sum(x[25:50])\nc = np.sum(x[50:75])\nd = np.sum(x[75:])\n\n\na,b,c,d\n\n(-3.006728261055644,\n 0.3368136525904264,\n -4.526860531092521,\n -0.9393040836301192)\n\n\n\n\n문제 4. – 10점\n\n모두 맞출 경우만 정답으로 인정\n\n(1) lambda를 이용하여 \\(f(x)=\\sin(x)\\)에 대응하는 함수를 선언하라.\n(풀이)\n\nlambda x: np.sin(x)\n\n&lt;function __main__.&lt;lambda&gt;(x)&gt;\n\n\n(2) def를 이용하여 \\(g(x)=\\cos(2x)\\)에 대응하는 함수를 선언하라.\n(풀이)\n\ndef g(x):\n    return np.cos(2*x)\n\n(3) 임의의 벡터 \\({\\bf x}=[x_0,\\dots,x_{n-1}]\\) 이 왔을때, \\({\\bf x}\\)의 최대값을 \\(x_{max}\\) 라고 하고 최소값을 \\(x_{min}\\)이라고 하자. 예를들어\n\\[{\\bf x} = [1,2,3,0]\\]\n의 경우 \\(x_{max}=3\\) 이고 \\(x_{min}=0\\) 이다. 벡터 \\({\\bf x}\\)를 입력으로 하고 출력으로 \\(x_{max}-x_{min}\\)의 계산값을 리턴하는 함수를 구현하라.\n(풀이)\n\nf = lambda x: np.max(x) - np.min(x)\n\n\nf([1,2,3,0])\n\n3\n\n\n\nf([-1,2,4,10])\n\n11\n\n\n\n\n문제 5. – 10점\n\n모두 맞출 경우만 정답으로 인정\n\n아래의 코드를 실행하여 x를 생성하라.\n\nnp.random.seed(43052)\nx = np.random.rand(4305)\n\n(1) 생성된 \\(x_i\\) 중 0.65와 가장 가까운 값을 출력하라.\n(풀이)\n\nx[np.argmin(np.abs(x-0.65))]\n\n0.6499741766686671\n\n\n(2) 생성된 값의 평균을 구하라.\nhint \\(\\frac{1}{4305}\\sum_{i=1}^{4305}x_i\\)를 계산하면 된다. 아니면 np.mean() 함수를 이용해도된다.\n(풀이)\n\nnp.sum(x)/4305, np.mean(x)\n\n(0.4965974918744432, 0.4965974918744432)\n\n\n(3) (2)에서 계산된 평균값과 가장 가까운 \\(x_i\\)값을 출력하라.\n(풀이)\n\nx[np.argmin(np.abs(x-np.mean(x)))]\n\n0.497315535600802\n\n\n\n\n문제 6. – 20점\n\\(\\frac{\\pi}{2}\\leq x \\leq \\pi\\) 에서 \\(f(x)=\\sin(\\frac{3}{2}x)\\) 와 \\(g(x)=\\cos(2x)\\sin(5x)\\) 의 교점의 좌표를 구하라.\n\n근사값만구해도 정답으로 인정함\n\n(풀이)\n\nx = np.linspace(np.pi/2, np.pi,1000000)\nf = lambda x: np.sin(3/2*x) \ng = lambda x: np.cos(2*x)*np.sin(5*x)\n\n\nplt.plot(x,f(x))\nplt.plot(x,g(x))\n\n\n\n\n\n\n\n\n\nxx = x[np.argmin(np.abs(f(x)-g(x)))]\nxx\n\n1.9462123119258816\n\n\n\nf(xx), g(xx)\n\n(0.2204484288597834, 0.2204457729878962)\n\n\n\n\n문제 7. – 30점\n(1) 무한급수 \\(\\sum_{n=1}^{\\infty}(\\frac{1}{2})^n\\) 의 수렴 및 발산을 파이썬을 이용하여 판정하라. – 10점\n힌트\n\\(n=10, 20, 30, ..., 100\\) 등에서 \\(S_n=\\sum_{k=1}^{n}a_k\\)의 값을 조사해보고 수렴성을 판단하라.\n(풀이)\n\nn = np.linspace(1,100,100)\nan = (1/2)**n\nSn = np.cumsum(an)\n\n\nSn\n\narray([0.5       , 0.75      , 0.875     , 0.9375    , 0.96875   ,\n       0.984375  , 0.9921875 , 0.99609375, 0.99804688, 0.99902344,\n       0.99951172, 0.99975586, 0.99987793, 0.99993896, 0.99996948,\n       0.99998474, 0.99999237, 0.99999619, 0.99999809, 0.99999905,\n       0.99999952, 0.99999976, 0.99999988, 0.99999994, 0.99999997,\n       0.99999999, 0.99999999, 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ,\n       1.        , 1.        , 1.        , 1.        , 1.        ])\n\n\n수렴한다\n(2) 무한급수 \\(\\sum_{n=1}^{\\infty}\\frac{1}{n}\\) 의 수렴 및 발산을 파이썬을 이용하여 판정하라. – 20점\n힌트 – (1)번과 동일한 테크닉\n(풀이)\n\nn = np.linspace(1,100000000,100000000)\nan = 1/n\nSn = np.cumsum(an)\n\n\nSn\n\narray([ 1.        ,  1.5       ,  1.83333333, ..., 18.99789639,\n       18.9978964 , 18.99789641])\n\n\n발산한다\n\n\n성적분포\n\nimport pandas as pd\n\n\npd.read_csv(\"2wk.csv\")['2wk'].sort_values().to_numpy()\n\narray([  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n         0,   0,   0,  10,  10,  10,  20,  20,  20,  20,  20,  30,  30,\n        30,  30,  40,  40,  40,  40,  40,  50,  50,  50,  50,  50,  50,\n        50,  60,  60,  60,  70,  70,  80,  80,  80,  90,  90, 100, 100,\n       100, 100, 100, 100])"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  }
]